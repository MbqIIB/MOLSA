require({cache:{
'dojo/date':function(){
define("dojo/date", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/date
	// summary:
	//		TODOC

lang.getObject("date", true, dojo);

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}

	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

return dojo.date;
});

},
'dojox/storage/WhatWGStorageProvider':function(){
// wrapped by build app
define("dojox/storage/WhatWGStorageProvider", ["dijit","dojo","dojox","dojo/require!dojox/storage/Provider,dojox/storage/manager"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.WhatWGStorageProvider");
dojo.require("dojox.storage.Provider");
dojo.require("dojox.storage.manager");

dojo.declare("dojox.storage.WhatWGStorageProvider", [ dojox.storage.Provider ], {
	// summary:
	//		Storage provider that uses WHAT Working Group features in Firefox 2
	//		to achieve permanent storage.
	// description:
	//		The WHAT WG storage API is documented at
	//		http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	//
	//		You can disable this storage provider with the following djConfig
	//		variable:
	//		var djConfig = { disableWhatWGStorage: true };
	//
	//		Authors of this storage provider-
	//			JB Boisseau, jb.boisseau@eutech-ssii.com
	//			Brad Neuberg, bkn3@columbia.edu

	initialized: false,
	
	_domain: null,
	_available: null,
	_statusHandler: null,
	_allNamespaces: null,
	_storageEventListener: null,
	
	initialize: function(){
		if(dojo.config["disableWhatWGStorage"] == true){
			return;
		}
		
		// get current domain
		this._domain = location.hostname;
		// console.debug(this._domain);
		
		// indicate that this storage provider is now loaded
		this.initialized = true;
		dojox.storage.manager.loaded();
	},
	
	isAvailable: function(){
		try{
			var myStorage = globalStorage[location.hostname];
		}catch(e){
			this._available = false;
			return this._available;
		}
		
		this._available = true;
		return this._available;
	},

	put: function(key, value, resultsHandler, namespace){
		if(this.isValidKey(key) == false){
			throw new Error("Invalid key given: " + key);
		}
		namespace = namespace||this.DEFAULT_NAMESPACE;
		
		// get our full key name, which is namespace + key
		key = this.getFullKey(key, namespace);
		
		this._statusHandler = resultsHandler;
		
		// serialize the value;
		// handle strings differently so they have better performance
		if(dojo.isString(value)){
			value = "string:" + value;
		}else{
			value = dojo.toJson(value);
		}
		
		// register for successful storage events.
		var storageListener = dojo.hitch(this, function(evt){
			// remove any old storage event listener we might have added
			// to the window on old put() requests; Firefox has a bug
			// where it can occassionaly go into infinite loops calling
			// our storage event listener over and over -- this is a
			// workaround
			// FIXME: Simplify this into a test case and submit it
			// to Firefox
			window.removeEventListener("storage", storageListener, false);
			
			// indicate we succeeded
			if(resultsHandler){
				resultsHandler.call(null, this.SUCCESS, key, null, namespace);
			}
		});
		
		window.addEventListener("storage", storageListener, false);
		
		// try to store the value
		try{
			var myStorage = globalStorage[this._domain];
			myStorage.setItem(key, value);
		}catch(e){
			// indicate we failed
			this._statusHandler.call(null, this.FAILED, key, e.toString(), namespace);
		}
	},

	get: function(key, namespace){
		if(this.isValidKey(key) == false){
			throw new Error("Invalid key given: " + key);
		}
		namespace = namespace||this.DEFAULT_NAMESPACE;
		
		// get our full key name, which is namespace + key
		key = this.getFullKey(key, namespace);
		
		// sometimes, even if a key doesn't exist, Firefox
		// will return a blank string instead of a null --
		// this _might_ be due to having underscores in the
		// keyname, but I am not sure.
		
		// FIXME: Simplify this bug into a testcase and
		// submit it to Firefox
		var myStorage = globalStorage[this._domain];
		var results = myStorage.getItem(key);
		
		if(results == null || results == ""){
			return null;
		}
		
		results = results.value;
		
		// destringify the content back into a
		// real JavaScript object;
		// handle strings differently so they have better performance
		if(dojo.isString(results) && (/^string:/.test(results))){
			results = results.substring("string:".length);
		}else{
			results = dojo.fromJson(results);
		}
		
		return results;
	},
	
	getNamespaces: function(){
		var results = [ this.DEFAULT_NAMESPACE ];
		
		// simply enumerate through our array and save any string
		// that starts with __
		var found = {};
		var myStorage = globalStorage[this._domain];
		var tester = /^__([^_]*)_/;
		for(var i = 0; i < myStorage.length; i++){
			var currentKey = myStorage.key(i);
			if(tester.test(currentKey) == true){
				var currentNS = currentKey.match(tester)[1];
				// have we seen this namespace before?
				if(typeof found[currentNS] == "undefined"){
					found[currentNS] = true;
					results.push(currentNS);
				}
			}
		}
		
		return results;
	},

	getKeys: function(namespace){
		namespace = namespace||this.DEFAULT_NAMESPACE;
		
		if(this.isValidKey(namespace) == false){
			throw new Error("Invalid namespace given: " + namespace);
		}
		
		// create a regular expression to test the beginning
		// of our key names to see if they match our namespace;
		// if it is the default namespace then test for the presence
		// of no namespace for compatibility with older versions
		// of dojox.storage
		var namespaceTester;
		if(namespace == this.DEFAULT_NAMESPACE){
			namespaceTester = new RegExp("^([^_]{2}.*)$");
		}else{
			namespaceTester = new RegExp("^__" + namespace + "_(.*)$");
		}
		
		var myStorage = globalStorage[this._domain];
		var keysArray = [];
		for(var i = 0; i < myStorage.length; i++){
			var currentKey = myStorage.key(i);
			if(namespaceTester.test(currentKey) == true){
				// strip off the namespace portion
				currentKey = currentKey.match(namespaceTester)[1];
				keysArray.push(currentKey);
			}
		}
		
		return keysArray;
	},

	clear: function(namespace){
		namespace = namespace||this.DEFAULT_NAMESPACE;
		
		if(this.isValidKey(namespace) == false){
			throw new Error("Invalid namespace given: " + namespace);
		}
		
		// create a regular expression to test the beginning
		// of our key names to see if they match our namespace;
		// if it is the default namespace then test for the presence
		// of no namespace for compatibility with older versions
		// of dojox.storage
		var namespaceTester;
		if(namespace == this.DEFAULT_NAMESPACE){
			namespaceTester = new RegExp("^[^_]{2}");
		}else{
			namespaceTester = new RegExp("^__" + namespace + "_");
		}
		
		var myStorage = globalStorage[this._domain];
		var keys = [];
		for(var i = 0; i < myStorage.length; i++){
			if(namespaceTester.test(myStorage.key(i)) == true){
				keys[keys.length] = myStorage.key(i);
			}
		}
		
		dojo.forEach(keys, dojo.hitch(myStorage, "removeItem"));
	},
	
	remove: function(key, namespace){
		// get our full key name, which is namespace + key
		key = this.getFullKey(key, namespace);
		
		var myStorage = globalStorage[this._domain];
		myStorage.removeItem(key);
	},
	
	isPermanent: function(){
		return true;
	},

	getMaximumSize: function(){
		return this.SIZE_NO_LIMIT;
	},

	hasSettingsUI: function(){
		return false;
	},
	
	showSettingsUI: function(){
		throw new Error(this.declaredClass + " does not support a storage settings user-interface");
	},
	
	hideSettingsUI: function(){
		throw new Error(this.declaredClass + " does not support a storage settings user-interface");
	},
	
	getFullKey: function(key, namespace){
		namespace = namespace||this.DEFAULT_NAMESPACE;
		
		if(this.isValidKey(namespace) == false){
			throw new Error("Invalid namespace given: " + namespace);
		}
		
		// don't append a namespace string for the default namespace,
		// for compatibility with older versions of dojox.storage
		if(namespace == this.DEFAULT_NAMESPACE){
			return key;
		}else{
			return "__" + namespace + "_" + key;
		}
	}
});

dojox.storage.manager.register("dojox.storage.WhatWGStorageProvider",
								new dojox.storage.WhatWGStorageProvider());

});

},
'curam/util/Request':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 04-Mar-2014  MV  [CR00421036] Use new LocalConfig API to read options, make
 *      login page detector configurable, add documentation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

define("curam/util/Request", ['dojo/_base/xhr',
        'curam/debug',
        'curam/util/ResourceBundle',
        'curam/util/LocalConfig'
        ], function(xhr, debug, ResourceBundle, localConfig) {
  
  dojo.requireLocalization("curam.application", "Request");

  var bundle = new ResourceBundle("Request"),

      // holds custom login page detector function, if one was provided
      // by the API client
      _isLoginPage = null,
        
      /**
       * Check for a login page based on the presence of this HTML tag:
       * <form action="j_security_check" ...>
       * 
       * @param request The XHR request object.
       * @return True if the response is a login page, otherwise False.
       */
      isLoginPage = function(request) {
        // if custom login page detector was provided use it
        if (_isLoginPage) {
          return _isLoginPage(request);

        // or fall back to default detection method
        } else {
          return request.responseText.indexOf(
              "action=\"j_security_check\"") > 0;
        }
      },

      errorDisplayHookpoint = function(err, ioargs) {
        if (isLoginPage(ioargs.xhr)) {
          // session timeout scenario
          debug.log(bundle.getProperty('sessionExpired'));
          alert(bundle.getProperty('sessionExpired'));

        } else {
          // display generic error message
          debug.log(bundle.getProperty('ajaxError'));
          alert(bundle.getProperty('ajaxError'));
        }

        // log the error
        debug.log(err);
        debug.log('HTTP status was: ' + ioargs.xhr.status);
      },
      
      _xhr = function(method, args) {
        var ajaxDebugMode =
                localConfig.readOption('ajaxDebugMode', 'false') == 'true';

        var error = args.error;
        
        // only enable common error handling if debug mode is on
        if (ajaxDebugMode) {
          args.error = function(err, ioargs) {
            if (args.errorHandlerOverrideDefault !== true) {
              errorDisplayHookpoint(err, ioargs);
            }

            // make sure custom error handler gets called, if there is one
            if (error) {
              error(err, ioargs);
            }
          };
        }

        var deferred = method(args);
        return deferred;
      };

  /**
   * @name curam.util.Request
   * @namespace AJAX request API with common error handling and login page
   * detection. It is designed as a near drop-in replacement for the dojo.xhr*
   * group of functions.
   * <p/>
   * By default this API will behave exactly like it's dojo.xhr* counterpart.
   * <p/>
   * But if the "curam.trace.javascript.ajax.report" application property is set
   * to true then common error reporting is used, causing every AJAX request
   * failure to be reported to the user in a friendly dialog with details
   * written to the JavaScript trace log (if it is enabled).<br/>
   * Session timeouts will be reported differently, asking the user to log
   * in again.
   * <p/>
   * Note that by default the common reporting will work alongside any custom
   * error handlers specified by the API client. However if
   * the "errorHandlerOverrideDefault" property is present on the args
   * object and is set to true, then a provided custom error handler will
   * override the default handling provided by this API.
   */
  var Request = 
    /**
     * @lends curam.util.Request.prototype
     */
    {
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html">dojo.xhrPost</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the post() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html#dojo-xhrpost-supported-object-properties">dojo.xhrPost documentation</a>
       * @returns {dojo.Deferred} Same return type as get(). See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      post: function(args) {
        return _xhr(xhr.post, args);
      },
      
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html">dojo.xhrGet</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the get() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#dojo-xhrget-supported-object-properties">dojo.xhrGet documentation</a>
       * @returns {dojo.Deferred} See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      get: function(args) {
        return _xhr(xhr.get, args);
      },
      
      /**
       * Allows to optionally customize the way to detect that a response
       * from an AJAX request is a login page.
       * 
       * This is optional and if custom detector function is not provided
       * the API will by default recognize login pages that contain a HTML form
       * that submits into the standard "j_security_check" mechanism.
       * 
       * If null is passed the default detection method will be used.
       * 
       * @param {function(dojoXhrRequestObject)::boolean} detectorFunction
       *        The function to be used for detecting login page based on the
       *        <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#handling-status-codes">Dojo XHR
       *        request object.</a>
       */
      setLoginPageDetector: function(detectorFunction) {
        _isLoginPage = detectorFunction;
      }
    };

  return Request;
});

},
'url:idx/oneui/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\r\n\t<tbody class=\"dijitReset\">\r\n\t\t<tr data-dojo-attach-point=\"_columnContainerNode\">\r\n\t\t\t<td class=\"dijitReset oneuiMenuColumn\" data-dojo-attach-point=\"columnNodes\">\r\n\t\t\t\t<table class=\"dijitReset\" cellspacing=\"0\" width=\"100%\" role=\"presentation\">\r\n\t\t\t\t\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"_containerNodes,containerNode\">\r\n<!-- this is column 0, which also starts out as the container node so menu items are initially loaded here.\r\n     containerNode changes to point to _columnContainerNode once the widget has initialised, so the whole set of columns is the container.\r\n\t this must be kept in synch with _MenuColumn.html -->\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n",
'dijit/MenuBar':function(){
require({cache:{
'url:dijit/templates/MenuBar.html':"<div class=\"dijitMenuBar dijitMenuPassive\" data-dojo-attach-point=\"containerNode\"  role=\"menubar\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress: _onKeyPress\"></div>\n"}});
define("dijit/MenuBar", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys.DOWN_ARROW
	"./_MenuBase",
	"dojo/text!./templates/MenuBar.html"
], function(declare, event, keys, _MenuBase, template){

/*=====
	var _MenuBase = dijit._MenuBase;
=====*/

// module:
//		dijit/MenuBar
// summary:
//		A menu bar, listing menu choices horizontally, like the "File" menu in most desktop applications

return declare("dijit.MenuBar", _MenuBase, {
	// summary:
	//		A menu bar, listing menu choices horizontally, like the "File" menu in most desktop applications

	templateString: template,

	baseClass: "dijitMenuBar",

	// _isMenuBar: [protected] Boolean
	//		This is a MenuBar widget, not a (vertical) Menu widget.
	_isMenuBar: true,

	postCreate: function(){
		var l = this.isLeftToRight();
		this.connectKeyNavHandlers(
			l ? [keys.LEFT_ARROW] : [keys.RIGHT_ARROW],
			l ? [keys.RIGHT_ARROW] : [keys.LEFT_ARROW]
		);

		// parameter to dijit.popup.open() about where to put popup (relative to this.domNode)
		this._orient = ["below"];
	},

	focusChild: function(item){
		// overload focusChild so that whenever the focus is moved to a new item,
		// check the previous focused whether it has its popup open, if so, after
		// focusing the new item, open its submenu immediately
		var prev_item = this.focusedChild,
			showpopup = prev_item && prev_item.popup && prev_item.popup.isShowingNow;
		this.inherited(arguments);
		if(showpopup && item.popup && !item.disabled){
			this._openPopup();		// TODO: on down arrow, _openPopup() is called here and in onItemClick()
		}
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case keys.DOWN_ARROW:
				this._moveToPopup(evt);
				event.stop(evt);
		}
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item. Cancels a dropdown if already open.
		// tags:
		//		private
		if(item.popup && item.popup.isShowingNow){
			item.popup.onCancel();
		}else{
			this.inherited(arguments);
		}
	}
});

});

},
'idx/oneui/form/TextBox':function(){
require({cache:{
'url:idx/oneui/form/templates/TextBox.html':"<div id=\"widget_${id}\" class=\"dijitInline dijitReset dijitLeft idxComposite\"\r\n\t><div class=\"idxLabel dijitInline dijitHidden\"><span class=\"idxRequiredIcon\">*&nbsp</span><label for=\"${id}\" dojoAttachPoint=\"compLabelNode\"></label></div\r\n\t><div class=\"dijitInline\"\r\n\t\t><div dojoAttachPoint='stateNode,oneuiBaseNode' class=\"dijit dijitReset dijitInline dijitLeft\" role=\"presentation\"\r\n\t\t\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\" ${!nameAttrSetting} type='${type}'/\r\n\t\t\t></div\r\n\t\t></div\r\n\t\t><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"></div\r\n\t\t><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\r\n\t\t><div class='dijitValidationIcon'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\r\n\t\t></div\r\n\t></div\r\n\t><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\r\n\t></div\r\n></div>\r\n"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/form/TextBox", [
	"dojo/_base/declare",
	"dojo/dom-style",
	"dijit/form/TextBox",
	"dijit/form/ValidationTextBox",
	"../HoverHelpTooltip",
	"../_CssStateMixin",
	"./_CompositeMixin",
	"dojo/text!./templates/TextBox.html"
], function(declare, domStyle, TextBox, ValidationTextBox, HoverHelpTooltip, _CssStateMixin, _CompositeMixin, template){
/**
	 * @name idx.oneui.form.TextBox
	 * @class One UI version.
	 * @augments dijit.form.TextBox
	 */
	 
	return declare("idx.oneui.form.TextBox", [ValidationTextBox, _CssStateMixin, _CompositeMixin], {
		/**@lends idx.oneui.form.TextBox*/
		
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		// instantValidate: Boolean
		//		Fire validation when widget get input by set true, 
		//		fire validation when widget get blur by set false
		instantValidate: false,
		templateString: template,
		baseClass: "idxTextBoxWrap",
		oneuiBaseClass: "dijitTextBox dijitValidationTextBox",
		
		postCreate: function(){
			this.inherited(arguments);
			if(this.instantValidate){
				this.connect(this, "_onInput", function(){
					this.validate(this.focused);
				});
			}else{
				this.connect(this, "_onBlur", function(){
					this.validate(this.focused);
				});
				this.connect(this, "_onFocus", function(){
					this._set("state", "");
					if(this.message == ""){return;}
					this.displayMessage(this.message);
					this.message = "";
				});
				this.connect(this, "_onInput", function(){
					this.displayMessage();
				});
			}
			this.connect(this.iconNode, "onmouseenter", function(){
				if(this.message && domStyle.get(this.iconNode, "visibility") == "visible"){
					HoverHelpTooltip.show(this.message, this.iconNode, this.tooltipPosition, !this.isLeftToRight());
				}
			});
			
		},
		/**
		* Overridable method to display validation errors/hints
		*/
		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a oneui.HoverHelpTooltip.
			// tags:
			//		extension
			HoverHelpTooltip.hide(this.oneuiBaseNode);
			HoverHelpTooltip.hide(this.iconNode);
			if(message && this.focused){
				var node = domStyle.get(this.iconNode, "visibility") == "hidden" ? this.oneuiBaseNode : this.iconNode;
				HoverHelpTooltip.show(message, node, this.tooltipPosition, !this.isLeftToRight());
			}
		},
		/**
		* use set("value", val) to set the value of the Textbox
		*/
		_setValueAttr: function(){
			TextBox.prototype._setValueAttr.apply(this, arguments);
		},
		_refreshState: function(){
			TextBox.prototype._refreshState.apply(this, arguments);
		}
	});
});

},
'dijit/Dialog':function(){
require({cache:{
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n"}});
define("dijit/Dialog", [
	"require",
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/connect", // connect._keypress
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/_base/event", // event.stop
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/kernel", // kernel.isAsync
	"dojo/keys",
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/_base/sniff", // has("ie") has("opera")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"./focus",
	"./_base/manager",	// manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_CssStateMixin",
	"./form/_FormMixin",
	"./_DialogMixin",
	"./DialogUnderlay",
	"./layout/ContentPane",
	"dojo/text!./templates/Dialog.html",
	".",			// for back-compat, exporting dijit._underlay (remove in 2.0)
	"dojo/i18n!./nls/common"
], function(require, array, connect, declare, Deferred,
			dom, domClass, domGeometry, domStyle, event, fx, i18n, kernel, keys, lang, on, ready, has, win, winUtils,
			Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin,
			DialogUnderlay, ContentPane, template, dijit){
	
/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _CssStateMixin = dijit._CssStateMixin;
	var _FormMixin = dijit.form._FormMixin;
	var _DialogMixin = dijit._DialogMixin;
=====*/	


	// module:
	//		dijit/Dialog
	// summary:
	//		A modal dialog Widget


	/*=====
	dijit._underlay = function(kwArgs){
		// summary:
		//		A shared instance of a `dijit.DialogUnderlay`
		//
		// description:
		//		A shared instance of a `dijit.DialogUnderlay` created and
		//		used by `dijit.Dialog`, though never created until some Dialog
		//		or subclass thereof is shown.
	};
	=====*/

	var _DialogBase = declare("dijit._DialogBase", [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div data-dojo-type="dijit.Dialog" data-dojo-props="href: 'test.html'"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: template,

		baseClass: "dijitDialog",

		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		// Map widget attributes to DOMNode attributes.
		_setTitleAttr: [
			{ node: "titleNode", type: "innerHTML" },
			{ node: "titleBar", type: "attribute" }
		],

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: manager.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog. The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div data-dojo-type="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = i18n.getLocalization("dijit", "common");
			lang.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			domStyle.set(this.domNode, {
				display: "none",
				position:"absolute"
			});
			win.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this._position();
			if(this.autofocus && DialogLevelManager.isTop(this)){
				this._getFocusItems(this.domNode);
				focus.focus(this._firstFocusItem);
			}
			this.inherited(arguments);
		},

		_endDrag: function(){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport,
			//		and also adjust position to be fully within the viewport, so user doesn't lose access to handle
			var nodePosition = domGeometry.position(this.domNode),
				viewport = winUtils.getBox();
			nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
			nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
			this._relativePosition = nodePosition;
			this._position();
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.titleBar });
				this.connect(this._moveable, "onMoveStop", "_endDrag");
			}else{
				domClass.add(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": array.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the domGeometry.position(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				domStyle.set(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var bb = domGeometry.position(this.domNode);
			var viewport = winUtils.getBox();
			if(bb.w >= viewport.w || bb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(bb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(bb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					domStyle.set(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			if(!domClass.contains(win.body(), "dojoMove")){	// don't do anything if called during auto-scroll
				var node = this.domNode,
					viewport = winUtils.getBox(),
					p = this._relativePosition,
					bb = p ? null : domGeometry.position(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				domStyle.set(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.charOrCode){
				var node = evt.target;
				if(evt.charOrCode === keys.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB){
					if(!singleFocusItem){
						focus.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					event.stop(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						focus.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					event.stop(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || domClass.contains(node, "dijitPopup")){
							if(evt.charOrCode == keys.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== keys.TAB){ // allow tabbing into the dialog for a11y
						event.stop(evt);
					// opera won't tab to a div
					}else if(!has("opera")){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the display animation is complete

			if(this.open){ return; }

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}

			if(!has("touch")){
				// If the user scrolls the display or resizes the viewport then reposition the Dialog.  But don't do it
				// for touch devices, because it will counteract when a keyboard pops up and then the browser
				// auto-scrolls the focused node into view.
				this._modalconnects.push(on(window, "scroll", lang.hitch(this, "layout")));
				this._modalconnects.push(on(window, "resize", lang.hitch(this, function(){
					// IE gives spurious resize events and can actually get stuck
					// in an infinite loop if we don't ignore them
					var viewport = winUtils.getBox();
					if(!this._oldViewport ||
							viewport.h != this._oldViewport.h ||
							viewport.w != this._oldViewport.w){
						this.layout();
						this._oldViewport = viewport;
					}
				})));
			}
			this._modalconnects.push(on(this.domNode, connect._keypress, lang.hitch(this, "_onKey")));

			domStyle.set(this.domNode, {
				opacity:0,
				display:""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this._size();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new Deferred(lang.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			fadeIn = fx.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: lang.hitch(this, function(){
					DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: lang.hitch(this, function(){
					if(this.autofocus && DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						focus.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.callback(true);
					delete this._fadeInDeferred;
				})
			}).play();

			return this._fadeInDeferred;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the hide animation is complete

			// if we haven't been initialized yet then we aren't showing and we can just return
			if(!this._alreadyInitialized){
				return;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new Deferred(lang.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));
			// fire onHide when the promise resolves.
			this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));

			fadeOut = fx.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: lang.hitch(this, function(){
					this.domNode.style.display = "none";
					DialogLevelManager.hide(this);
					this._fadeOutDeferred.callback(true);
					delete this._fadeOutDeferred;
				})
			 }).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return this._fadeOutDeferred;
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	});

	var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {});
	Dialog._DialogBase = _DialogBase;	// for monkey patching

	var DialogLevelManager = Dialog._DialogLevelManager = {
		// summary:
		//		Controls the various active "levels" on the page, starting with the
		//		stuff initially visible on the page (at z-index 0), and then having an entry for
		//		each Dialog shown.

		_beginZIndex: 950,

		show: function(/*dijit._Widget*/ dialog, /*Object*/ underlayAttrs){
			// summary:
			//		Call right before fade-in animation for new dialog.
			//		Saves current focus, displays/adjusts underlay for new dialog,
			//		and sets the z-index of the dialog itself.
			//
			//		New dialog will be displayed on top of all currently displayed dialogs.
			//
			//		Caller is responsible for setting focus in new dialog after the fade-in
			//		animation completes.

			// Save current focus
			ds[ds.length-1].focus = focus.curNode;

			// Display the underlay, or if already displayed then adjust for this new dialog
			var underlay = dijit._underlay;
			if(!underlay || underlay._destroyed){
				underlay = dijit._underlay = new DialogUnderlay(underlayAttrs);
			}else{
				underlay.set(dialog.underlayAttrs);
			}

			// Set z-index a bit above previous dialog
			var zIndex = ds[ds.length-1].dialog ? ds[ds.length-1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
			if(ds.length == 1){	// first dialog
				underlay.show();
			}
			domStyle.set(dijit._underlay.domNode, 'zIndex', zIndex - 1);

			// Dialog
			domStyle.set(dialog.domNode, 'zIndex', zIndex);

			ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
		},

		hide: function(/*dijit._Widget*/ dialog){
			// summary:
			//		Called when the specified dialog is hidden/destroyed, after the fade-out
			//		animation ends, in order to reset page focus, fix the underlay, etc.
			//		If the specified dialog isn't open then does nothing.
			//
			//		Caller is responsible for either setting display:none on the dialog domNode,
			//		or calling dijit.popup.hide(), or removing it from the page DOM.

			if(ds[ds.length-1].dialog == dialog){
				// Removing the top (or only) dialog in the stack, return focus
				// to previous dialog

				ds.pop();

				var pd = ds[ds.length-1];	// the new active dialog (or the base page itself)

				// Adjust underlay
				if(ds.length == 1){
					// Returning to original page.
					// Hide the underlay, unless the underlay widget has already been destroyed
					// because we are being called during page unload (when all widgets are destroyed)
					if(!dijit._underlay._destroyed){
						dijit._underlay.hide();
					}
				}else{
					// Popping back to previous dialog, adjust underlay
					domStyle.set(dijit._underlay.domNode, 'zIndex', pd.zIndex - 1);
					dijit._underlay.set(pd.underlayAttrs);
				}

				// Adjust focus
				if(dialog.refocus){
					// If we are returning control to a previous dialog but for some reason
					// that dialog didn't have a focused field, set focus to first focusable item.
					// This situation could happen if two dialogs appeared at nearly the same time,
					// since a dialog doesn't set it's focus until the fade-in is finished.
					var focus = pd.focus;
					if(pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))){
						pd.dialog._getFocusItems(pd.dialog.domNode);
						focus = pd.dialog._firstFocusItem;
					}

					if(focus){
						// Refocus the button that spawned the Dialog.   This will fail in corner cases including
						// page unload on IE, because the dijit/form/Button that launched the Dialog may get destroyed
						// before this code runs.  (#15058)
						try{
							focus.focus();
						}catch(e){}
					}
				}
			}else{
				// Removing a dialog out of order (#9944, #10705).
				// Don't need to mess with underlay or z-index or anything.
				var idx = array.indexOf(array.map(ds, function(elem){return elem.dialog}), dialog);
				if(idx != -1){
					ds.splice(idx, 1);
				}
			}
		},

		isTop: function(/*dijit._Widget*/ dialog){
			// summary:
			//		Returns true if specified Dialog is the top in the task
			return ds[ds.length-1].dialog == dialog;
		}
	};

	// Stack representing the various active "levels" on the page, starting with the
	// stuff initially visible on the page (at z-index 0), and then having an entry for
	// each Dialog shown.
	// Each element in stack has form {
	//		dialog: dialogWidget,
	//		focus: returnFromGetFocus(),
	//		underlayAttrs: attributes to set on underlay (when this widget is active)
	// }
	var ds = Dialog._dialogStack = [
		{dialog: null, focus: null, underlayAttrs: null}	// entry for stuff at z-index: 0
	];

	// Back compat w/1.6, remove for 2.0
	if(!kernel.isAsync){
		ready(0, function(){
			var requires = ["dijit/TooltipDialog"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return Dialog;
});

},
'dojo/date/locale':function(){
define("dojo/date/locale", [
	"../_base/kernel",
	"../_base/lang",
	"../_base/array",
	"../date",
	"../cldr/supplemental",
	"../regexp",
	"../string",
	"../i18n!../cldr/nls/gregorian"
], function(dojo, lang, array, date, cldr, regexp, string, gregorian) {
	// module:
	//		dojo/date/locale
	// summary:
	//		This modules defines dojo.date.locale, localization methods for Date.

lang.getObject("date.locale", true, dojo);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.

// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						string.pad(Math.floor(Math.abs(offset)/60), 2),
						string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
						result[0] = (v < cutoff) ? century + v : century - 100 + v;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
					s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}

var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = lang.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = cldr.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

return dojo.date.locale;
});

},
'idx/oneui/MenuBar':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/MenuBar", ["dojo/_base/declare",
		"dijit/MenuBar",
    "idx/oneui/_MenuOpenOnHoverMixin"],
		function(declare,
				 MenuBar,
         _MenuOpenOnHoverMixin){
	/**
	 * Creates an idx.oneui.MenuBar
	 * @name idx.oneui.MenuBar
	 * @class The MenuBar widget provides a menu bar with open-on-hover behaviour.
	 * @augments dijit.MenuBar
	 * @augments idx.oneui._MenuOpenOnHoverMixin
	 * @borrows idx.oneui._MenuOpenOnHoverMixin#openOnHover as this.openOnHover
	 * @example &lt;div data-dojo-type="idx.oneui.MenuBar"&gt;
  &lt;div data-dojo-type="dijit.PopupMenuBarItem"&gt;
    &lt;span&gt;Edit&lt;/span&gt;
    &lt;div data-dojo-type="idx.oneui.Menu"&gt;
      &lt;div data-dojo-type="dijit.MenuItem" onclick="..."&gt;Cut&lt;/div&gt;
      &lt;div data-dojo-type="dijit.MenuItem" onclick="..."&gt;Copy&lt;/div&gt;
      &lt;div data-dojo-type="dijit.MenuItem" onclick="..."&gt;Paste&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
	 */
	return declare("idx.oneui.MenuBar", [MenuBar, _MenuOpenOnHoverMixin], 
	/** @lends idx.oneui.MenuBar.prototype */
	{
	});
	
});

},
'dojo/require':function(){
define("dojo/require", ["./_base/loader"], function(loader){
	return {
		dynamic:0,
		normalize:function(id){return id;},
		load:loader.require
	};
});

},
'dijit/form/RadioButton':function(){
define("dijit/form/RadioButton", [
	"dojo/_base/declare", // declare
	"./CheckBox",
	"./_RadioButtonMixin"
], function(declare, CheckBox, _RadioButtonMixin){

/*=====
	var CheckBox = dijit.form.CheckBox;
	var _RadioButtonMixin = dijit.form._RadioButtonMixin;
=====*/

	// module:
	//		dijit/form/RadioButton
	// summary:
	//		Radio button widget

	return declare("dijit.form.RadioButton", [CheckBox, _RadioButtonMixin], {
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		baseClass: "dijitRadio"
	});
});

},
'dijit/MenuSeparator':function(){
require({cache:{
'url:dijit/templates/MenuSeparator.html':"<tr class=\"dijitMenuSeparator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>"}});
define("dijit/MenuSeparator", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_Contained",
	"dojo/text!./templates/MenuSeparator.html"
], function(declare, dom, _WidgetBase, _TemplatedMixin, _Contained, template){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _Contained = dijit._Contained;
=====*/

	// module:
	//		dijit/MenuSeparator
	// summary:
	//		A line between two menu items

	return declare("dijit.MenuSeparator", [_WidgetBase, _TemplatedMixin, _Contained], {
		// summary:
		//		A line between two menu items

		templateString: template,

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});
});

},
'dijit/form/ToggleButton':function(){
define("dijit/form/ToggleButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

/*=====
	var Button = dijit.form.Button;
	var _ToggleButtonMixin = dijit.form._ToggleButtonMixin;
=====*/

	// module:
	//		dijit/form/ToggleButton
	// summary:
	//		A templated button widget that can be in two states (checked or not).


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'curam/util/Dialog':function(){
/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.util.Dialog
 * @namespace Provides the ability to open arbitrary (non-UIM) content
 * in a Curam dialog.
 * 
 * It is required that the non-UIM page you are opening in a dialog resides
 * on the same Internet domain as the Curam application you are integrating
 * with.
 * <p/>
 * To open a custom page in a dialog you have to <ul>
 * <li> in the Curam application make the API call to load the custom page
 *      in a dialog </li>
 * <li> hook the custom page into the dialog API </li> </ul>
 * 
 * To hook the custom page into the dialog API, you first need to load the code,
 * preferably using <code>dojo.require("curam.util.Dialog");</code>
 * This assumes that you are using Dojo and you have access to the Curam
 * infrastructure JavaScript libraries.
 * <p/>
 * If this is not true for your pages, you will need to load the code
 * in the page header with standard <code>script</code> HTML elements.
 * The necesary script files are
 * <code>/CDEJ/jscript/curam/util/Dialog.js</code>,
 * <code>/CDEJ/jscript/curam/dialog.js</code>
 * and <code>/CDEJ/jscript/cdej.js</code>.
 * <p/>
 * The important API functions that must be called from your page are:<ul>
 * <li><code>{@link curam.util.Dialog.init}</code> in the page header.</li>
 * <li><code>{@link curam.util.Dialog.pageLoadFinished} when the page has been
 * fully loaded.</code></li></ul>
 * <p/>
 * To control the dialog size and title text you must register custom
 * functions by calling the following API in the page header:<ul>
 * <li><code>{@link curam.util.Dialog.registerGetSizeFunc}</code></li>
 * <li><code>{@link curam.util.Dialog.registerGetTitleFunc}</code></li></ul>
 * <p/>
 * Optionally you can also register custom handlers for the following events:<ul>
 * <li>AfterDisplay</li>
 * <li>BeforeClose</li></ul>
 * 
 * If linking from a dialog back into the Curam application is required,
 * this is done using the {@link curam.util.Dialog.close} function.
 */
define("curam/util/Dialog", ["curam/util",
        "curam/define",
        "curam/dialog",
        "curam/util/onLoad",
        "curam/debug",
        "curam/util/ResourceBundle"
        ], function() {

/*
 * Modification History
 * --------------------
 * 03-Jul-2013  MV  [CR00390548] Remove IEG2 specific processing.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 03-Feb-2011  MV  [CR00253193] Add special processing in case IEG2
 *    is the client of the API - will be removed later on.
 * 03-Feb-2011  MV  [CR00250687] Notify the parent of the page unload.
 * 18-Jan-2011  MV  [CR00243263] Ensure handlers are released properly. Remove
 *    the use of alias for the window object.
 * 12-Jan-2011  PK  [CR00231655] Fixed issue with registerGetSizeFunc() not
 *                    correctly registering the specified sizing function.
 * 18-Nov-2010  MV  [CR00231655] Take dialog size into account properly.
 * 29-Sep-2010  MV  [CR00221605] Refactor to enable easy change of the context
 *      the API works on.
 */
  
/**
 * Creating Resource Bundle Object to access localized resources.
 */ 
dojo.requireLocalization("curam.application", "Debug");
var bundle = new curam.util.ResourceBundle("Debug");
  
curam.define.singleton("curam.util.Dialog",
/**
 * @lends curam.util.Dialog.prototype
 */
{  
  /**
   * Holds ID of the dialog in the current context.
   * @private
   */
  _id: null,
  
  /**
   * Holds the tokens for unsubscribing handlers on dialog close.
   * @private
   */
  _unsubscribes: [],
    
  /**
   * Opens the specified non-UIM page in a Curam dialog.
   * 
   * @param {String} path URL path to the page to display in the dialog, without
   *              the query string.
   * @param {Object} pageParameters An object containing the required page
   *      parameters, or null if no page parameters are required.
   *      The following format is expected:
   *                        <code>{ param1Name:"value", param2Name:248 }</code>
   *      The infrastructure handles URL-encoding the values so do NOT encode
   *      them yourself.
   * @param {Object} [dialogSize] An object representing the required size
   *    of the dialog in pixels. The following form is required:
   *        <code>{ width:500, height:300 }</code> If size is not specified
   *      the default size will be used instead.
   */
  open: function(path, pageParameters, dialogSize) {
    var url = path + curam.util.makeQueryString(pageParameters);
    var anchor = { href: url };
    var windowOptions = null;
    if (dialogSize) {
      windowOptions = "width=" + dialogSize.width
          + ",height=" + dialogSize.height;
    }
    window.jsModals = true;
    curam.util.openModalDialog(anchor, windowOptions);
  },
    
  /**
   * Initializes the dialog infrastructure.
   *
   * Must be called in the header of the page loaded in the dialog.
   */
  init: function() {
    // receive the dialogId for the current context
    var topWin = curam.util.getTopmostWindow();
    var unsToken = topWin.dojo.subscribe("/curam/dialog/SetId", null,
        function(dialogId) {
          curam.util.Dialog._id = dialogId;
          
          curam.debug.log(bundle.getProperty("curam.util.Dialog.id.success"), 
            curam.util.Dialog._id);

          topWin.dojo.unsubscribe(unsToken);
        });
    curam.util.Dialog._unsubscribes.push(unsToken);
    
    // publish the init event
    // this also triggers the /curam/dialog/SetId event
    // to get the ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!curam.util.Dialog._id) {
      curam.debug.log(bundle.getProperty("curam.util.Dialog.id.fail"));
    }
    
    dojo.addOnUnload(function() {
      // ensure any event handlers are released on page unload
      curam.util.Dialog._releaseHandlers();

      // notify interested parties of the iframe unload
      window.parent.dojo.publish(
          "/curam/dialog/iframeUnloaded", [ curam.util.Dialog._id, window ]);
    });
  },
  
  /**
   * Registers a custom function to get the dialog title text.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getTitle A function that returns the text to be displayed
   *                  in the dialog title bar.
   */
  registerGetTitleFunc: function(getTitle) {
    curam.util.onLoad.addPublisher(function(context) {
      context.title = getTitle();
    });
  },
  
  /**
   * Registers a custom function to get the dialog size.
   *
   * Can be optioanally called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getSize A function that returns an object
   *      in the following form: <code>{ width:500, height:300 }</code>
   */
  registerGetSizeFunc: function(getSize) {
    curam.util.onLoad.addPublisher(function(context) {
      context.windowOptions = getSize();
    });
  },
  
  /**
   * Registers a custom function that will be called after the dialog appears
   * on the screen.
   * 
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the AfterDisplay event.
   */
  registerAfterDisplayHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/AfterDisplay", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Registers a custom function that will be called before the dialog
   * is closed.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the BeforeClose event.
   */
  registerBeforeCloseHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId === curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Notifies the dialog infrastructure that the page has been fully loaded.
   *
   * Must be called by the page after it finishes loading in the dialog.
   * (E.g. dojo.addOnLoad(curam.Dialog.pageLoadFinished))
   */
  pageLoadFinished: function() {
    // ensure the handlers are unregistered on dialog close
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsTokenReleaseHandlers = topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            curam.util.Dialog._releaseHandlers();
          }
        });
     
    // invoke the onLoad API 
    curam.util.onLoad.execute();
  },
  
  /**
   * Releases any registered handlers.
   *
   * @private
   */
  _releaseHandlers: function() {
    var topWin = curam.util.getTopmostWindow();
    dojo.forEach(curam.util.Dialog._unsubscribes, topWin.dojo.unsubscribe);
    curam.util.Dialog._unsubscribes = [];
    
    topWin.dojo.unsubscribe(curam.util.Dialog._unsTokenReleaseHandlers);
    curam.util.Dialog._unsTokenReleaseHandlers = null;
  },
  
  /**
   * Closes the dialog, optionally refreshing or redirecting the parent window.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Boolean} [refreshParent=false] Should the parent be refreshed
   *              when this dialog closes?
   * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
   *      should be redirected to when this dialog closes. Alternatively
   *      a full URL including the page parameters can be passed.
   * @param {Object} [pageParameters] Page parameters to be used when
   *        redirecting the parent to the new page. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        The infrastructure handles URL-encoding the values so do NOT encode
   *        them yourself.
   *        If full URL is specified then the pageParameters are ignored.
   */
  close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
      /*optional*/ pageParameters) {
    
    var parentWindow = curam.dialog.getParentWindow(window);
    if (refreshParent && !newPageIdOrFullUrl) {
      curam.dialog.forceParentRefresh();
      parentWindow.curam.util.redirectWindow(null);
      
    } else if (newPageIdOrFullUrl) {
      var newParentUrl = newPageIdOrFullUrl;
      // distinguish between pageId and full URL
      if (newPageIdOrFullUrl.indexOf("Page.do") == -1 && newPageIdOrFullUrl.indexOf("Action.do") == -1) {
        newParentUrl = newPageIdOrFullUrl + "Page.do"
            + curam.util.makeQueryString(pageParameters);
      }

      parentWindow.curam.util.redirectWindow(newParentUrl);
    }

    var topWin = curam.util.getTopmostWindow();
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  },
  
  /**
   * Closes the dialog and submit the parent page, where the form parameters
   * will be optionally passed to. This method is design for the senario where
   * the parent page has an <code>ACTION</code> phase.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Object} [formParameters] Form parameters to be used in the form of
   *        the parent page when it is being submitted. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        Those parameters should not be encoded. The parameter name should be
   *        the order of the input fields in the form, e.g. '1' means the first
   *        input field in the form.
   */
  closeAndSubmitParent: function(/*optional*/ formParameters) {
    var parentWindow = curam.dialog.getParentWindow(window);
    // Get the form of the parent page.
    var parentWindowForm = parentWindow.document.forms["mainForm"];
    var topWin = curam.util.getTopmostWindow();
    
    // Check if the from in the parent window exists or not. If not, simply 
    // close the modal and return. The parent page will not be submitted.
    if (parentWindowForm == null || parentWindowForm == undefined) {
      //Close the modal
      topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
      return;
    }
        
    // Define the function used to check if the "formParameters" object is
    // empty or not.
    var isEmpty = function (object) {
      for (var property in object) {
        if (object.hasOwnProperty(property)) {
          return false;
        }
      }
      return true;
    };

    
    // Set the from parameters to the corresponding input fields 
    // in the form of the parent page that will be submitted.
    if (formParameters && !isEmpty(formParameters)) {
      // Reset and assign new form parameters to the input fields
      var inputFieldListUnfiltered = dojo.query(
          "input[type=text])", parentWindowForm);
	 
      var inputFieldList = dojo.filter(inputFieldListUnfiltered, function(node){
        return node.readOnly == false;
      });
	  
      dojo.forEach(inputFieldList, function(node) {
          node.value = "";
      });
    
      for (var fieldName in formParameters) {
        var inputField = inputFieldList[parseInt(fieldName)];
        
        if (inputField) {
          var hiddenInputForDropDown = dojo.query(
                   "input[name=" + inputField.id + "]", parentWindowForm)[0];
            if (hiddenInputForDropDown) {
              hiddenInputForDropDown.value = formParameters[fieldName];
            } else {
              inputField.value = formParameters[fieldName];
            }
        
        }
      }
    } else {
      // Do nothing. No form paramters are passed down. Keep the existing string
      // in the from input fields.
    }
	
    //Submit the parent page.
    parentWindow.dojo.publish("/curam/page/refresh");
    parentWindowForm.submit();
    
    //Close the modal
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  }

  });
  
});


},
'dijit/CheckedMenuItem':function(){
require({cache:{
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n"}});
define("dijit/CheckedMenuItem", [
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"./MenuItem",
	"dojo/text!./templates/CheckedMenuItem.html",
	"./hccss"
], function(declare, domClass, MenuItem, template){

/*=====
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/CheckedMenuItem
	// summary:
	//		A checkbox-like menu item for toggling on and off

	return declare("dijit.CheckedMenuItem", MenuItem, {
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: template,

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			domClass.toggle(this.domNode, "dijitCheckedMenuItemChecked", checked);
			this.domNode.setAttribute("aria-checked", checked);
			this._set("checked", checked);
		},

		iconClass: "",	// override dijitNoIcon

		onChange: function(/*Boolean*/ /*===== checked =====*/){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});
});

},
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\ttabIndex=\"-1\" role=\"presentation\" data-dojo-attach-point=\"valueNode\"\n/></span>\n",
'dojox/html/_base':function(){
define("dojox/html/_base", [
	"dojo/_base/kernel",
	"dojo/_base/lang",
	"dojo/_base/xhr",
	"dojo/_base/window",
	"dojo/_base/sniff",
	"dojo/_base/url",
	"dojo/dom-construct",
	"dojo/html",
	"dojo/_base/declare"
], function (dojo, lang, xhrUtil, windowUtil, has, _Url, domConstruct, htmlUtil) {
/*
	Status: dont know where this will all live exactly
	Need to pull in the implementation of the various helper methods
	Some can be static method, others maybe methods of the ContentSetter (?)

	Gut the ContentPane, replace its _setContent with our own call to dojox.html.set()


*/
	var html = dojo.getObject("dojox.html", true);

	if(has("ie")){
		var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
	}

	// css at-rules must be set before any css declarations according to CSS spec
	// match:
	// @import 'http://dojotoolkit.org/dojo.css';
	// @import 'you/never/thought/' print;
	// @import url("it/would/work") tv, screen;
	// @import url(/did/you/now.css);
	// but not:
	// @namespace dojo "http://dojotoolkit.org/dojo.css"; /* namespace URL should always be a absolute URI */
	// @charset 'utf-8';
	// @media print{ #menuRoot {display:none;} }

	// we adjust all paths that dont start on '/' or contains ':'
	//(?![a-z]+:|\/)

	var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;

	var adjustCssPaths = html._adjustCssPaths = function(cssUrl, cssText){
		//	summary:
		//		adjusts relative paths in cssText to be relative to cssUrl
		//		a path is considered relative if it doesn't start with '/' and not contains ':'
		//	description:
		//		Say we fetch a HTML page from level1/page.html
		//		It has some inline CSS:
		//			@import "css/page.css" tv, screen;
		//			...
		//			background-image: url(images/aplhaimage.png);
		//
		//		as we fetched this HTML and therefore this CSS
		//		from level1/page.html, these paths needs to be adjusted to:
		//			@import 'level1/css/page.css' tv, screen;
		//			...
		//			background-image: url(level1/images/alphaimage.png);
		//
		//		In IE it will also adjust relative paths in AlphaImageLoader()
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
		//		will be adjusted to:
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
		//
		//		Please note that any relative paths in AlphaImageLoader in external css files wont work, as
		//		the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
		//		not relative to the CSS file that declares it

		if(!cssText || !cssUrl){ return; }

		// support the ImageAlphaFilter if it exists, most people use it in IE 6 for transparent PNGs
		// We are NOT going to kill it in IE 7 just because the PNGs work there. Somebody might have
		// other uses for it.
		// If user want to disable css filter in IE6  he/she should
		// unset filter in a declaration that just IE 6 doesn't understands
		// like * > .myselector { filter:none; }
		if(alphaImageLoader){
			cssText = cssText.replace(alphaImageLoader, function(ignore, pre, delim, url, post){
				return pre + (new _Url(cssUrl, './'+url).toString()) + post;
			});
		}

		return cssText.replace(cssPaths, function(ignore, delimStr, strUrl, delimUrl, urlUrl, media){
			if(strUrl){
				return '@import "' + (new _Url(cssUrl, './'+strUrl).toString()) + '"' + media;
			}else{
				return 'url(' + (new _Url(cssUrl, './'+urlUrl).toString()) + ')' + media;
			}
		});
	};

	// attributepaths one tag can have multiple paths, example:
	// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
	// <img style='filter:progid...AlphaImageLoader(src="noticeTheSrcHereRunsThroughHtmlSrc")' src="img">
	var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;

	var adjustHtmlPaths = html._adjustHtmlPaths = function(htmlUrl, cont){
		var url = htmlUrl || "./";

		return cont.replace(htmlAttrPaths,
			function(tag, start, name, delim, relUrl, delim2, cssText, end){
				return start + (name ?
							(name + '=' + delim + (new _Url(url, relUrl).toString()) + delim)
						: ('style=' + delim2 + adjustCssPaths(url, cssText) + delim2)
				) + end;
			}
		);
	};

	var snarfStyles = html._snarfStyles = function	(/*String*/cssUrl, /*String*/cont, /*Array*/styles){
		/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
		// also return any attributes from this tag (might be a media attribute)
		// if cssUrl is set it will adjust paths accordingly
		styles.attributes = [];

		return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi,
			function(ignore, styleAttr, cssText, linkAttr, delim, href){
				// trim attribute
				var i, attr = (styleAttr||linkAttr||"").replace(/^\s*([\s\S]*?)\s*$/i, "$1");
				if(cssText){
					i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
				}else{
					i = styles.push('@import "' + href + '";');
					attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, ""); // remove rel=... and href=...
				}
				if(attr){
					attr = attr.split(/\s+/);// split on both "\n", "\t", " " etc
					var atObj = {}, tmp;
					for(var j = 0, e = attr.length; j < e; j++){
						tmp = attr[j].split('='); // split name='value'
						atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1"); // trim and remove ''
					}
					styles.attributes[i - 1] = atObj;
				}
				return "";
			}
		);
	};

	var snarfScripts = html._snarfScripts = function(cont, byRef){
		// summary
		//		strips out script tags from cont
		// invoke with
		//	byRef = {errBack:function(){/*add your download error code here*/, downloadRemote: true(default false)}}
		//	byRef will have {code: 'jscode'} when this scope leaves
		byRef.code = "";

		//Update script tags nested in comments so that the script tag collector doesn't pick
		//them up.
		cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)script\b/ig,"&lt;$1Script");
			}
		);

		function download(src){
			if(byRef.downloadRemote){
				// console.debug('downloading',src);
				//Fix up src, in case there were entity character encodings in it.
				//Probably only need to worry about a subset.
				src = src.replace(/&([a-z0-9#]+);/g, function(m, name) {
					switch(name) {
						case "amp"	: return "&";
						case "gt"	: return ">";
						case "lt"	: return "<";
						default:
							return name.charAt(0)=="#" ? String.fromCharCode(name.substring(1)) : "&"+name+";";
					}
				});
				xhrUtil.get({
					url: src,
					sync: true,
					load: function(code){
						byRef.code += code+";";
					},
					error: byRef.errBack
				});
			}
		}

		// match <script>, <script type="text/..., but not <script type="dojo(/method)...
		return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))(?:[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?)*>([\s\S]*?)<\/script>/gi,
			function(ignore, delim, src, code){
				if(src){
					download(src);
				}else{
					byRef.code += code;
				}
				return "";
			}
		);
	};

	var evalInGlobal = html.evalInGlobal = function(code, appendNode){
		// we do our own eval here as dojo.eval doesn't eval in global crossbrowser
		// This work X browser but but it relies on a DOM
		// plus it doesn't return anything, thats unrelevant here but not for dojo core
		appendNode = appendNode || windowUtil.doc.body;
		var n = appendNode.ownerDocument.createElement('script');
		n.type = "text/javascript";
		appendNode.appendChild(n);
		n.text = code; // DOM 1 says this should work
	};

	html._ContentSetter = dojo.declare(/*===== "dojox.html._ContentSetter", =====*/ htmlUtil._ContentSetter, {
		// adjustPaths: Boolean
		//		Adjust relative paths in html string content to point to this page
		//		Only useful if you grab content from a another folder than the current one
		adjustPaths: false,
		referencePath: ".",
		renderStyles: false,

		executeScripts: false,
		scriptHasHooks: false,
		scriptHookReplacement: null,

		_renderStyles: function(styles){
			// insert css from content into document head
			this._styleNodes = [];
			var st, att, cssText, doc = this.node.ownerDocument;
			var head = doc.getElementsByTagName('head')[0];

			for(var i = 0, e = styles.length; i < e; i++){
				cssText = styles[i]; att = styles.attributes[i];
				st = doc.createElement('style');
				st.setAttribute("type", "text/css"); // this is required in CSS spec!

				for(var x in att){
					st.setAttribute(x, att[x]);
				}

				this._styleNodes.push(st);
				head.appendChild(st); // must insert into DOM before setting cssText

				if(st.styleSheet){ // IE
					st.styleSheet.cssText = cssText;
				}else{ // w3c
					st.appendChild(doc.createTextNode(cssText));
				}
			}
		},

		empty: function() {
			this.inherited("empty", arguments);

			// empty out the styles array from any previous use
			this._styles = [];
		},

		onBegin: function() {
			// summary
			//		Called after instantiation, but before set();
			//		It allows modification of any of the object properties - including the node and content
			//		provided - before the set operation actually takes place
			//		This implementation extends that of dojo.html._ContentSetter
			//		to add handling for adjustPaths, renderStyles on the html string content before it is set
			this.inherited("onBegin", arguments);

			var cont = this.content,
				node = this.node;

			var styles = this._styles;// init vars

			if(lang.isString(cont)){
				if(this.adjustPaths && this.referencePath){
					cont = adjustHtmlPaths(this.referencePath, cont);
				}

				if(this.renderStyles || this.cleanContent){
					cont = snarfStyles(this.referencePath, cont, styles);
				}

				// because of a bug in IE, script tags that is first in html hierarchy doesnt make it into the DOM
				//	when content is innerHTML'ed, so we can't use dojo.query to retrieve scripts from DOM
				if(this.executeScripts){
					var _t = this;
					var byRef = {
						downloadRemote: true,
						errBack:function(e){
							_t._onError.call(_t, 'Exec', 'Error downloading remote script in "'+_t.id+'"', e);
						}
					};
					cont = snarfScripts(cont, byRef);
					this._code = byRef.code;
				}
			}
			this.content = cont;
		},

		onEnd: function() {
			// summary
			//		Called after set(), when the new content has been pushed into the node
			//		It provides an opportunity for post-processing before handing back the node to the caller
			//		This implementation extends that of dojo.html._ContentSetter

			var code = this._code,
				styles = this._styles;

			// clear old stylenodes from the DOM
			// these were added by the last set call
			// (in other words, if you dont keep and reuse the ContentSetter for a particular node
			// .. you'll have no practical way to do this)
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					domConstruct.destroy(this._styleNodes.pop());
				}
			}
			// render new style nodes
			if(this.renderStyles && styles && styles.length){
				this._renderStyles(styles);
			}

			if(this.executeScripts && code){
				if(this.cleanContent){
					// clean JS from html comments and other crap that browser
					// parser takes care of in a normal page load
					code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, '');
				}
				if(this.scriptHasHooks){
					// replace _container_ with this.scriptHookReplace()
					// the scriptHookReplacement can be a string
					// or a function, which when invoked returns the string you want to substitute in
					code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
				}
				try{
					evalInGlobal(code, this.node);
				}catch(e){
					this._onError('Exec', 'Error eval script in '+this.id+', '+e.message, e);
				}
			}
			this.inherited("onEnd", arguments);
		},
		tearDown: function() {
			this.inherited(arguments);
			delete this._styles;
			// only tear down -or another set() - will explicitly throw away the
			// references to the style nodes we added
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					domConstruct.destroy(this._styleNodes.pop());
				}
			}
			delete this._styleNodes;
			// reset the defaults from the prototype
			// XXX: not sure if this is the correct intended behaviour, it was originally
			// dojo.getObject(this.declaredClass).prototype which will not work with anonymous
			// modules
			dojo.mixin(this, html._ContentSetter.prototype);
		}

	});

	html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
		// TODO: add all the other options
			// summary:
			//		inserts (replaces) the given content into the given node
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});

		if(!params){
			// simple and fast
			return htmlUtil._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			var op = new html._ContentSetter(dojo.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};

	return html;
});
},
'dijit/_DialogMixin':function(){
define("dijit/_DialogMixin", [
	"dojo/_base/declare", // declare
	"./a11y"	// _getTabNavigable
], function(declare, a11y){

	// module:
	//		dijit/_DialogMixin
	// summary:
	//		_DialogMixin provides functions useful to Dialog and TooltipDialog

	return declare("dijit._DialogMixin", null, {
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = a11y._getTabNavigable(this.containerNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	});
});

},
'dijit/_Widget':function(){
define("dijit/_Widget", [
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _OnDijitClickMixin = dijit._OnDijitClickMixin;
	var _FocusMixin = dijit._FocusMixin;
=====*/


// module:
//		dijit/_Widget
// summary:
//		Old base for widgets.   New widgets should extend _WidgetBase instead


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Base class for all Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//			- declaratively/programatically specifying widget initialization parameters like
	//				onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//			- ondijitclick
	//				Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//			- focus related functions
	//				In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//				dijit/_base/focus.js.
	//			- deprecated methods
	//			- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//			- browser sniffing (putting browser id like .dj_ie on <html> node)
	//			- high contrast mode sniffing (add .dijit_a11y class to <body> if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params){
		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		This method is deprecated, use get() or set() directly.

		// Print deprecation warning but only once per calling function
		if(config.isDebug){
			var alreadyCalledHash = arguments.callee._ach || (arguments.callee._ach = {}),
				caller = (arguments.callee.caller || "unknown caller").toString();
			if(!alreadyCalledHash[caller]){
				kernel.deprecated(this.declaredClass + "::attr() is deprecated. Use get() or set() instead, called from " +
				caller, "", "2.0");
				alreadyCalledHash[caller] = true;
			}
		}

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit._Widget[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"onclick:_onClick\"\n/></div>\n",
'idx/oneui/_CssStateMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/_CssStateMixin", ["dojo", "dijit/dijit", "dijit/_WidgetBase"], function(dojo, dijit, widgetBase){

return dojo.declare("idx.oneui._CssStateMixin", [], {
	
	cssStateNodes: {},
	hovering: false,
	active: false,

	// stateNode
	//		The original dijit domNode (inner field widget)
	
	// oneuiBaseClass
	//		The original dijit baseClass (inner field widget)

	_applyAttributes: function(){
		widgetBase.prototype._applyAttributes.apply(this, arguments);
		dojo.forEach(["onmouseenter", "onmouseleave", "onmousedown"], function(e){
			this.connect(this.stateNode, e, "_cssMouseEvent");
		}, this);

		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		dojo.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "required"], function(attr){
			this.watch(attr, dojo.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown" :
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},
	
	_setStateClass: function(){
		// Compute new set of classes
		var newStateClasses = this._getModifiedClasses(this.oneuiBaseClass);
		this._applyStateClass(this.stateNode, newStateClasses);
		newStateClasses = this._getModifiedClasses(this.baseClass);
		this._applyStateClass(this.domNode, newStateClasses);
	},
	
	_getModifiedClasses: function(/*String*/className){
		var clazz = className.split(" ");
		function multiply(modifier){
			clazz = clazz.concat(dojo.map(clazz, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
		if(this.checked){
			multiply(checkedState);
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}
		if(this.required){
			multiply("Required");
		}
		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this.focused){
			multiply("Focused");
		}
		return clazz;
	},
	
	_applyStateClass: function(/*DomNode*/ node, /*Array*/classes){
		// Compute new set of classes
		// Remove old state classes and add new ones.
		// For performance concerns we only write into stateNode.className and domNode.className once.
		var classHash = {};	// set of all classes (state and otherwise) for node
		
		dojo.forEach(node.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in node){
			dojo.forEach(node._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(classes, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		node.className = newClasses.join(" ");
		node._stateClasses = classes;
	},
	
	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because dojo.toggleClass() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = dojo.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			dojo.toggleClass(node, clazz+"Hover", hovering && !active && !disabled);
			dojo.toggleClass(node, clazz+"Active", active && !disabled);
			dojo.toggleClass(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn("onmousedown", function(){
			active = true;
			setClass();
		});
		cn("onmouseup", function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});
});
},
'idx/oneui/form/DateTextBox':function(){
require({cache:{
'url:idx/oneui/form/templates/DropDownBox.html':"<div id=\"widget_${id}\" class=\"dijitInline dijitReset dijitLeft idxComposite\"\r\n\t><div class=\"idxLabel dijitInline dijitHidden\"><span class=\"idxRequiredIcon\">*&nbsp</span><label for=\"${id}\" dojoAttachPoint=\"compLabelNode\"></label></div\r\n\t><div class=\"dijitInline\"\r\n\t><div class=\"dijit dijitInline dijitReset dijitInlineTable dijitLeft\" role=\"combobox\" dojoAttachPoint='_aroundNode,stateNode,oneuiBaseNode'\r\n\t\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\" dojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"/\r\n\t></div\r\n\t></div\r\n\t><div class='dijitReset dijitInline oneuiIcon'\r\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\r\n\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\" ${_buttonInputDisabled}/\r\n\t></div\r\n\t><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"></div\r\n\t><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\r\n\t\t><div class=\"dijitValidationIcon\"><input class=\"dijitReset dijitInputField dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\r\n\t></div></div\r\n\t><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\r\n\t></div\r\n></div>"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/form/DateTextBox", [
	"dojo/_base/declare",
	"dojo/dom-style",
	"dijit/Calendar",
	"../HoverHelpTooltip",
	"../_CssStateMixin",
	"./_DateTimeTextBox",
	"./_CompositeMixin",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, domStyle, Calendar, HoverHelpTooltip, _CssStateMixin, _DateTimeTextBox, _CompositeMixin, template){

	// module:
	//		dijit/form/DateTextBox
	// summary:
	//		A validating, serializable, range-bound date text box with a drop down calendar

	/**
	* @name idx.oneui.form.DateTextBox
	* @class A validating, serializable, range-bound date text box with a drop down calendar
	* @augments idx.oneui.form._DateTimeTextBox
	* @augments idx.oneui.form._CompositeMixin
	* @augments idx.oneui._CssStateMixin
	*/ 
	return declare("idx.oneui.form.DateTextBox", [_DateTimeTextBox, _CompositeMixin, _CssStateMixin], {
	/**@lends idx.oneui.form.DateTextBox*/ 
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		//
		//		Example:
		// |	new dijit.form.DateTextBox({value: new Date(2009, 0, 20)})
		//
		//		Example:
		// |	<input dojotype='dijit.form.DateTextBox' value='2009-01-20'>

		// instantValidate: Boolean
		//		Fire validation when widget get input by set true, 
		//		fire validation when widget get blur by set false
		instantValidate: false,
		/**
		* base class of this oneui widget
		*/
		baseClass: "idxDateTextBoxWrap",
		/**
		* base class of dijit widget
		*/
		oneuiBaseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
		popupClass: "dijit.Calendar",
		_selector: "date",
		templateString: template,
		
		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `dojo.date.stamp.fromISOString`.
		//		set("value", ...) accepts either a Date object or a string.
		value: new Date(""),// value.toString()="NaN"
		/** @ignore */
		postCreate: function(){
			this.inherited(arguments);
			if(this.instantValidate){
				this.connect(this, "_onInput", function(){
					this.validate(this.focused);
				});
			}else{
				this.connect(this, "_onBlur", function(){
					this.validate(this.focused);
				});
				this.connect(this, "_onFocus", function(){
					this._set("state", "");
					if(this.message == ""){return;}
					this.displayMessage(this.message);
					this.message = "";
				});
				this.connect(this, "_onInput", function(){
					this.displayMessage();
				});
			}
			this.connect(this.iconNode, "onmouseenter", function(){
				if(this.message && domStyle.get(this.iconNode, "visibility") == "visible"){
					HoverHelpTooltip.show(this.message, this.iconNode, this.tooltipPosition, !this.isLeftToRight());
				}
			});
			
		},
		/**
		* Overridable method to display validation errors/hints
		*/
		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			HoverHelpTooltip.hide(this.oneuiBaseNode);
			HoverHelpTooltip.hide(this.iconNode);
			if(message && this.focused){
				var node = domStyle.get(this.iconNode, "visibility") == "hidden" ? this.oneuiBaseNode : this.iconNode;
				HoverHelpTooltip.show(message, node, this.tooltipPosition, !this.isLeftToRight());
			}
		}
	});
});

},
'dojo/NodeList-traverse':function(){
define("dojo/NodeList-traverse", ["./query", "./_base/lang", "./_base/array"], function(dquery, lang, array) {
	// module:
	//		dojo/NodeList-traverse
	// summary:
	//		TODOC

var NodeList = dquery.NodeList;

/*=====
dojo["NodeList-traverse"] = {
	// summary: Adds a chainable methods to dojo.query() / Nodelist instances for traversing the DOM
};

// doc alias helpers:
NodeList = dojo.NodeList;
=====*/

lang.extend(NodeList, {
	_buildArrayFromCallback: function(/*Function*/callback){
		// summary:
		// 		builds a new array of possibly differing size based on the input list.
		// 		Since the returned array is likely of different size than the input array,
		// 		the array's map function cannot be used.
		var ary = [];
		for(var i = 0; i < this.length; i++){
			var items = callback.call(this[i], this[i], ary);
			if(items){
				ary = ary.concat(items);
			}
		}
		return ary;	//Array
	},

	_getUniqueAsNodeList: function(/*Array*/ nodes){
		// summary:
		// 		given a list of nodes, make sure only unique
		// 		elements are returned as our NodeList object.
		// 		Does not call _stash().
		var ary = [];
		//Using for loop for better speed.
		for(var i = 0, node; node = nodes[i]; i++){
			//Should be a faster way to do this. dojo.query has a private
			//_zip function that may be inspirational, but there are pathways
			//in query that force nozip?
			if(node.nodeType == 1 && array.indexOf(ary, node) == -1){
				ary.push(node);
			}
		}
		return this._wrap(ary, null, this._NodeListCtor);	 //dojo.NodeList
	},

	_getUniqueNodeListWithParent: function(/*Array*/ nodes, /*String*/ query){
		// summary:
		// 		gets unique element nodes, filters them further
		// 		with an optional query and then calls _stash to track parent NodeList.
		var ary = this._getUniqueAsNodeList(nodes);
		ary = (query ? dquery._filterResult(ary, query) : ary);
		return ary._stash(this);  //dojo.NodeList
	},

	_getRelatedUniqueNodes: function(/*String?*/ query, /*Function*/ callback){
		// summary:
		// 		cycles over all the nodes and calls a callback
		// 		to collect nodes for a possible inclusion in a result.
		// 		The callback will get two args: callback(node, ary),
		// 		where ary is the array being used to collect the nodes.
		return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  //dojo.NodeList
	},

	children: function(/*String?*/ query){
		// summary:
		// 		Returns all immediate child elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the child elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".container").children();
		//		returns the four divs that are children of the container div.
		//		Running this code:
		//	|	dojo.query(".container").children(".red");
		//		returns the two divs that have the class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return lang._toArray(node.childNodes);
		}); //dojo.NodeList
	},

	closest: function(/*String*/ query, /*String|DOMNode?*/ root){
		// summary:
		// 		Returns closest parent that matches query, including current node in this
		// 		dojo.NodeList if it matches the query.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// query:
		//		a CSS selector.
		// root:
		//		If specified, query is relative to "root" rather than document body.
		// returns:
		//		dojo.NodeList, the closest parent that matches the query, including the current
		//		node in this dojo.NodeList if it matches the query.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		//	|		<div class="red">Red One</div>
		//	|		Some Text
		//	|		<div class="blue">Blue One</div>
		//	|		<div class="red">Red Two</div>
		//	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".red").closest(".container");
		//		returns the div with class "container".
		return this._getRelatedUniqueNodes(null, function(node, ary){
			do{
				if(dquery._filterResult([node], query, root).length){
					return node;
				}
			}while(node != root && (node = node.parentNode) && node.nodeType == 1);
			return null; //To make rhino strict checking happy.
		}); //dojo.NodeList
	},

	parent: function(/*String?*/ query){
		// summary:
		// 		Returns immediate parent elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the parent elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".text").parent();
		//		returns the two divs with class "blue".
		//		Running this code:
		//	|	dojo.query(".text").parent(".first");
		//		returns the one div with class "blue" and "first".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return node.parentNode;
		}); //dojo.NodeList
	},

	parents: function(/*String?*/ query){
		// summary:
		// 		Returns all parent elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the child elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all parent elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".text").parents();
		//		returns the two divs with class "blue", the div with class "container",
		// 	|	the body element and the html element.
		//		Running this code:
		//	|	dojo.query(".text").parents(".container");
		//		returns the one div with class "container".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			while(node.parentNode){
				node = node.parentNode;
				pary.push(node);
			}
			return pary;
		}); //dojo.NodeList
	},

	siblings: function(/*String?*/ query){
		// summary:
		// 		Returns all sibling elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").siblings();
		//		returns the two divs with class "red" and the other div
		// 	|	with class "blue" that does not have "first".
		//		Running this code:
		//	|	dojo.query(".first").siblings(".red");
		//		returns the two div with class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var nodes = (node.parentNode && node.parentNode.childNodes);
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i] != node){
					pary.push(nodes[i]);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	next: function(/*String?*/ query){
		// summary:
		// 		Returns the next element for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the next elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, the next element for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").next();
		//		returns the div with class "red" and has innerHTML of "Red Two".
		//		Running this code:
		//	|	dojo.query(".last").next(".red");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var next = node.nextSibling;
			while(next && next.nodeType != 1){
				next = next.nextSibling;
			}
			return next;
		}); //dojo.NodeList
	},

	nextAll: function(/*String?*/ query){
		// summary:
		// 		Returns all sibling elements that come after the nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red next">Red Two</div>
		// 	|		<div class="blue next">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").nextAll();
		//		returns the two divs with class of "next".
		//		Running this code:
		//	|	dojo.query(".first").nextAll(".red");
		//		returns the one div with class "red" and innerHTML "Red Two".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var next = node;
			while((next = next.nextSibling)){
				if(next.nodeType == 1){
					pary.push(next);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	prev: function(/*String?*/ query){
		// summary:
		// 		Returns the previous element for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the previous elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, the previous element for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").prev();
		//		returns the div with class "red" and has innerHTML of "Red One".
		//		Running this code:
		//	|	dojo.query(".first").prev(".blue");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var prev = node.previousSibling;
			while(prev && prev.nodeType != 1){
				prev = prev.previousSibling;
			}
			return prev;
		}); //dojo.NodeList
	},

	prevAll: function(/*String?*/ query){
		// summary:
		// 		Returns all sibling elements that come before the nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		The returned nodes will be in reverse DOM order -- the first node in the list will
		// 		be the node closest to the original node/NodeList.
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".second").prevAll();
		//		returns the two divs with class of "prev".
		//		Running this code:
		//	|	dojo.query(".first").prevAll(".red");
		//		returns the one div with class "red prev" and innerHTML "Red One".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var prev = node;
			while((prev = prev.previousSibling)){
				if(prev.nodeType == 1){
					pary.push(prev);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	andSelf: function(){
		// summary:
		// 		Adds the nodes from the previous dojo.NodeList to the current dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".second").prevAll().andSelf();
		//		returns the two divs with class of "prev", as well as the div with class "second".
		return this.concat(this._parent);	//dojo.NodeList
	},

	//Alternate methods for the :first/:last/:even/:odd pseudos.
	first: function(){
		// summary:
		// 		Returns the first node in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the first node in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".blue").first();
		//		returns the div with class "blue" and "first".
		return this._wrap(((this[0] && [this[0]]) || []), this); //dojo.NodeList
	},

	last: function(){
		// summary:
		// 		Returns the last node in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the last node in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".blue").last();
		//		returns the last div with class "blue",
		return this._wrap((this.length ? [this[this.length - 1]] : []), this); //dojo.NodeList
	},

	even: function(){
		// summary:
		// 		Returns the even nodes in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the even nodes in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".interior").even();
		//		returns the two divs with class "blue"
		return this.filter(function(item, i){
			return i % 2 != 0;
		}); //dojo.NodeList
	},

	odd: function(){
		// summary:
		// 		Returns the odd nodes in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the odd nodes in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".interior").odd();
		//		returns the two divs with class "red"
		return this.filter(function(item, i){
			return i % 2 == 0;
		}); //dojo.NodeList
	}
});

return NodeList;
});

},
'idx/oneui/form/_DateTimeTextBox':function(){
require({cache:{
'url:idx/oneui/form/templates/DropDownBox.html':"<div id=\"widget_${id}\" class=\"dijitInline dijitReset dijitLeft idxComposite\"\r\n\t><div class=\"idxLabel dijitInline dijitHidden\"><span class=\"idxRequiredIcon\">*&nbsp</span><label for=\"${id}\" dojoAttachPoint=\"compLabelNode\"></label></div\r\n\t><div class=\"dijitInline\"\r\n\t><div class=\"dijit dijitInline dijitReset dijitInlineTable dijitLeft\" role=\"combobox\" dojoAttachPoint='_aroundNode,stateNode,oneuiBaseNode'\r\n\t\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\" dojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"/\r\n\t></div\r\n\t></div\r\n\t><div class='dijitReset dijitInline oneuiIcon'\r\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\r\n\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\" ${_buttonInputDisabled}/\r\n\t></div\r\n\t><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"></div\r\n\t><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\r\n\t\t><div class=\"dijitValidationIcon\"><input class=\"dijitReset dijitInputField dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\r\n\t></div></div\r\n\t><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\r\n\t></div\r\n></div>"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/form/_DateTimeTextBox", [
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/date", 
	"dojo/date/locale", 
	"dojo/date/stamp", 
	"dijit/_base/wai",
	"dijit/form/RangeBoundTextBox",
	"dijit/form/ValidationTextBox", 
	"dijit/_HasDropDown",
	"./TextBox",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, lang, date, locale, stamp, wai, RangeBoundTextBox, ValidationTextBox, _HasDropDown, 
		TextBox, template) {

	new Date("X"); // workaround for #11279, new Date("") == NaN
	
	/*=====
	dojo.declare(
		"dijit.form._DateTimeTextBox.__Constraints",
		[dijit.form.RangeBoundTextBox.__Constraints, dojo.date.locale.__FormatOptions], {
		// summary:
		//		Specifies both the rules on valid/invalid values (first/last date/time allowed),
		//		and also formatting options for how the date/time is displayed.
		// example:
		//		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
		//	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
	});
	=====*/

	return declare("idx.oneui.form._DateTimeTextBox", [RangeBoundTextBox, _HasDropDown], {
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		templateString: template,

		// hasDownArrow: [const] Boolean
		//		Set this textbox to display a down arrow button, to open the drop down list.
		hasDownArrow: false,

		// openOnClick: [const] Boolean
		//		Set to true to open drop down upon clicking anywhere on the textbox.
		openOnClick: true,

		/*=====
		// constraints: dijit.form._DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.  See `dijit.form._DateTimeTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: locale.regexp,

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 Uses Gregorian calendar routines
		//		at dojo.date, by default.
		datePackage: "dojo.date",

		// Override _FormWidget.compare() to work for dates/times
		compare: function(/*Date*/ val1, /*Date*/ val2){
			var isInvalid1 = this._isInvalidDate(val1);
			var isInvalid2 = this._isInvalidDate(val2);
			return isInvalid1 ? (isInvalid2 ? 0 : -1) : (isInvalid2 ? 1 : date.compare(val1, val2, this._selector));
		},

		// flag to _HasDropDown to make drop down Calendar width == <input> width
		forceWidth: true,

		format: function(/*Date*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			return value ? this.dateLocaleModule.format(value, constraints) : '';
		},

		"parse": function(/*String*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/ val, /*Object?*/ options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return stamp.toISOString(val, options);
		},

		// dropDownDefaultValue: Date
		//		The default value to focus in the popupClass widget when the textbox value is empty.
		dropDownDefaultValue : new Date(),

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`
		value: new Date(""),	// value.toString()="NaN"

		_blankValue: null,	// used by filter() when the textbox is blank

		// popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(/*Object*/ args){
			var dateClass = args.datePackage ? args.datePackage + ".Date" : "Date";
			this.dateClassObj = lang.getObject(dateClass, false);
			this.value = new this.dateClassObj("");

			this.datePackage = args.datePackage || this.datePackage;
			this.dateLocaleModule = lang.getObject(this.datePackage + ".locale", false);
			this.regExpGen = this.dateLocaleModule.regexp;
			this._invalidDate = idx.oneui.form._DateTimeTextBox.prototype.value.toString();
		},

		buildRendering: function(){
			this.inherited(arguments);

			if(!this.hasDownArrow){
				this._buttonNode.style.display = "none";
			}

			// If openOnClick is true, we basically just want to treat the whole widget as the
			// button.  We need to do that also if the actual drop down button will be hidden,
			// so that there's a mouse method for opening the drop down.
			if(this.openOnClick || !this.hasDownArrow){
				this._buttonNode = this.oneuiBaseNode;
				this.oneuiBaseClass += " dijitComboBoxOpenOnClick";
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = stamp.fromISOString;
			if(typeof constraints.min == "string"){ constraints.min = fromISO(constraints.min); }
 			if(typeof constraints.max == "string"){ constraints.max = fromISO(constraints.max); }
			this.inherited(arguments, [constraints]);
		},

		_isInvalidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking for invalid conditions
			// tags:
			//		private
			return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
		},

		_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
			if(value !== undefined){
				if(typeof value == "string"){
					value = stamp.fromISOString(value);
				}
				if(this._isInvalidDate(value)){
					value = null;
				}
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
			}
//			this.inherited(arguments, [value, priorityChange, formattedValue]);
			wai.setWaiState(this.focusNode, "valuenow", value);
			TextBox.prototype._setValueAttr.apply(this, arguments);
			if(this.dropDown){
				this.dropDown.set('value', value, false);
			}
		},
		_refreshState: function(){
			TextBox.prototype._refreshState.apply(this, arguments);
		},

		_set: function(attr, value){
			// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
			if(attr == "value" && this.value instanceof Date && this.compare(value, this.value) == 0){
				return;
			}
			this.inherited(arguments);
		},

		_setDropDownDefaultValueAttr: function(/*Date*/ val){
			this.dropDownDefaultvalue = this._isInvalidDate(val) ? new this.dateClassObj() : val;
		},

		openDropDown: function(/*Function*/ callback){
			// rebuild drop down every time, so that constraints get copied (#6002)
			if(this.dropDown){
				this.dropDown.destroy();
			}
			var PopupProto = lang.getObject(this.popupClass, false),
				textBox = this,
				value = this.get("value");
			this.dropDown = new PopupProto({
				autoFocus: false,
				onChange: function(value){
					// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
					idx.oneui.form._DateTimeTextBox.superclass._setValueAttr.call(textBox, value, true);
				},
				id: this.id + "_popup",
				dir: textBox.dir,
				lang: textBox.lang,
				value: value,
				currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
				constraints: textBox.constraints,
				filterString: textBox.filterString, // for TimeTextBox, to filter times shown
				datePackage: textBox.datePackage,
				isDisabledDate: function(/*Date*/ date){
					// summary:
					// 	disables dates outside of the min/max of the _DateTimeTextBox
					return !textBox.rangeCheck(date, textBox.constraints);
				}
			});
			this.inherited(arguments);
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		},
		_onDropDownMouseUp: function(){
			this.inherited(arguments);
			if((!this.dropDown.focus) || (!this.dropDown.autoFocus)){
				setTimeout(lang.hitch(this, "focus"), 0);
			}
		}
	});
});

},
'url:curam/layout/resources/TabContainer.html':"<div class=\"dijitTabContainer\">\r\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\r\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer dijitAlignTop\"></div>\r\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container dijitAlignClient\" data-dojo-attach-point=\"containerNode\"></div>\r\n</div>\r\n",
'dojox/storage/Provider':function(){
// wrapped by build app
define("dojox/storage/Provider", ["dijit","dojo","dojox"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.Provider");

dojo.declare("dojox.storage.Provider", null, {
	// summary: A singleton for working with dojox.storage.
	// description:
	//		dojox.storage exposes the current available storage provider on this
	//		platform. It gives you methods such as dojox.storage.put(),
	//		dojox.storage.get(), etc.
	//
	//		For more details on dojox.storage, see the primary documentation
	//		page at
	//			http://manual.dojotoolkit.org/storage.html
	//
	//		Note for storage provider developers who are creating subclasses-
	//		This is the base class for all storage providers Specific kinds of
	//		Storage Providers should subclass this and implement these methods.
	//		You should avoid initialization in storage provider subclass's
	//		constructor; instead, perform initialization in your initialize()
	//		method.
	constructor: function(){
	},
	
	// SUCCESS: String
	//	Flag that indicates a put() call to a
	//	storage provider was succesful.
	SUCCESS: "success",
	
	// FAILED: String
	//	Flag that indicates a put() call to
	//	a storage provider failed.
	FAILED: "failed",
	
	// PENDING: String
	//	Flag that indicates a put() call to a
	//	storage provider is pending user approval.
	PENDING: "pending",
	
	// SIZE_NOT_AVAILABLE: String
	//	Returned by getMaximumSize() if this storage provider can not determine
	//	the maximum amount of data it can support.
	SIZE_NOT_AVAILABLE: "Size not available",
	
	// SIZE_NO_LIMIT: String
	//	Returned by getMaximumSize() if this storage provider has no theoretical
	//	limit on the amount of data it can store.
	SIZE_NO_LIMIT: "No size limit",

	// DEFAULT_NAMESPACE: String
	//	The namespace for all storage operations. This is useful if several
	//	applications want access to the storage system from the same domain but
	//	want different storage silos.
	DEFAULT_NAMESPACE: "default",
	
	// onHideSettingsUI: Function
	//	If a function is assigned to this property, then when the settings
	//	provider's UI is closed this function is called. Useful, for example,
	//	if the user has just cleared out all storage for this provider using
	//	the settings UI, and you want to update your UI.
	onHideSettingsUI: null,

	initialize: function(){
		// summary:
		//		Allows this storage provider to initialize itself. This is
		//		called after the page has finished loading, so you can not do
		//		document.writes(). Storage Provider subclasses should initialize
		//		themselves inside of here rather than in their function
		//		constructor.
		console.warn("dojox.storage.initialize not implemented");
	},
	
	isAvailable: function(){ /*Boolean*/
		// summary:
		//		Returns whether this storage provider is available on this
		//		platform.
		console.warn("dojox.storage.isAvailable not implemented");
	},

	put: function(	/*string*/ key,
					/*object*/ value,
					/*function*/ resultsHandler,
					/*string?*/ namespace){
		// summary:
		//		Puts a key and value into this storage system.
		// description:
		//		Example-
		//			var resultsHandler = function(status, key, message, namespace){
		//			  alert("status="+status+", key="+key+", message="+message);
		//			};
		//			dojox.storage.put("test", "hello world", resultsHandler);
		//
		//			Arguments:
		//
		//			status - The status of the put operation, given by
		//								dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
		//								dojox.storage.PENDING
		//			key - The key that was used for the put
		//			message - An optional message if there was an error or things failed.
		//			namespace - The namespace of the key. This comes at the end since
		//									it was added later.
		//
		//		Important note: if you are using Dojo Storage in conjunction with
		//		Dojo Offline, then you don't need to provide
		//		a resultsHandler; this is because for Dojo Offline we
		//		use Google Gears to persist data, which has unlimited data
		//		once the user has given permission. If you are using Dojo
		//		Storage apart from Dojo Offline, then under the covers hidden
		//		Flash might be used, which is both asychronous and which might
		//		get denied; in this case you must provide a resultsHandler.
		// key:
		//		A string key to use when retrieving this value in the future.
		// value:
		//		A value to store; this can be any JavaScript type.
		// resultsHandler:
		//		A callback function that will receive three arguments. The
		//		first argument is one of three values: dojox.storage.SUCCESS,
		//		dojox.storage.FAILED, or dojox.storage.PENDING; these values
		//		determine how the put request went. In some storage systems
		//		users can deny a storage request, resulting in a
		//		dojox.storage.FAILED, while in other storage systems a storage
		//		request must wait for user approval, resulting in a
		//		dojox.storage.PENDING status until the request is either
		//		approved or denied, resulting in another call back with
		//		dojox.storage.SUCCESS.
		//		The second argument in the call back is the key name that was being stored.
		//		The third argument in the call back is an optional message that
		//		details possible error messages that might have occurred during
		//		the storage process.
		//	namespace:
		//		Optional string namespace that this value will be placed into;
		//		if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE
		
		console.warn("dojox.storage.put not implemented");
	},

	get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
		// summary:
		//		Gets the value with the given key. Returns null if this key is
		//		not in the storage system.
		// key:
		//		A string key to get the value of.
		//	namespace:
		//		Optional string namespace that this value will be retrieved from;
		//		if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
		// return: Returns any JavaScript object type; null if the key is not present
		console.warn("dojox.storage.get not implemented");
	},

	hasKey: function(/*string*/ key, /*string?*/ namespace){
		// summary: Determines whether the storage has the given key.
		return !!this.get(key, namespace); // Boolean
	},

	getKeys: function(/*string?*/ namespace){ /*Array*/
		// summary: Enumerates all of the available keys in this storage system.
		// return: Array of available keys
		console.warn("dojox.storage.getKeys not implemented");
	},
	
	clear: function(/*string?*/ namespace){
		// summary:
		//		Completely clears this storage system of all of it's values and
		//		keys. If 'namespace' is provided just clears the keys in that
		//		namespace.
		console.warn("dojox.storage.clear not implemented");
	},
  
	remove: function(/*string*/ key, /*string?*/ namespace){
		// summary: Removes the given key from this storage system.
		console.warn("dojox.storage.remove not implemented");
	},
	
	getNamespaces: function(){ /*string[]*/
		console.warn("dojox.storage.getNamespaces not implemented");
	},

	isPermanent: function(){ /*Boolean*/
		// summary:
		//		Returns whether this storage provider's values are persisted
		//		when this platform is shutdown.
		console.warn("dojox.storage.isPermanent not implemented");
	},

	getMaximumSize: function(){ /* mixed */
		// summary: The maximum storage allowed by this provider
		// returns:
		//	Returns the maximum storage size
		//	supported by this provider, in
		//	thousands of bytes (i.e., if it
		//	returns 60 then this means that 60K
		//	of storage is supported).
		//
		//	If this provider can not determine
		//	it's maximum size, then
		//	dojox.storage.SIZE_NOT_AVAILABLE is
		//	returned; if there is no theoretical
		//	limit on the amount of storage
		//	this provider can return, then
		//	dojox.storage.SIZE_NO_LIMIT is
		//	returned
		console.warn("dojox.storage.getMaximumSize not implemented");
	},
		
	putMultiple: function(	/*array*/ keys,
							/*array*/ values,
							/*function*/ resultsHandler,
							/*string?*/ namespace){
		// summary:
		//		Puts multiple keys and values into this storage system.
		// description:
		//		Example-
		//			var resultsHandler = function(status, key, message){
		//			  alert("status="+status+", key="+key+", message="+message);
		//			};
		//			dojox.storage.put(["test"], ["hello world"], resultsHandler);
		//
		//		Important note: if you are using Dojo Storage in conjunction with
		//		Dojo Offline, then you don't need to provide
		//		a resultsHandler; this is because for Dojo Offline we
		//		use Google Gears to persist data, which has unlimited data
		//		once the user has given permission. If you are using Dojo
		//		Storage apart from Dojo Offline, then under the covers hidden
		//		Flash might be used, which is both asychronous and which might
		//		get denied; in this case you must provide a resultsHandler.
		// keys:
		//		An array of string keys to use when retrieving this value in the future,
		//		one per value to be stored
		// values:
		//		An array of values to store; this can be any JavaScript type, though the
		//		performance of plain strings is considerably better
		// resultsHandler:
		//		A callback function that will receive three arguments. The
		//		first argument is one of three values: dojox.storage.SUCCESS,
		//		dojox.storage.FAILED, or dojox.storage.PENDING; these values
		//		determine how the put request went. In some storage systems
		//		users can deny a storage request, resulting in a
		//		dojox.storage.FAILED, while in other storage systems a storage
		//		request must wait for user approval, resulting in a
		//		dojox.storage.PENDING status until the request is either
		//		approved or denied, resulting in another call back with
		//		dojox.storage.SUCCESS.
		//		The second argument in the call back is the key name that was being stored.
		//		The third argument in the call back is an optional message that
		//		details possible error messages that might have occurred during
		//		the storage process.
		//	namespace:
		//		Optional string namespace that this value will be placed into;
		//		if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE
		
		for(var i = 0; i < keys.length; i++){
			dojox.storage.put(keys[i], values[i], resultsHandler, namespace);
		}
	},

	getMultiple: function(/*array*/ keys, /*string?*/ namespace){ /*Object*/
		// summary:
		//		Gets the valuse corresponding to each of the given keys.
		//		Returns a null array element for each given key that is
		//		not in the storage system.
		// keys:
		//		An array of string keys to get the value of.
		//	namespace:
		//		Optional string namespace that this value will be retrieved from;
		//		if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
		// return: Returns any JavaScript object type; null if the key is not present
		
		var results = [];
		for(var i = 0; i < keys.length; i++){
			results.push(dojox.storage.get(keys[i], namespace));
		}
		
		return results;
	},

	removeMultiple: function(/*array*/ keys, /*string?*/ namespace) {
		// summary: Removes the given keys from this storage system.
		
		for(var i = 0; i < keys.length; i++){
			dojox.storage.remove(keys[i], namespace);
		}
	},
	
	isValidKeyArray: function( keys) {
		if(keys === null || keys === undefined || !dojo.isArray(keys)){
			return false;
		}

		//	JAC: This could be optimized by running the key validity test
		//  directly over a joined string
		return !dojo.some(keys, function(key){
			return !this.isValidKey(key);
		}, this); // Boolean
	},

	hasSettingsUI: function(){ /*Boolean*/
		// summary: Determines whether this provider has a settings UI.
		return false;
	},

	showSettingsUI: function(){
		// summary: If this provider has a settings UI, determined
		// by calling hasSettingsUI(), it is shown.
		console.warn("dojox.storage.showSettingsUI not implemented");
	},

	hideSettingsUI: function(){
		// summary: If this provider has a settings UI, hides it.
		console.warn("dojox.storage.hideSettingsUI not implemented");
	},
	
	isValidKey: function(/*string*/ keyName){ /*Boolean*/
		// summary:
		//		Subclasses can call this to ensure that the key given is valid
		//		in a consistent way across different storage providers. We use
		//		the lowest common denominator for key values allowed: only
		//		letters, numbers, and underscores are allowed. No spaces.
		if(keyName === null || keyName === undefined){
			return false;
		}
			
		return /^[0-9A-Za-z_]*$/.test(keyName);
	},
	
	getResourceList: function(){ /* Array[] */
		// summary:
		//	Returns a list of URLs that this
		//	storage provider might depend on.
		// description:
		//	This method returns a list of URLs that this
		//	storage provider depends on to do its work.
		//	This list is used by the Dojo Offline Toolkit
		//	to cache these resources to ensure the machinery
		//	used by this storage provider is available offline.
		//	What is returned is an array of URLs.
		//  Note that Dojo Offline uses Gears as its native
		//  storage provider, and does not support using other
		//  kinds of storage providers while offline anymore.
		
		return [];
	}
});

});

},
'dojo/dnd/common':function(){
define("dojo/dnd/common", ["../main"], function(dojo) {
	// module:
	//		dojo/dnd/common
	// summary:
	//		TODOC

dojo.getObject("dnd", true, dojo);

dojo.dnd.getCopyKeyState = dojo.isCopyKey;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

return dojo.dnd;
});

},
'curam/util/ResourceBundle':function(){
/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define("curam/util/ResourceBundle", ["dojo/i18n",
        "dojo/string"
        ], function(i18n, string) {

/*
 * Modification History
 * --------------------
 * 20-May-2013  MV  [CR00383012] Fail if there are no properties loaded.
 * 19-May-2012  BOS [CR00346368] Use new Dojo AMD format.
 * 15-Jun-2012  MV  [CR00329034] Added proper documentation.
 * 11-Jun-2012  MV  [CR00328689] Initial version.
 */

/**
 * @name curam.util.ResourceBundle
 * @namespace Provides access to localizable resources.
 * <p/>
 * The process for getting localized messaged from a resource bundle consists
 * of two steps: <ol>
 * <li>Load the resources using <code>dojo.requireLocalization()</code></li>
 * <li>Create an instance of <code>curam.util.ResourceBunlde</code> class
 *      to access the localized resources.</li>
 * </ol>
 *
 * <h2>Loading Resources</h2>
 * In most cases the call to load resources should look like this:
 * <code><pre>dojo.requireLocalization("curam.application", "MyResources")</pre></code>
 * <p/>
 * "curam.application" is the default package into which all localizable
 * resources are placed by Curam infrastructure.
 * <p/>
 * "MyResources" is an example of a resource bundle name. Resource bundle name
 * will be specific to your own JavaScript code and it is derived from the name
 * of the related resource bundle *.properties file.
 *
 * <h2>Accessing Localized Resources</h2>
 * Previously loaded localized resources can be accessed in the following way:
 * <code><pre>dojo.require("curam.util.ResourceBundle");
 * var bundle = new curam.util.ResourceBundle("MyResources");
 * var localizedMessage = bundle.getProperty("myPropertyKey");
 * </pre></code>
 * Note in the above example there is no need to specify the default package
 * name "curam.appliciation" - the infrastructure will use the default
 * if no package is specified. This should be the case in most normal
 * situations.
 *
 * <h2>Resource File Naming and Content</h2>
 * The localizable resources for your JavaScript are expected in the standard
 * Java Properties format.
 * <p/>
 * By convention the name of the resource file for your JavaScript should be
 * derived from name of the JavaScript file itself. For example if your
 * JavaScript file is called "MyJavaScript.js" then related localizable
 * resources should be placed in <code>MyJavaScript.js.properties</code> file.
 * This .properties file can be placed anywhere in the component directory, but
 * by convention it should be in the same directory as the related *.js file.
 * The only exception to this, is that a *.js file within a WebContent directory
 * cannot have it's associated .properties file within the same directory - the
 * associated .properties file must be placed within a directory outside of the
 * WebContent directory.
 * <p/>
 * The tranlations of the resource bundle should then be placed in files named
 * in the following way (again following the Java standard naming):
 * <code>MyJavaScript.js_fr_CA.properties</code>,
 * <code>MyJavaScript.js_fr.properties</code>,
 * <code>MyJavaScript.js_cs_CZ.properties</code>, etc.
 * <p/>
 * Sample content of a resource file is as follows:
 * <code><pre>myPropertyKey=A localizable message.
 * another.property.key=Another localizable message.
 * propertyKey3=A message with %s value placeholders %s.
 * </pre></code>
 * Please note property keys with dots are allowed and string value
 * substitution into mesages is supported.
 */
 var ResourceBundle = dojo.declare("curam.util.ResourceBundle", null,
/**
 * @lends curam.util.ResourceBundle.prototype
 */
{
  _bundle: undefined,

  /**
   * Constructor takes bundle name and optionally locale.
   *
   * @param {String} possiblyQualifiedBundleName Bundle name. Optionally
   *           qualified with package name. E.g. "my.package.MyResourceBundle".
   * @param {String} [locale] Locale string in the following format:
   *            <code> en-US</code> where "en" is language code and "US"
   *            is variant as per IETF specification.
   */
  constructor: function(possiblyQualifiedBundleName, locale) {
    var parts = possiblyQualifiedBundleName.split(".");
    var bundleName = parts[parts.length - 1];
    var packageName = parts.length == 1 ? "curam.application"
        : possiblyQualifiedBundleName.slice(0,
            possiblyQualifiedBundleName.length - bundleName.length - 1);
    try {
      var b = i18n.getLocalization(packageName, bundleName, locale);
      if (this._isEmpty(b)) {
        throw new Error("Empty resource bundle.");

      } else {
        this._bundle = b;
      }

    } catch (e) {
      throw new Error("Unable to access resource bundle: " + packageName + "."
          + bundleName + ": " + e.message);
    }
  },
  
  /**
   * Checks if the passed bundle is empty or has some properties.
   * @param bundle The bundle object to check.
   * @returns {Boolean} True if the bundle if empty, false if it contains
   *            properties.
   */
  _isEmpty: function(bundle) {
    for (var prop in bundle) {
      // if it has at least one property, return false - it is not empty
      return false;
    }
    // no properties - return true as it is empty
    return true;
  },

  /**
   * Gets the localized value of a specified property, optionally replacing any
   * placeholders with appropriate values from specified array.
   *
   * @param {String} key The property key of the required message.
   * @param {Array} [values] An array of values to be used for replacing
   *            placeholders within the specified message.
   * @returns {String} Value of the requested localized property from
   *            the bundle.
   */
  getProperty: function(key, values) {
    var msg = this._bundle[key];

    var result = msg;
    if (values) {
      result = string.substitute(msg, values);
    }

    return result;
  }
  });
 return ResourceBundle;
});
},
'dijit/Menu':function(){
define("dijit/Menu", [
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel",
	"dojo/keys",	// keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body win.doc.documentElement win.doc.frames win.withGlobal
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, event, dom, domAttr, domGeometry, domStyle, kernel, keys, lang, on,
			has, win, winUtils, pm, DropDownMenu, ready){

/*=====
	var DropDownMenu = dijit.DropDownMenu;
=====*/

// module:
//		dijit/Menu
// summary:
//		Includes dijit.Menu widget and base class dijit._MenuBase

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.Menu", DropDownMenu, {
	// summary:
	//		A context menu you can assign to multiple elements

	constructor: function(){
		this._bindings = [];
	},

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(win.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later set('targetNodeIds', ...) call.  There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			array.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		this.inherited(arguments);
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		return winUtils.get(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && win.doc.frames[iframe_el.name]) || null;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		return iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && win.doc.frames[iframe_el.name] && win.doc.frames[iframe_el.name].document)
			|| null;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dom.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.  Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				window = this._iframeContentWindow(iframe);
			cn = win.withGlobal(window, win.body);
		}else{

			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == win.body() ? win.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
		// we need to monitor keyboard events in addition to the oncontextmenu event.
		var doConnects = lang.hitch(this, function(cn){
			return [
				// TODO: when leftClickToOpen is true then shouldn't space/enter key trigger the menu,
				// rather than shift-F10?
				on(cn, this.leftClickToOpen ? "click" : "contextmenu", lang.hitch(this, function(evt){
					// Schedule context menu to be opened unless it's already been scheduled from onkeydown handler
					event.stop(evt);
					this._scheduleOpen(evt.target, iframe, {x: evt.pageX, y: evt.pageY});
				})),
				on(cn, "keydown", lang.hitch(this, function(evt){
					if(evt.shiftKey && evt.keyCode == keys.F10){
						event.stop(evt);
						this._scheduleOpen(evt.target, iframe);	// no coords - open near target node
					}
				}))
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use connect.connect(), see #9609.

			binding.onloadHandler = lang.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var window = this._iframeContentWindow(iframe);
					cn = win.withGlobal(window, win.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dom.byId(nodeName);
		}catch(e){
			// On IE the dom.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && domAttr.has(node, attrName)){
			var bid = domAttr.get(node, attrName)-1, b = this._bindings[bid], h;
			while(h = b.connects.pop()){
				h.remove();
			}

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			domAttr.remove(node, attrName);
			delete this._bindings[bid];
		}
	},

	_scheduleOpen: function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
		// summary:
		//		Set timer to display myself.  Using a timer rather than displaying immediately solves
		//		two problems:
		//
		//		1. IE: without the delay, focus work in "open" causes the system
		//		context menu to appear in spite of stopEvent.
		//
		//		2. Avoid double-shows on linux, where shift-F10 generates an oncontextmenu event
		//		even after a event.stop(e).  (Shift-F10 on windows doesn't generate the
		//		oncontextmenu event.)

		if(!this._openTimer){
			this._openTimer = setTimeout(lang.hitch(this, function(){
				delete this._openTimer;
				this._openMyself({
					target: target,
					iframe: iframe,
					coords: coords
				});
			}), 1);
		}
	},

	_openMyself: function(args){
		// summary:
		//		Internal function for opening myself when the user does a right-click or something similar.
		// args:
		//		This is an Object containing:
		//		* target:
		//			The node that is being clicked
		//		* iframe:
		//			If an <iframe> is being clicked, iframe points to that iframe
		//		* coords:
		//			Put menu at specified x/y position in viewport, or if iframe is
		//			specified, then relative to iframe.
		//
		//		_openMyself() formerly took the event object, and since various code references
		//		evt.target (after connecting to _openMyself()), using an Object for parameters
		//		(so that old code still works).

		var target = args.target,
			iframe = args.iframe,
			coords = args.coords;

		// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
		// then near the node the menu is assigned to.
		if(coords){
			if(iframe){
				// Specified coordinates are on <body> node of an <iframe>, convert to match main document
				var ifc = domGeometry.position(iframe, true),
					window = this._iframeContentWindow(iframe),
					scroll = win.withGlobal(window, "_docScroll", dojo);

				var cs = domStyle.getComputedStyle(iframe),
					tp = domStyle.toPixelValue,
					left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

				coords.x += ifc.x + left - scroll.x;
				coords.y += ifc.y + top - scroll.y;
			}
		}else{
			coords = domGeometry.position(target, true);
			coords.x += 10;
			coords.y += 10;
		}

		var self=this;
		var prevFocusNode = this._focusManager.get("prevNode");
		var curFocusNode = this._focusManager.get("curNode");
		var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus && savedFocusNode){
				savedFocusNode.focus();
			}
			pm.close(self);
		}
		pm.open({
			popup: this,
			x: coords.x,
			y: coords.y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			pm.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		array.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
});

});

},
'dijit/_base/window':function(){
define("dijit/_base/window", [
	"dojo/window", // windowUtils.get
	".."	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/window
	// summary:
	//		Back compatibility module, new code should use windowUtils directly instead of using this module.

	dijit.getDocumentWindow = function(doc){
		return windowUtils.get(doc);
	};
});

},
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n></div>\n",
'dijit/form/MappedTextBox':function(){
define("dijit/form/MappedTextBox", [
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"./ValidationTextBox"
], function(declare, domConstruct, ValidationTextBox){

/*=====
	var ValidationTextBox = dijit.form.ValidationTextBox;
=====*/

	// module:
	//		dijit/form/MappedTextBox
	// summary:
	//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
	//		a visible formatted display value, and a serializable
	//		value in a hidden input field which is actually sent to the server.

	return declare("dijit.form.MappedTextBox", ValidationTextBox, {
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		// Override default behavior to assign name to focusNode
		_setNameAttr: null,

		serialize: function(val /*=====, options =====*/){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// val: anything
			// options: Object?
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._TemplatedMixin.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling domConstruct.create() with an attrs argument
			// to make query(input[name=...]) work on IE. (see #8660)
			this.valueNode = domConstruct.place("<input type='hidden'" + (this.name ? " name='" + this.name.replace(/'/g, "&quot;") + "'" : "") + "/>", this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	});
});

},
'url:dijit/form/templates/Select.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode\" cellspacing='0' cellpadding='0'\n\trole=\"combobox\" aria-haspopup=\"true\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\" role=\"presentation\"\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  data-dojo-attach-point=\"containerNode,_popupStateNode\"></span\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\n\t\t/></td><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t></tr></tbody\n></table>\n",
'dojox/layout/ContentPane':function(){
define("dojox/layout/ContentPane", [
	"dojo/_base/lang",
	"dojo/_base/xhr",
	"dijit/layout/ContentPane",
	"dojox/html/_base",
	"dojo/_base/declare"
], function (lang, xhrUtil, ContentPane, htmlUtil, declare) {

/*===== var ContentPane = dijit.layout.ContentPane =====*/
return declare("dojox.layout.ContentPane", ContentPane, {
	// summary:
	//		An extended version of dijit.layout.ContentPane.
	//		Supports infile scripts and external ones declared by <script src=''
	//		relative path adjustments (content fetched from a different folder)
	//		<style> and <link rel='stylesheet' href='..'> tags,
	//		css paths inside cssText is adjusted (if you set adjustPaths = true)
	//
	//		NOTE that dojo.require in script in the fetched file isn't recommended
	//		Many widgets need to be required at page load to work properly

	// adjustPaths: Boolean
	//		Adjust relative paths in html string content to point to this page.
	//		Only useful if you grab content from a another folder then the current one
	adjustPaths: false,

	// cleanContent: Boolean
	//	summary:
	//		cleans content to make it less likely to generate DOM/JS errors.
	//	description:
	//		useful if you send ContentPane a complete page, instead of a html fragment
	//		scans for
	//
	//			* title Node, remove
	//			* DOCTYPE tag, remove
	cleanContent: false,

	// renderStyles: Boolean
	//		trigger/load styles in the content
	renderStyles: false,

	// executeScripts: Boolean
	//		Execute (eval) scripts that is found in the content
	executeScripts: true,

	// scriptHasHooks: Boolean
	//		replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	// NOTE this name might change in the near future
	scriptHasHooks: false,

	constructor: function(){
		// init per instance properties, initializer doesn't work here because how things is hooked up in dijit._Widget
		this.ioArgs = {};
		this.ioMethod = xhrUtil.get;
	},

	onExecError: function(e){
		// summary:
		//		event callback, called on script error or on java handler error
		//		overide and return your own html string if you want a some text
		//		displayed within the ContentPane
	},

	_setContent: function(cont){
		// override dijit.layout.ContentPane._setContent, to enable path adjustments
		
		var setter = this._contentSetter;
		if(! (setter && setter instanceof htmlUtil._ContentSetter)) {
			setter = this._contentSetter = new htmlUtil._ContentSetter({
				node: this.containerNode,
				_onError: lang.hitch(this, this._onError),
				onContentError: lang.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		// stash the params for the contentSetter to allow inheritance to work for _setContent
		this._contentSetterParams = {
			adjustPaths: Boolean(this.adjustPaths && (this.href||this.referencePath)),
			referencePath: this.href || this.referencePath,
			renderStyles: this.renderStyles,
			executeScripts: this.executeScripts,
			scriptHasHooks: this.scriptHasHooks,
			scriptHookReplacement: "dijit.byId('"+this.id+"')"
		};

		this.inherited("_setContent", arguments);
	}
	// could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles
});
});
},
'cwtk/util/SlidingHandler':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/util/SlidingHandler", [
    "dojo", 
    "dojo/_base/declare", 
    "dojo/NodeList-traverse", 
    "dojo/fx"
], function(dojo, declare){

		return declare("cwtk.util.SlidingHandler", null, {

			swap:function(nodeA, nodeB) {
					
					var showNode = nodeA;
					var hideNode = nodeA;
					
					if(dojo.style(nodeA, 'display') === 'none') {
					    hideNode = nodeB;
					} else {
					    showNode = nodeB;
					}
					hideNode.style.display = "none";
					showNode.style.display = "";
					showNode.focus();
					dojo.query("a", showNode).forEach(function(n){
					    n.focus();
					});
					
				},
				
				slidePanel:function(panel) {
					
					var hidden = dojo.style(panel, 'display') === 'none';
					
					if(hidden){
						dojo.fx.wipeIn({node:panel, duration:300}).play();
					} else {
						dojo.fx.wipeOut({node:panel, duration:300}).play();
					}
				},
				slide:function(node) {
					
					var titlePane = dojo.query(node).parents(".cw-title-pane-query").first()[0];
					var showDiv = dojo.query(".cw-title-pane-show-div", titlePane)[0];
					var hideDiv = dojo.query(".cw-title-pane-hide-div", titlePane)[0];
					
					this.swap(showDiv, hideDiv);
					
					dojo.forEach(
						dojo.query(".cw-title-pane-display-panel", titlePane), 
						this.slidePanel);
				}
		});

});
},
'dojo/dnd/Moveable':function(){
define("dojo/dnd/Moveable", ["../main", "../Evented", "../touch", "./Mover"], function(dojo, Evented, touch) {
	// module:
	//		dojo/dnd/Moveable
	// summary:
	//		TODOC


/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", [Evented], {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, touch.press, this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node, ctor){
		return new ctor(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},

	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, touch.move, this, "onMouseMove"),
				dojo.connect(this.handle, touch.release, this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},

	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove");
		dojo.addClass(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover, /* Event */ e){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.

		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop, /* Event */ e){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.

		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.

		// default implementation does nothing
	}
});

return dojo.dnd.Moveable;
});

},
'dojo/store/util/QueryResults':function(){
define("dojo/store/util/QueryResults", ["../../_base/array", "../../_base/lang", "../../_base/Deferred"
], function(array, lang, Deferred) {
  //  module:
  //    dojo/store/util/QueryResults
  //  summary:
  //    The module defines a query results wrapper

var util = lang.getObject("dojo.store.util", true);

util.QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	//
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	//
	// returns: Object
	//		An array-like object that can be used for iterating over.
	//
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}
	// if it is a promise it may be frozen
	if(results.then){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		if(!results[method]){
			results[method] = function(){
				var args = arguments;
				return Deferred.when(results, function(results){
					Array.prototype.unshift.call(args, results);
					return util.QueryResults(array[method].apply(array, args));
				});
			};
		}
	}
	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(!results.total){
		results.total = Deferred.when(results, function(results){
			return results.length;
		});
	}
	return results;
};

return util.QueryResults;
});

},
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"onclick:_onClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" data-dojo-attach-point=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" data-dojo-attach-point=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>",
'dijit/form/CheckBox':function(){
require({cache:{
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"onclick:_onClick\"\n/></div>\n"}});
define("dijit/form/CheckBox", [
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel",
	"dojo/query", // query
	"dojo/ready",
	"./ToggleButton",
	"./_CheckBoxMixin",
	"dojo/text!./templates/CheckBox.html",
	"dojo/NodeList-dom" // NodeList.addClass/removeClass
], function(require, declare, domAttr, kernel, query, ready, ToggleButton, _CheckBoxMixin, template){

/*=====
	var ToggleButton = dijit.form.ToggleButton;
	var _CheckBoxMixin = dijit.form._CheckBoxMixin;
=====*/

	// module:
	//		dijit/form/CheckBox
	// summary:
	//		Checkbox widget

	// Back compat w/1.6, remove for 2.0
	if(!kernel.isAsync){
		ready(0, function(){
			var requires = ["dijit/form/RadioButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form.CheckBox", [ToggleButton, _CheckBoxMixin], {
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//			1. High contrast mode
		//			2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: template,

		baseClass: "dijitCheckBox",

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		data-dojo-type="dijit.CheckBox" value="chicken">)
			//		widget.set('value', string) will check the checkbox and change the value to the
			//		specified string
			//		widget.set('value', boolean) will change the checked state.
			if(typeof newValue == "string"){
				this._set("value", newValue);
				domAttr.set(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		// Override behavior from Button, since we don't have an iconNode
		_setIconClassAttr: null,

		postMixInProperties: function(){
			this.inherited(arguments);

			// Need to set initial checked state as part of template, so that form submit works.
			// domAttr.set(node, "checked", bool) doesn't work on IE until node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";
		},

		 _fillContent: function(){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		_onFocus: function(){
			if(this.id){
				query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/DropDownButton':function(){
require({cache:{
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-point=\"valueNode\" role=\"presentation\"\n/></span>\n"}});
define("dijit/form/DropDownButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/lang",	// hitch
	"dojo/query", // query
	"../registry",	// registry.byNode
	"../popup",		// dijit.popup2.hide
	"./Button",
	"../_Container",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownButton.html"
], function(declare, lang, query, registry, popup, Button, _Container, _HasDropDown, template){

/*=====
	Button = dijit.form.Button;
	_Container = dijit._Container;
	_HasDropDown = dijit._HasDropDown;
=====*/

// module:
//		dijit/form/DropDownButton
// summary:
//		A button with a drop down


return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button data-dojo-type="dijit.form.DropDownButton">
	// |		Hello world
	// |		<div data-dojo-type="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	win.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: template,

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = query("*", this.srcNodeRef);
			this.inherited(arguments, [nodes[0]]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown && this.dropDownContainer){
			var dropDownNode = query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = registry.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		if(this.dropDown){
			popup.hide(this.dropDown);
		}

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
	},

	loadDropDown: function(/*Function*/ callback){
		// Default implementation assumes that drop down already exists,
		// but hasn't loaded it's data (ex: ContentPane w/href).
		// App must override if the drop down is lazy-created.
		var dropDown = this.dropDown;
		var handler = dropDown.on("load", lang.hitch(this, function(){
			handler.remove();
			callback();
		}));
		dropDown.refresh();		// tell it to load
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

});

},
'dijit/_base/scroll':function(){
define("dijit/_base/scroll", [
	"dojo/window", // windowUtils.scrollIntoView
	".."	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/scroll
	// summary:
	//		Back compatibility module, new code should use windowUtils directly instead of using this module.

	dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
		// summary:
		//		Scroll the passed node into view, if it is not already.
		//		Deprecated, use `windowUtils.scrollIntoView` instead.

		windowUtils.scrollIntoView(node, pos);
	};
});

},
'dojo/regexp':function(){
define("dojo/regexp", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/regexp
	// summary:
	//		TODOC

lang.getObject("regexp", true, dojo);

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
};

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return dojo.regexp;
});

},
'curam/layout/TabContainer':function(){
require({cache:{
'url:curam/layout/resources/TabContainer.html':"<div class=\"dijitTabContainer\">\r\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\r\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer dijitAlignTop\"></div>\r\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container dijitAlignClient\" data-dojo-attach-point=\"containerNode\"></div>\r\n</div>\r\n"}});
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.layout.TabContainer
 * @namespace Customized dijit.layout.TabContainer class in order to change the
 * behavior when a tab is closed.
 */
define("curam/layout/TabContainer", ["dijit/layout/TabContainer",
        "dojo/text!curam/layout/resources/TabContainer.html"
        ], function(TabContainer, template) {
        
/*
 * Modification History
 * --------------------
 * 24-Oct-2012  SK  [CR00346419] Now destroys the unnecessary references to avoid
 *                    holding memory.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format. 
 * 17-Dec-2010  DG  [CR00239200] Do not select tabs when destroying container.
 * 29-Sep-2010  MK  [CR00221781] Revised to change tab by responding to
 *                    the onRemoveChild event.
 * 03-Aug-2010  MK  [CR00211743] Initial Version.
 */
 
var CuramTabContainer = dojo.declare("curam.layout.TabContainer", TabContainer,
  /**
   * @lends curam.layout.TabContainer
   */
{
  // The "dijitAlingTop" CSS class has been added to the "tablistSpacer" div in the template string.
  // The template string is actually defined in _TabContainerBase.js. No information on why this is needed
  // but it is obviously it was an alignment issue with the ootb Dojo widget. However, it "looks wrong".
  // If there was a bug with the ootb alignment (e.g. it didn't align to the center), then we should have fixed that
  // instaead of using "dijitAlignTop" to "push up" the contents to the center. It sounds to me like we are using
  // "align top" to make something "align center" !! Needs more investigation.  
  templateString: template,
  
  /**
   * The index of the currently selected tab.
   * @private
   */
  _theSelectedTabIndex: 0,

  /**
   * The page associated with the currently selected tab.
   * @private
   */
  _thePage: null,

  /**
   * The list of tabs.
   * @private
   */
  _theChildren: null,

  /**
   * Override of the superclass method in order to connect
   * the _changeTab function to the onRemoveChild event.
   */
  postCreate: function() {
    this.inherited(arguments);
    var tl = this.tablist;
    this.connect(tl, 'onRemoveChild', '_changeTab');
  },

  /**
    * This method implements the Curam specific behavior to
    * be executed when a tab is closed.
    *
    * @private
    */
  _changeTab: function(){
    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._beingDestroyed) {
      this._thePage = null;
      this._theChildren = null;
      return;
    }
    if (this._theChildren == null) {
      return;
    }
    // if the tab currently being closed is not the one in display
    // then we don't want to change focus
    if (this._theChildren[this._theSelectedTabIndex] != this._thePage) {
      this.selectChild(this._theChildren[this._theSelectedTabIndex]);
      this._thePage = null;
      this._theChildren = null;
      return;
    }

    // display correct tab.
    if (this._theChildren.length < 1 ) { // no tabs open
      this._thePage = null;
      return;
    } else if (this._theChildren.length == 1 ) { // only one tab open
      this.selectChild(this._theChildren[this._theChildren.length-1]);
      this._thePage = null;
      this._theChildren = null;
    } else { // more than one tab open

      if (this._theSelectedTabIndex == (this._theChildren.length - 1)){
        // closing the right most tab
        this.selectChild(this._theChildren[this._theChildren.length-2]);

      } else if (this._theSelectedTabIndex == 0) {
        // closing the left most tab
       this.selectChild(this._theChildren[1]);

      } else {
        // closing a tab that is neither the left or right most tab
        // we can be guaranteed there is at least three tabs
        if (this._theChildren.length > 2) {
          this.selectChild(this._theChildren[this._theSelectedTabIndex + 1]);
        }
      }
      this._thePage = null;
      this._theChildren = null;
    }
  },

  /**
   * Override of the parent method.
   */
  removeChild: function(/*dijit._Widget*/ page){
    // Overrides dijit.layout.TabContainer.removeChild()

    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._started && !this._beingDestroyed) {
      // find the index of the selected tab
      // need to find this before the call to inherited as the call to
      // inherited reset the selected tab.
      var children = this.getChildren();
      var i = 0;
      var selectedTabIndex = 0;
      for (i = 0; i < children.length; i++){
        if (children[i].get('selected')) {
          selectedTabIndex = i;
          break;
        }
      }

      // store the values so that they will be accessible by
      // _changeTab method when it responds to the firing.
      // of the onRemoveChild event
      this._theSelectedTabIndex = selectedTabIndex;
      this._thePage = page;
      this._theChildren = children;
    }

    // Call the superclass. It can handle destruction cleanly on its own.
    this.inherited(arguments);
  }
});

return CuramTabContainer;
});
},
'dojo/io/script':function(){
define("dojo/io/script", ["../main"], function(dojo) {
	// module:
	//		dojo/io/script
	// summary:
	//		TODOC

	dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.script.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply to this
		//		type as well, EXCEPT "handleAs". It is not applicable to
		//		dojo.io.script.get() calls, since it is implied by the usage of
		//		"jsonp" (response will be a JSONP call returning JSON)
		//		or the response is pure JavaScript defined in
		//		the body of the script that was attached.
		//	callbackParamName: String
		//		Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported for
		//		legacy code. See notes for jsonp property.
		//	jsonp: String
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		//	checkString: String
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use callbackParamName instead).
		//	frameDoc: Document
		//		The Document object for a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
		this.callbackParamName = callbackParamName;
		this.jsonp = jsonp;
		this.checkString = checkString;
		this.frameDoc = frameDoc;
	}
});
=====*/

	var loadEvent = dojo.isIE ? "onreadystatechange" : "load",
		readyRegExp = /complete|loaded/;

	dojo.io.script = {
		get: function(/*dojo.io.script.__ioArgs*/args){
			//	summary:
			//		sends a get request using a dynamically created script tag.
			var dfd = this._makeScriptDeferred(args);
			var ioArgs = dfd.ioArgs;
			dojo._ioAddQueryToUrl(ioArgs);

			dojo._ioNotifyStart(dfd);

			if(this._canAttach(ioArgs)){
				var node = this.attach(ioArgs.id, ioArgs.url, args.frameDoc);

				//If not a jsonp callback or a polling checkString case, bind
				//to load event on the script tag.
				if(!ioArgs.jsonp && !ioArgs.args.checkString){
					var handle = dojo.connect(node, loadEvent, function(evt){
						if(evt.type == "load" || readyRegExp.test(node.readyState)){
							dojo.disconnect(handle);
							ioArgs.scriptLoaded = evt;
						}
					});
				}
			}

			dojo._ioWatch(dfd, this._validCheck, this._ioCheck, this._resHandle);
			return dfd;
		},

		attach: function(/*String*/id, /*String*/url, /*Document?*/frameDocument){
			//	summary:
			//		creates a new <script> tag pointing to the specified URL and
			//		adds it to the document.
			//	description:
			//		Attaches the script element to the DOM.	 Use this method if you
			//		just want to attach a script to the DOM and do not care when or
			//		if it loads.
			var doc = (frameDocument || dojo.doc);
			var element = doc.createElement("script");
			element.type = "text/javascript";
			element.src = url;
			element.id = id;
			element.async = true;
			element.charset = "utf-8";
			return doc.getElementsByTagName("head")[0].appendChild(element);
		},

		remove: function(/*String*/id, /*Document?*/frameDocument){
			//summary: removes the script element with the given id, from the given frameDocument.
			//If no frameDocument is passed, the current document is used.
			dojo.destroy(dojo.byId(id, frameDocument));

			//Remove the jsonp callback on dojo.io.script, if it exists.
			if(this["jsonp_" + id]){
				delete this["jsonp_" + id];
			}
		},

		_makeScriptDeferred: function(/*Object*/args){
			//summary:
			//		sets up a Deferred object for an IO request.
			var dfd = dojo._ioSetArgs(args, this._deferredCancel, this._deferredOk, this._deferredError);

			var ioArgs = dfd.ioArgs;
			ioArgs.id = dojo._scopeName + "IoScript" + (this._counter++);
			ioArgs.canDelete = false;

			//Special setup for jsonp case
			ioArgs.jsonp = args.callbackParamName || args.jsonp;
			if(ioArgs.jsonp){
				//Add the jsonp parameter.
				ioArgs.query = ioArgs.query || "";
				if(ioArgs.query.length > 0){
					ioArgs.query += "&";
				}
				ioArgs.query += ioArgs.jsonp
					+ "="
					+ (args.frameDoc ? "parent." : "")
					+ dojo._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";

				ioArgs.frameDoc = args.frameDoc;

				//Setup the Deferred to have the jsonp callback.
				ioArgs.canDelete = true;
				dfd._jsonpCallback = this._jsonpCallback;
				this["jsonp_" + ioArgs.id] = dfd;
			}
			return dfd; // dojo.Deferred
		},

		_deferredCancel: function(/*Deferred*/dfd){
			//summary: canceller function for dojo._ioSetArgs call.

			//DO NOT use "this" and expect it to be dojo.io.script.
			dfd.canceled = true;
			if(dfd.ioArgs.canDelete){
				dojo.io.script._addDeadScript(dfd.ioArgs);
			}
		},

		_deferredOk: function(/*Deferred*/dfd){
			//summary: okHandler function for dojo._ioSetArgs call.

			//DO NOT use "this" and expect it to be dojo.io.script.
			var ioArgs = dfd.ioArgs;

			//Add script to list of things that can be removed.
			if(ioArgs.canDelete){
				dojo.io.script._addDeadScript(ioArgs);
			}

			//Favor JSONP responses, script load events then lastly ioArgs.
			//The ioArgs are goofy, but cannot return the dfd since that stops
			//the callback chain in Deferred. The return value is not that important
			//in that case, probably a checkString case.
			return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
		},

		_deferredError: function(/*Error*/error, /*Deferred*/dfd){
			//summary: errHandler function for dojo._ioSetArgs call.

			if(dfd.ioArgs.canDelete){
				//DO NOT use "this" and expect it to be dojo.io.script.
				if(error.dojoType == "timeout"){
					//For timeouts, remove the script element immediately to
					//avoid a response from it coming back later and causing trouble.
					dojo.io.script.remove(dfd.ioArgs.id, dfd.ioArgs.frameDoc);
				}else{
					dojo.io.script._addDeadScript(dfd.ioArgs);
				}
			}
			console.log("dojo.io.script error", error);
			return error;
		},

		_deadScripts: [],
		_counter: 1,

		_addDeadScript: function(/*Object*/ioArgs){
			//summary: sets up an entry in the deadScripts array.
			dojo.io.script._deadScripts.push({id: ioArgs.id, frameDoc: ioArgs.frameDoc});
			//Being extra paranoid about leaks:
			ioArgs.frameDoc = null;
		},

		_validCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if dfd is still valid.

			//Do script cleanup here. We wait for one inflight pass
			//to make sure we don't get any weird things by trying to remove a script
			//tag that is part of the call chain (IE 6 has been known to
			//crash in that case).
			var _self = dojo.io.script;
			var deadScripts = _self._deadScripts;
			if(deadScripts && deadScripts.length > 0){
				for(var i = 0; i < deadScripts.length; i++){
					//Remove the script tag
					_self.remove(deadScripts[i].id, deadScripts[i].frameDoc);
					deadScripts[i].frameDoc = null;
				}
				dojo.io.script._deadScripts = [];
			}

			return true;
		},

		_ioCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if IO finished.
			var ioArgs = dfd.ioArgs;
			//Check for finished jsonp
			if(ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)){
				return true;
			}

			//Check for finished "checkString" case.
			var checkString = ioArgs.args.checkString;
			return checkString && eval("typeof(" + checkString + ") != 'undefined'");


		},

		_resHandle: function(/*Deferred*/dfd){
			//summary: inflight function to handle a completed response.
			if(dojo.io.script._ioCheck(dfd)){
				dfd.callback(dfd);
			}else{
				//This path should never happen since the only way we can get
				//to _resHandle is if _ioCheck is true.
				dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
			}
		},

		_canAttach: function(/*Object*/ioArgs){
			//summary: A method that can be overridden by other modules
			//to control when the script attachment occurs.
			return true;
		},

		_jsonpCallback: function(/*JSON Object*/json){
			//summary:
			//		generic handler for jsonp callback. A pointer to this function
			//		is used for all jsonp callbacks.  NOTE: the "this" in this
			//		function will be the Deferred object that represents the script
			//		request.
			this.ioArgs.json = json;
		}
	};

	return dojo.io.script;
});

},
'url:curam/app/templates/ExternalApplication.html':"<div class=\"app-container\">\r\n  <div class=\"app-container-bc\" \r\n    data-dojo-type=\"dijit/layout/BorderContainer\"\r\n    data-dojo-props=\"gutters:false\"\r\n    data-dojo-attach-point=\"_borderContainer\">\r\n    <div class=\"app-banner\"\r\n      data-dojo-type=\"dojox/layout/ContentPane\"\r\n      data-dojo-props=\"region: 'top'\"\r\n      data-dojo-attach-point=\"_appBanner\">\r\n    </div>\r\n    <div id=\"app-nav\"\r\n      data-dojo-type=\"curam/widget/menu/MenuPane\"\r\n      data-dojo-props=\"region: 'leading', startExpanded: false\"\r\n      data-dojo-attach-point=\"_appNav\"\r\n      class=\"leftNavMenu\">\r\n    </div>\r\n\t\t<div id=\"app-content\"\r\n\t\t\tdata-dojo-type=\"curam/widget/containers/TransitionContainer\"\r\n\t\t\tdata-dojo-attach-point=\"_appContentBody\" class=\"mainBody\"\r\n\t\t\tdata-dojo-props='region:\"center\", style : {padding : 0, border : 0}'>\r\n\t\t</div>\r\n  </div>\r\n</div>",
'dojo/string':function(){
define("dojo/string", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/string
	// summary:
	//		TODOC

lang.getObject("string", true, dojo);

/*=====
dojo.string = {
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	// summary:
	//		Trims whitespace from both sides of the string
	// str: String
	//		String to be trimmed
	// returns: String
	//		Returns the trimmed string
	// description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

return dojo.string;
});

},
'idx/oneui/form/_CompositeMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/form/_CompositeMixin", [
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom",
	"dojo/i18n", 
	"dojo/query", 
	"dojo/dom-class", 
	"dojo/dom-style", 
	"dijit/_base/wai", 
	"../HoverHelpTooltip",
	"../common",
	"./_FocusManager"
], function(declare, lang, domAttr, dom, i18n, query, domClass, domStyle, wai, HoverHelpTooltip, common, _focusManager) {
	/**
	 * @public
	 * @name idx.oneui.form._CompositeMixin
	 * @class Mix-in class to provide customized label, hint, unit, and field layout, implemented according to 
	 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y29&vsub=*&hsub=*&openpanes=0000010000">Text Areas & Fields</a></b>.
	 * It takes the assumption that a composite widget will follow the dom structure below
	 * <br>
	 &lt;div class="idxComposite"&gt;
		&lt;div class="idxLabel"&gt;
			&lt;span&gt;*&lt;/span&gt;
				&lt;label dojotAttachPoint="compLabelNode"&gt;Label Text&lt;/label&gt;
		&lt;/div&gt;
		&lt;div&gt;other dom structure...&lt;/div&gt;&lt;div dojoAttachPoint="compUnitNode"&gt;unit text&lt;/div&gt;
		&lt;div dojoAttachPoint="compHintNode" class="idxHint dijitHidden"&gt;hint text&lt;/div&gt;
	 &lt;/div>
	 * <br>
	 * @aguments idx.oneui.form._FocusManager
	 */

	lang.extend(HoverHelpTooltip._MasterHoverHelpTooltip, {hoverFocus: false});

	return declare("idx.oneui.form._CompositeMixin", null, 
	/**@lends idx.oneui.form._CompositeMixin#*/
	{
		/**
		 * Layout of the label and the field, "horizontal" or "vertical", implemented according to 
		 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y16&vsub=*&hsub=*&openpanes=0000011100">Field & Label Alignment</a></b>
		 * @type String
		 * @default "horizontal"
		 */
		labelAlignment: "horizontal",
		
		/**
		 * Label text
		 * @type String
		 */
		label: "",
		
		/**
		 * Width from the left of label to the left of corresponding field, this parameter works in the composite widget layout of "horizontal".
		 * @type String | Number
		 */
		labelWidth: "",
		
		/**
		 * Width of the field with a hidden validation icon
		 * @type String | Number
		 */
		fieldWidth: "",
		
		/**
		 * For input widgets only. The position of the hint text: "inside" / "outside", inner the field input or not.
		 * @type String
		 * @default "inside"
		 */
		hintPosition: "inside",
		
		/**
		 * For input widgets only. The hint text.
		 * @type String
		 */
		hint: "",
		
		/**
		 * Indicates that it's a required field or not. A required field will have a red asterisk.
		 * implemented according to 
	 	 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y17&vsub=*&hsub=*&openpanes=0000011100">Required Fields</a></b>.
		 * @type boolean
		 * @default false
		 */
		required: false,
		
		/**
		 * The text of unit for the numerical value input widget.
		 * @type String
		 */
		unit: "",
		
		/**
		 * Focus manager for all composite widget
		 * @type idx.oneui.form.FocusManager
		 * @private
		 */
		_focusManager: _focusManager,
		
		/**
		 * Set the alignment for the label and field,  update the style of the label node to make 
		 * it be at the right place.
		 * @public
		 * @param {string} alignment
		 * The alignment of the label and field. Can be "vertical" or "horizontal".
		 * If "vertical" is used, the label is put above the TextBox.
		 * If "horizontal" is used, the label is put on the left of the TextBox (on
		 * the right of the TextBox if RTL language is used).
		 */
		_setLabelAlignmentAttr: function(/*String*/ alignment){
			var h = alignment == "horizontal";
			query(".idxLabel", this.domNode).toggleClass("dijitInline", h);
			query(".idxCompContainer", this.domNode).toggleClass("dijitInline", h);
			this._set("labelAlignment", alignment);
		},
		
		/**
		 * Set the label text. Update the content of the label node.
		 * @public
		 * @param {string} label
		 * The text will be displayed as the content of the label. If text is null or
		 * empty string, nothing would be displayed.
		 */
		_setLabelAttr: function(/*String*/ label){
			this.compLabelNode.innerHTML = label;
			query(".idxLabel", this.domNode).toggleClass("dijitHidden", /^\s*$/.test(label));
			this._set("label", label);
		},
		
		/**
		 * Set this field as a required field or not. If this field is required,
		 * a red asterisk will be shown at the start of label.
		 * @public
		 * @param {boolean} required
		 */
		_setRequiredAttr: function(/*Boolean*/ required){
			wai.setWaiState(this.focusNode, "required", required + "");
			this._set("required", required);
			if(required){
				this._set("state", "Incomplete");
			}
		},
		
		/**
		 * Set position of the hint text. If position is "outside", update the content
		 * of the hint node. If position is "inside" and the value of the TextBox is
		 * null, set the value of the TextBox to the hintText
		 * @protected
		 * @param {string} position
		 * The position of the label. Can be "outside" or "inside".
		 * If "outside" is used, the hint text is put below the TextBox.
		 * If "inside" is used and the TextBox has a value, display the value in the TextBox. Once
		 * the value of the TextBox is null, display the hint text inside the TextBox in a specified
		 * color (e.g: gray).
		 */
		_setHintPositionAttr: function(/*String*/ position){
			if(!this.compHintNode){ return; }
			domClass.toggle(this.compHintNode, "dijitVisible", position != "inside");
			this._set("hintPosition", position);
			this.set("hint", this.hint);
		},
		
		/**
		 * Set the hint text
		 * @public
		 * @param {string} hint
		 * The text will be displayed inside or below the TextBox per the "position" attribute.
		 */
		_setHintAttr: function(/*String*/ hint){
			if(!this.compHintNode){ return; }
			this.set("placeHolder", this.hintPosition == "inside" ? hint : "");
			this.compHintNode.innerHTML = this.hintPosition == "inside" ? "" : hint;
			
			if(this.hintPosition == "outside"){
				domAttr.set(this.compHintNode, "id", this.id + "_hint_outside");
			}
			dijit.setWaiState(this.focusNode, "describedby", this.id + "_hint_" + this.hintPosition);
			this._set("hint", hint);
		},
		
		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = dojo.create('span',{
					className:'dijitPlaceHolder dijitInputField',
					id: this.id + "_hint_inside"
				},this.focusNode,'after');
			}
			this._phspan.innerHTML = "";
			this._phspan.appendChild(document.createTextNode(v));
			this._phspan.style.display=(this.placeHolder&&!this.focused&&!this.textbox.value)?"":"none";
		},
		
		/**
		 * Set the text of unit
		 * @public
		 * @param {string} unit
		 * The unit will be displayed on the right of the input box(on the left of the input
		 * box if RTL language is used).
		 */
		_setUnitAttr: function(/*String*/ unit){
			if(!this.compUnitNode){ return; }
			this.compUnitNode.innerHTML = unit;
			domClass.toggle(this.compUnitNode, "dijitHidden", /^\s*$/.test(unit));
			this._set("unit", unit);
		},
		
		/**
		 * Set the width of label, the width is from the start of label to the start of the field.
		 * @public
		 * @param {string | number} width 
		 * Unit of "pt","em","px" will be normalized to "px", and "px" by default for numeral value.
		 */
		_setLabelWidthAttr: function(/*String | Integer*/width){
			if(!width){ return; }
			var widthInPx = common.normalizedLength(width);
			query(".idxLabel", this.domNode).style("width", widthInPx + "px");
		},
		
		/**
		 * Set the width of field with a hidden validation icon.
		 * @public
		 * @param {string | number} width 
		 * Unit of "pt","em","px" will be normalized to "px", and "px" by default for numeral value.
		 */
		_setFieldWidthAttr: function(/*String | Integer*/width){
			if(!width){ return; }
			var widthInPx = common.normalizedLength(width);
			domStyle.set(this.oneuiBaseNode, "width", widthInPx + "px");
		},
		
		_isValidFocusNode: function(mousedownNode){
			return dom.isDescendant(mousedownNode, this.oneuiBaseNode) ||
				!dom.isDescendant(mousedownNode, this.domNode);
		},
		
		/**
		 * Reset the value and state of the composite widget.
		 * @public
		 */
		reset: function(){
			this.set("state", "");
			this.message = "";
			this.inherited(arguments);
		}
	});
});

},
'dijit/_Contained':function(){
define("dijit/_Contained", [
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained
	// summary:
	//		Mixin for widgets that are children of a container widget

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		//
		// example:
		// | 	// make a basic custom widget that knows about it's parents
		// |	declare("my.customClass",[dijit._Widget,dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//      Returns next or previous sibling
			// which:
			//      Either "next" or "previous"
			// tags:
			//      private
			var node = this.domNode;
			do{
				node = node[which+"Sibling"];
			}while(node && node.nodeType != 1);
			return node && registry.byNode(node);	// dijit._Widget
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit._Widget
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit._Widget
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit._Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'curam/util/UIMFragment':function(){
/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/UIMFragment", ['curam/util/Request',
        "curam/define",
        "curam/debug",
        "curam/util/ScreenContext"],
       function(curamRequest) {
  /*
   * Modification History
   * --------------------
   * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
   * 23-Aug-2012  KW  [CR00339169] Initial Version
   */
  /**
   * @name curam.util.UIMFragment
   * @namespace Allows interaction with fragment UIMs.
   *
   * A "fragment UIM" is a special type of UIM which generates a HTML fragment
   * rather than a full page. It is defined by setting the UIM PAGE element's
   * COMPONENT_TYPE attribute to "PAGE_FRAGMENT". The UIM will then contain a
   * single FIELD which is mapped to a renderer. The output of this renderer will
   * be returned when the UIM is requested. No other HTML (e.g. html, head, body
   * elements) will be returned.
   * 
   * This API provides methods to interact with these types of UIMs.
   * 
   */
  
  curam.define.singleton("curam.util.UIMFragment", {

    /** 
     * Requests a fragment UIM.
     * 
     * @param (Object) args An object containing the following properties:
     * <ul>
     *   <li>pageID : The UIM page id. This is mandatory.</li>
     *   <li>params : A Object with name-value pairs specifying request
     *   parameters. This method will URL encode the parameter values before
     *   making the request. This is optional.</li>
     *   <li>contentPaneID : The ID of the dijit.layout.ContentPane to load the
     *   HTML fragment into. This is mandatory.</li>
     *   <li>onDownloadEnd : The function which will be invoked when the
     *   ContentPane is loaded. This is optional.</li>
     *   <li>onDownloadEnd : The function which will be invoked if there was an
     *   error retrieving the HTML fragment. This is optional.</li>  
     * </ul>
     */
    get: function(args) {

      var pageID = args && args.pageID;
      var url = args && args.url;
      var params = args && args.params;
      var onLoad = args && args.onLoad;
      var onDownloadError = args && args.onDownloadError;

      var targetID = args && args.targetID;


      if (targetID === "" || typeof targetID === "undefined") {
        throw "UIMFragment: targetID must be set.";
      }

      var requestPath = null;
      if (url) {
        //var locale = "en";
        //var topWindow = window.top;
        //if (topWindow.curam && topWindow.curam.config
        //    && topWindow.curam.config.locale) {
        //  locale = topWindow.curam.config.locale;
        //}
        requestPath = url;
      } else {
        // The "_addCDEJParameters()" method adds the "?" to the query string, and
        // the "_encodeParameters()" method assumes this. So, do not change the
        // order of the methods here.
        requestPath = curam.util.UIMFragment._constructPath(pageID)
                          + curam.util.UIMFragment._addCDEJParameters()
                          + curam.util.UIMFragment._encodeParameters(params);
      }
      curam.debug.log("UIMFragment: GET to " + requestPath);

      curam.util.UIMFragment._doService(requestPath, targetID, args,
                                  onLoad, onDownloadError);
    },
    
    /**
     * 
     * @param args
     */
    submitForm: function(onSubmitEvent) {
      var onSubmitEvent = dojo.fixEvent(onSubmitEvent);
      var theForm = onSubmitEvent.target;
      dojo.stopEvent(onSubmitEvent);
      
      // TODO: prevent multiple submits.....
      // if this form has already been submitted just return so the xhrPost
      // below isn't executed multiple times.
      //if (theForm._isSubmitted) {
      //  return false;
      //}
      // Set a flag to indicate this form has been submitted.
      //theForm._isSubmitted = true;
      
      var xhrPostArgs = {
          url: curam.util.UIMFragment._constructFormActionPath(theForm),
          form: theForm,
          load: function(data) 
            { 
              var cp = dijit.getEnclosingWidget(theForm);
              cp.set("content", data);
            },
          error: function(error){alert('form error: error!!')}
        };
        
      curamRequest.post(xhrPostArgs);
      
      console.log(onSubmitEvent + " " + theForm);
    },
    
    _constructFormActionPath: function(theForm) {
      var prefix = "";
      if (window === window.top) {
        // top level window so prefix locale:
        prefix = curam.config.locale + "/";
      }
      return prefix + theForm.getAttribute("action"); 
    },
    
    /**
     * 
     * @param pageID The UIM Page ID.
     */
    _initForm: function(contentPaneID) {
      var theForm = dojo.query("form", dijit.byId(contentPaneID).domNode)[0];
      if (theForm) {
        dojo.connect(theForm, "onsubmit", curam.util.UIMFragment.submitForm);
      }
    },

    /**
     * Construct the Url Path. If the function is called from the top most
     * window, we need to prefix the locale to the pathname.
     * 
     * @param {String} pageID The UIM page ID.
     * @Returns {String} Pathname used to create ajax request.
     */
    _constructPath: function(pageID) {
      var currentWindow = window;
      var topWindow = window.top;
      return curam.util.UIMFragment._constructPathValue(
          pageID, currentWindow, topWindow);
    },

    _constructPathValue: function(pageID, currentWindow, topWindow) {
      if (pageID === "" || typeof pageID === "undefined") {
        throw "UIMFragment: pageID must be set.";
      }
      var pathPrefix = "";
      // TODO: can we just use currentWindow === topWindow ?
      if (currentWindow.location.pathname === topWindow.location.pathname) {
        // it's the "top level" window so we need to add the locale to the Path.
        var locale = topWindow.curam && topWindow.curam.config
                                                && topWindow.curam.config.locale;
        // should always be set, but have included default case just to be safe.
        pathPrefix = (locale || "en") + "/";
      }
      return pathPrefix + pageID + "Page.do";
    },

    /** 
     * Encode the parameters and appended them to the request Path.
     * 
     * @param {Object} params
     *        Parameters to append to path,
     *        expected format: { name:"value", ... }.
     * @Returns {String}
     *        Encoded request parameters prefixed with question mark.
     */
    _encodeParameters: function(params) {

      if (typeof params === "undefined" || dojo.toJson(params) === "{}") {
        curam.debug.log("UIMFragment: No params included in request.");
        return "";
      }
   
      var result = [];
      for (var paramName in params) {
        result.push(paramName + "=" + encodeURIComponent(params[paramName]));
      }
      // This method assumes that _addCDEJParameters() as been called which
      // guarantees that a parameter has been already added. Therefore, this
      // string starts with an "&". 
      return "&" + result.join("&");
    },
    
    /**
     * Adds CDEJ parameters to the request string. This function assumes it is
     * called directly after _constructPath() so it always starts with a "?".
     * The screen context parameter is the only one required for "fragment"
     * requests.
     */
    _addCDEJParameters: function() {
      return "?" + jsScreenContext.toRequestString();
    },

    /**
     * Creates a Ajax post request using the dojo api. Any parameters to be sent
     * with the request are included as per a normal get|post request.
     *
     * @param {String} method
     *        The method of the request, either "GET" or "POST".
     * @param {String} path
     *        The path to invoke on the web-tier.
     * @param {Object} params
     *        The parameters to be included with the post.
     * @param {Function} onDownloadEnd
     *        The function to invoke for handling the returned data.
     * @param {Function} onDownloadError
     *        The function to invoke on failure of resolving the path.
     * @param {String} targetID
     *        Dictates what format the response will be in, e.g. Text or JSON.
     */
    _doService: function(url, targetID, args, onLoad, onDownloadError) {

      var cp = dijit.byId(targetID);
      
      //cp.onDownloadError = dojo.hitch(
      //    this, curam.util.UIMFragment._handleDownloadError, onDownloadError);
      
      //cp.onDownloadEnd = dojo.hitch(
      //    cp, curam.util.UIMFragment._handleDownloadSuccess, args, onDownloadEnd);

      // onLoad is called after either setHref or setContent.....
      cp.onLoad = dojo.hitch(
          cp, curam.util.UIMFragment._handleLoadSuccess, args, onLoad);
      
      // Set defaults if not defined
      //if (typeof onDownloadError === "undefined") {
        //onDownloadError = dojo.hitch(this, this._handleDownloadError);
        //cp.set("onDownloadError", this._handleDownloadError);
        //cp.onDownloadError = curam.util.UIMFragment._handleDownloadError;
      //} else {
        //cp.set("onDownloadError", onDownloadError);
        //cp.onDownloadError = onDownloadError;
      //}
      
      //if (typeof onDownloadEnd === "undefined" || onDownloadEnd == null) {
        //onDownloadEnd = dojo.hitch(this, this._handleDownloadSuccess);
        //cp.set("onDownloadEnd ", this._handleDownloadSuccess);
        //cp.onDownloadEnd = curam.util.UIMFragment._handleDownloadSuccess;
      //} else {
        //cp.onDownloadEnd = onDownloadEnd;
      //}
      
      cp.preventCache = true;
      cp.set("href", url);
    },


    /**
     * Generic handler for when the UIMFragment fails.
     *
     * @param {Object} error
     *        Containing all information on the error
     * @param {Object} ioargs
     *        Contains all arguments passed to the web tier in the call, for
     *        debugging purposes.
     */
    _handleDownloadError: function(error) {
      curam.debug.log("Error invoking the UIMFragment: " + error);  
      return "UIMFragment: Generic Error Handler";
    },

    /**
     * When content is loaded into a ContentPane by this class, a number of 
     * actions have to take place:
     * 1. Search the HTML fragment for a form and setup event handlers
     * 2. Invoke the developer specified callback if specified.  
     * 
     * This method will always be called in the scope of the ContentPane that has
     * just been loaded i.e. The "this" keyword will point to a ContentPane.
     *  
     * @param {Object} fragmentArgs The original arguments to the
     * "UIMFragment.get" call.
     * @param {Function} customCallback The developers specified call back.
     */
    _handleLoadSuccess: function(fragmentArgs, customCallback) {
      
      curam.util.UIMFragment._initForm(fragmentArgs.targetID);
      if (customCallback) {
        customCallback(this);
      }
      curam.debug.log("");  
      return "UIMFragment: Generic Success Handler";
    }
  });
  
  return curam.util.UIMFragment;
  
});
},
'curam/util/ui/AppExitConditionHandler':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 06-Jun-2013  MV  [CR00384697] Add parameter and return value checks.
 * 03-Apr-2013  MV  [] Initial version.
 */

/**
 * @name curam.util.ui.AppExitConditionHandler
 * @namespace Wraps a function for custom conditions for displaying page exit
 *       confirmation.
 * 
 */
define("curam/util/ui/AppExitConditionHandler", [
        ], function() {
  
  var AppExitConditionHandler = dojo.declare(
      "curam.util.ui.AppExitConditionHandler", null,
      /** @lends curam.util.ui.AppExitConditionHandler.prototype */ {
        
    _handler: null,

    /**
     * Constructor.
     * 
     * @param handlerFunctionReturningBoolean A function that will be evaluated
     *        to test if we should display page navigation confirmation dialog.
     */
    constructor: function(handlerFunctionReturningBoolean) {
      if (typeof handlerFunctionReturningBoolean != "function") {
        throw new Error("Illegal argument: " + handlerFunctionReturningBoolean);
      }
      this._handler = handlerFunctionReturningBoolean;
    },
    
    /**
     * Determine if confirmation dialog should be allowed.
     *
     * @returns True if confirmation is allowed, false otherwise. 
     */
    isConfirmationAllowed: function() {
      // convert to pure boolean for extra contract safety
      return this._handler() ? true : false;
    }
  });
  
  return AppExitConditionHandler;
});

},
'cwtk/eligibilityresults/CategoryAction':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("cwtk/eligibilityresults/CategoryAction", [
    "dojo", 
    "dojo/_base/declare", 
    "dijit/Dialog"
], function(dojo, declare, Dialog){

		return declare("cwtk.eligibilityresults.CategoryAction", null, {
		
        execute : function(args) {
            
            this.action(args.url, args.title, args.motivationID, args.categoryID);
        
        },
        
        action: function(url, title, motivationID, categoryID) {
        
            cw.popup.show({title: title});
            cw.fragment.load(cw.popup.dialog().id, url, {motivationID:motivationID, categoryID:categoryID});
            cw.form.clearUpdateListeners();
            cw.form.addUpdateListener(function(){
                cw.ajax.updateContent('cw-eligibility-results-context-bar')
            });
            cw.form.addUpdateListener(function(){
                cw.ajax.updateContent('cw-eligibility-results-actions-'+ categoryID)
            });                                         
        }
		          
		});

});




},
'dojox/storage/manager':function(){
// wrapped by build app
define("dojox/storage/manager", ["dijit","dojo","dojox"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.manager");
//dojo.require("dojo.AdapterRegistry");
// FIXME: refactor this to use an AdapterRegistry

dojox.storage.manager = new function(){
	// summary: A singleton class in charge of the dojox.storage system
	// description:
	//		Initializes the storage systems and figures out the best available
	//		storage options on this platform.

	// currentProvider: Object
	//	The storage provider that was automagically chosen to do storage
	//	on this platform, such as dojox.storage.FlashStorageProvider.
	this.currentProvider = null;

	// available: Boolean
	//	Whether storage of some kind is available.
	this.available = false;

  // providers: Array
  //  Array of all the static provider instances, useful if you want to
  //  loop through and see what providers have been registered.
  this.providers = [];

	this._initialized = false;

	this._onLoadListeners = [];

	this.initialize = function(){
		// summary:
		//		Initializes the storage system and autodetects the best storage
		//		provider we can provide on this platform
		this.autodetect();
	};

	this.register = function(/*string*/ name, /*Object*/ instance){
		// summary:
		//		Registers the existence of a new storage provider; used by
		//		subclasses to inform the manager of their existence. The
		//		storage manager will select storage providers based on
		//		their ordering, so the order in which you call this method
		//		matters.
		// name:
		//		The full class name of this provider, such as
		//		"dojox.storage.FlashStorageProvider".
		// instance:
		//		An instance of this provider, which we will use to call
		//		isAvailable() on.

		// keep list of providers as a list so that we can know what order
		// storage providers are preferred; also, store the providers hashed
		// by name in case someone wants to get a provider that uses
		// a particular storage backend
		this.providers.push(instance);
		this.providers[name] = instance;
	};

	this.setProvider = function(storageClass){
		// summary:
		//		Instructs the storageManager to use the given storage class for
		//		all storage requests.
		// description:
		//		Example-
		//			dojox.storage.setProvider(
		//				dojox.storage.IEStorageProvider)

	};

	this.autodetect = function(){
		// summary:
		//		Autodetects the best possible persistent storage provider
		//		available on this platform.

		//console.debug("dojox.storage.manager.autodetect");

		if(this._initialized){ // already finished
			return;
		}

		// a flag to force the storage manager to use a particular
		// storage provider type, such as
		// djConfig = {forceStorageProvider: "dojox.storage.WhatWGStorageProvider"};
		var forceProvider = dojo.config["forceStorageProvider"] || false;

		// go through each provider, seeing if it can be used
		var providerToUse;
		//FIXME: use dojo.some
		for(var i = 0; i < this.providers.length; i++){
			providerToUse = this.providers[i];
			if(forceProvider && forceProvider == providerToUse.declaredClass){
				// still call isAvailable for this provider, since this helps some
				// providers internally figure out if they are available
				// FIXME: This should be refactored since it is non-intuitive
				// that isAvailable() would initialize some state
				providerToUse.isAvailable();
				break;
			}else if(!forceProvider && providerToUse.isAvailable()){
				break;
			}
		}

		if(!providerToUse){ // no provider available
			this._initialized = true;
			this.available = false;
			this.currentProvider = null;
			console.warn("No storage provider found for this platform");
			this.loaded();
			return;
		}

		// create this provider and mix in it's properties
		// so that developers can do dojox.storage.put rather
		// than dojox.storage.currentProvider.put, for example
		this.currentProvider = providerToUse;
		dojo.mixin(dojox.storage, this.currentProvider);

		// have the provider initialize itself
		dojox.storage.initialize();

		this._initialized = true;
		this.available = true;
	};

	this.isAvailable = function(){ /*Boolean*/
		// summary: Returns whether any storage options are available.
		return this.available;
	};

	this.addOnLoad = function(func){ /* void */
		// summary:
		//		Adds an onload listener to know when Dojo Offline can be used.
		// description:
		//		Adds a listener to know when Dojo Offline can be used. This
		//		ensures that the Dojo Offline framework is loaded and that the
		//		local dojox.storage system is ready to be used. This method is
		//		useful if you don't want to have a dependency on Dojo Events
		//		when using dojox.storage.
		// func: Function
		//		A function to call when Dojo Offline is ready to go
		this._onLoadListeners.push(func);

		if(this.isInitialized()){
			this._fireLoaded();
		}
	};

	this.removeOnLoad = function(func){ /* void */
		// summary: Removes the given onLoad listener
		for(var i = 0; i < this._onLoadListeners.length; i++){
			if(func == this._onLoadListeners[i]){
				this._onLoadListeners.splice(i, 1);
				break;
			}
		}
	};

	this.isInitialized = function(){ /*Boolean*/
	 	// summary:
		//		Returns whether the storage system is initialized and ready to
		//		be used.

		// FIXME: This should REALLY not be in here, but it fixes a tricky
		// Flash timing bug.
		// Confirm that this is still needed with the newly refactored Dojo
		// Flash. Used to be for Internet Explorer. -- Brad Neuberg
		if(this.currentProvider != null
			&& this.currentProvider.declaredClass == "dojox.storage.FlashStorageProvider"
			&& dojox.flash.ready == false){
			return false;
		}else{
			return this._initialized;
		}
	};

	this.supportsProvider = function(/*string*/ storageClass){ /* Boolean */
		// summary: Determines if this platform supports the given storage provider.
		// description:
		//		Example-
		//			dojox.storage.manager.supportsProvider(
		//				"dojox.storage.InternetExplorerStorageProvider");

		// construct this class dynamically
		try{
			// dynamically call the given providers class level isAvailable()
			// method
			var provider = eval("new " + storageClass + "()");
			var results = provider.isAvailable();
			if(!results){ return false; }
			return results;
		}catch(e){
			return false;
		}
	};

	this.getProvider = function(){ /* Object */
		// summary: Gets the current provider
		return this.currentProvider;
	};

	this.loaded = function(){
		// summary:
		//		The storage provider should call this method when it is loaded
		//		and ready to be used. Clients who will use the provider will
		//		connect to this method to know when they can use the storage
		//		system. You can either use dojo.connect to connect to this
		//		function, or can use dojox.storage.manager.addOnLoad() to add
		//		a listener that does not depend on the dojo.event package.
		// description:
		//		Example 1-
		//			if(dojox.storage.manager.isInitialized() == false){
		//				dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
		//			}else{
		//				dojo.connect(dojo, "loaded", TestStorage, "initialize");
		//			}
		//		Example 2-
		//			dojox.storage.manager.addOnLoad(someFunction);


		// FIXME: we should just provide a Deferred for this. That way you
		// don't care when this happens or has happened. Deferreds are in Base
		this._fireLoaded();
	};

	this._fireLoaded = function(){
		//console.debug("dojox.storage.manager._fireLoaded");

		dojo.forEach(this._onLoadListeners, function(i){
			try{
				i();
			}catch(e){ console.debug(e); }
		});
	};

	this.getResourceList = function(){
		// summary:
		//		Returns a list of whatever resources are necessary for storage
		//		providers to work.
		// description:
		//		This will return all files needed by all storage providers for
		//		this particular environment type. For example, if we are in the
		//		browser environment, then this will return the hidden SWF files
		//		needed by the FlashStorageProvider, even if we don't need them
		//		for the particular browser we are working within. This is meant
		//		to faciliate Dojo Offline, which must retrieve all resources we
		//		need offline into the offline cache -- we retrieve everything
		//		needed, in case another browser that requires different storage
		//		mechanisms hits the local offline cache. For example, if we
		//		were to sync against Dojo Offline on Firefox 2, then we would
		//		not grab the FlashStorageProvider resources needed for Safari.
		var results = [];
		dojo.forEach(dojox.storage.manager.providers, function(currentProvider){
			results = results.concat(currentProvider.getResourceList());
		});

		return results;
	}
};

});

},
'dijit/_Container':function(){
define("dijit/_Container", [
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"./registry"	// registry.byNode()
], function(array, declare, domConstruct, registry){

	// module:
	//		dijit/_Container
	// summary:
	//		Mixin for widgets that contain a set of widget children.

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 			this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !registry.byNode(node)));
			return node && registry.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'dijit/layout/BorderContainer':function(){
define("dijit/layout/BorderContainer", [
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/event", // event.stop
	"dojo/keys",
	"dojo/_base/lang", // lang.getObject lang.hitch
	"dojo/on",
	"dojo/touch",
	"dojo/_base/window", // win.body win.doc win.doc.createElement
	"../_WidgetBase",
	"../_Widget",
	"../_TemplatedMixin",
	"./_LayoutWidget",
	"./utils"		// layoutUtils.layoutChildren
], function(array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, event, keys, lang, on, touch, win,
			_WidgetBase, _Widget, _TemplatedMixin, _LayoutWidget, layoutUtils){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _LayoutWidget = dijit.layout._LayoutWidget;
=====*/

// module:
//		dijit/layout/BorderContainer
// summary:
//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.

var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: [const] String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" data-dojo-attach-event="onkeypress:_onKeyPress,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

	constructor: function(){
		this._handlers = [];
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		this.horizontal = /top|bottom/.test(this.region);
		this._factor = /top|left/.test(this.region) ? 1 : -1;
		this._cookieName = this.container.id + "_" + this.region;
	},

	buildRendering: function(){
		this.inherited(arguments);

		domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

		if(this.container.persist){
			// restore old size
			var persistSize = cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		// summary:
		//		Return the maximum size that my corresponding pane can be set to

		var dim = this.horizontal ? 'h' : 'w',
			childSize = domGeometry.getMarginBox(this.child.domNode)[dim],
			center = array.filter(this.container.getChildren(), function(child){ return child.region == "center";})[0],
			spaceAvailable = domGeometry.getMarginBox(center.domNode)[dim];	// can expand until center is crushed to 0

		return Math.min(this.child.maxSize, childSize + spaceAvailable);
	},

	_startDrag: function(e){
		if(!this.cover){
			this.cover = win.doc.createElement('div');
			domClass.add(this.cover, "dijitSplitterCover");
			domConstruct.place(this.cover, this.child.domNode, "after");
		}
		domClass.add(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ domConstruct.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			domClass.add(this.domNode, "dijitSplitterShadow");
			domConstruct.place(this.fake, this.domNode, "after");
		}
		domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
		if(this.fake){
			domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
		}

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = domGeometry.getMarginBox(this.child.domNode)[dim],
			max = this._computeMaxSize(),
			min = this.child.minSize || 20,
			region = this.region,
			splitterAttr = region == "top" || region == "bottom" ? "top" : "left",	// style attribute of splitter to adjust
			splitterStart = parseInt(splitterStyle[splitterAttr], 10),
			resize = this._resize,
			layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id),
			de = win.doc;

		this._handlers = this._handlers.concat([
			on(de, touch.move, this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					layoutFunc(boundChildSize);
				}
				// TODO: setting style directly (usually) sets content box size, need to set margin box size
				splitterStyle[splitterAttr] = delta + splitterStart + factor*(boundChildSize - childSize) + "px";
			}),
			on(de, "dragstart", event.stop),
			on(win.body(), "selectstart", event.stop),
			on(de, touch.release, lang.hitch(this, "_stopDrag"))
		]);
		event.stop(e);
	},

	_onMouse: function(e){
		// summary:
		//		Handler for onmouseenter / onmouseleave events
		var o = (e.type == "mouseover" || e.type == "mouseenter");
		domClass.toggle(this.domNode, "dijitSplitterHover", o);
		domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				domClass.remove(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ domConstruct.destroy(this.fake); }
			domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter"
				+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			delete this._drag;
		}

		if(this.container.persist){
			cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		var h;
		while(h = this._handlers.pop()){ h.remove(); }
	},

	_onKeyPress: function(/*Event*/ e){
		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		switch(e.charOrCode){
			case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = domGeometry.getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
		event.stop(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" role="presentation"></div>',

	postMixInProperties: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
	},

	buildRendering: function(){
		this.inherited(arguments);
		domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

var BorderContainer = declare("dijit.layout.BorderContainer", _LayoutWidget, {
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	//		For complex layouts, multiple children can be specified for a single region.   In this case, the
	//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	//		instead of the design attribute to control layout precedence of horizontal vs. vertical panes.
	// example:
	// |	<div data-dojo-type="dijit.layout.BorderContainer" data-dojo-props="design: 'sidebar', gutters: false"
	// |            style="width: 400px; height: 300px;">
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'top'">header text</div>
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'right', splitter: true" style="width: 200px;">table of contents</div>
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'center'">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: [const] Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: [const] Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: Function||String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: _Splitter,

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }
		array.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			domClass.add(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
				var _Splitter = child.splitter ? this._splitterClass : _Gutter;
				if(lang.isString(_Splitter)){
					_Splitter = lang.getObject(_Splitter);	// for back-compat, remove in 2.0
				}
				var splitter = new _Splitter({
					id: child.id + "_splitter",
					container: this,
					child: child,
					region: region,
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				child._splitterWidget = splitter;

				domConstruct.place(splitter.domNode, child.domNode, "after");

				// Splitters aren't added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;	// TODO: technically wrong since it overwrites "trailing" with "left" etc.
		}
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		this._layoutChildren();
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this.layout(); //OPT
		}
	},

	removeChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget.removeChild().

		var region = child.region;
		var splitter = child._splitterWidget;
		if(splitter){
			splitter.destroy();
			delete child._splitterWidget;
		}
		this.inherited(arguments);

		if(this._started){
			this._layoutChildren();
		}
		// Clean up whatever style changes we made to the child pane.
		// Unclear how height and width should be handled.
		domClass.remove(child.domNode, this.baseClass+"Pane");
		domStyle.set(child.domNode, {
			top: "auto",
			bottom: "auto",
			left: "auto",
			right: "auto",
			position: "static"
		});
		domStyle.set(child.domNode, region == "top" || region == "bottom" ? "width" : "height", "auto");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return array.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	// TODO: remove in 2.0
	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region
		// tags:
		//		deprecated
		return array.filter(this.getChildren(), function(child){
			return child.region == region;
		})[0]._splitterWidget;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if(!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = domStyle.getComputedStyle(node);
			this.pe = domGeometry.getPadExtents(node, this.cs);
			this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
			this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);

			domStyle.set(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
		// summary:
		//		This is the main routine for setting size/position of each child.
		// description:
		//		With no arguments, measures the height of top/bottom panes, the width
		//		of left/right panes, and then sizes all panes accordingly.
		//
		//		With changedRegion specified (as "left", "top", "bottom", or "right"),
		//		it changes that region's width/height to changedRegionSize and
		//		then resizes other regions that were affected.
		// changedChildId:
		//		Id of the child which should be resized because splitter was dragged.
		// changedChildSize:
		//		The new width/height (in pixels) to make specified child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		// Generate list of wrappers of my children in the order that I want layoutChildren()
		// to process them (i.e. from the outside to the inside)
		var wrappers = array.map(this.getChildren(), function(child, idx){
			return {
				pane: child,
				weight: [
					child.region == "center" ? Infinity : 0,
					child.layoutPriority,
					(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
					idx
				]
			};
		}, this);
		wrappers.sort(function(a, b){
			var aw = a.weight, bw = b.weight;
			for(var i=0; i<aw.length; i++){
				if(aw[i] != bw[i]){
					return aw[i] - bw[i];
				}
			}
			return 0;
		});

		// Make new list, combining the externally specified children with splitters and gutters
		var childrenAndSplitters = [];
		array.forEach(wrappers, function(wrapper){
			var pane = wrapper.pane;
			childrenAndSplitters.push(pane);
			if(pane._splitterWidget){
				childrenAndSplitters.push(pane._splitterWidget);
			}
		});

		// Compute the box in which to lay out my children
		var dim = {
			l: this.pe.l,
			t: this.pe.t,
			w: this._borderBox.w - this.pe.w,
			h: this._borderBox.h - this.pe.h
		};

		// Layout the children, possibly changing size due to a splitter drag
		layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters,
			changedChildId, changedChildSize);
	},

	destroyRecursive: function(){
		// Destroy splitters first, while getChildren() still works
		array.forEach(this.getChildren(), function(child){
			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
			}
			delete child._splitterWidget;
		});

		// Then destroy the real children, and myself
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
lang.extend(_WidgetBase, {
	// region: [const] String
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the `dijit.layout.BorderContainer` description for details.
	region: '',

	// layoutPriority: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Children with a higher layoutPriority will be placed closer to the BorderContainer center,
	//		between children with a lower layoutPriority.
	layoutPriority: 0,

	// splitter: [const] Boolean
	//		Parameter for child of `dijit.layout.BorderContainer` where region != "center".
	//		If true, enables user to resize the widget by putting a draggable splitter between
	//		this widget and the region=center widget.
	splitter: false,

	// minSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
	minSize: 0,

	// maxSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
	maxSize: Infinity
});

// For monkey patching
BorderContainer._Splitter = _Splitter;
BorderContainer._Gutter = _Gutter;

return BorderContainer;
});

},
'cwtk/widget/HoverHelpTooltip':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/HoverHelpTooltip", [
    "dojo", 
    "dojo/_base/declare", 
    "idx/oneui/HoverHelpTooltip", 
    "cwtk/widget/_OrientedDropDown" 
], function(dojo, declare, HoverHelpTooltip, _OrientedDropDown){


		return declare("cwtk.widget.HoverHelpTooltip", [HoverHelpTooltip, _OrientedDropDown], {
		
		   handleReset : null,
		   
		   startup : function() {
		       this.inherited(arguments);
		   },
		   
		   _onHover : function() {
		       this.inherited(arguments);
		   },
		   
		   _onUnHover : function() {
		       this.inherited(arguments);
		   },
		   
		   open : function(target) {
		       this.inherited(arguments);
			   
			   this.aroundNode = this._connectNode;
			   this.dropDown = HoverHelpTooltip._masterTT;
			   this.connector = dojo.query('.idxOneuiHoverHelpTooltipConnector', this.dropDown.domNode)[0];
			   this.resetDropDown();
			   
			   var self = this;
		       this.handleReset = dojo.connect(this.dropDown, "_onHide", function(){
		           dojo.disconnect(self.handleReset);
		           self.resetDropDown();
		       });
			   
			   this.fixDropDown();
			   
			   // Fix horizontal alignment of the tooltip. GLS-1748
			   if(!this.isLeftToRight()){
			       var marginLeft = this.dropDown.domNode.style.marginLeft;
			       this.dropDown.domNode.style.marginLeft = this.dropDown.domNode.style.marginRight;
			       this.dropDown.domNode.style.marginRight = "-" + marginLeft;
			    }
		   } 
		});

});
},
'dijit/_base/wai':function(){
define("dijit/_base/wai", [
	"dojo/dom-attr", // domAttr.attr
	"dojo/_base/lang", // lang.mixin
	"..",	// export symbols to dijit
	"../hccss"			// not using this module directly, but loading it sets CSS flag on <html>
], function(domAttr, lang, dijit){

	// module:
	//		dijit/_base/wai
	// summary:
	//		Deprecated methods for setting/getting wai roles and states.
	//		New code should call setAttribute()/getAttribute() directly.
	//
	//		Also loads hccss to apply dijit_a11y class to root node if machine is in high-contrast mode.

	lang.mixin(dijit, {
		hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
			// summary:
			//		Determines if an element has a particular role.
			// returns:
			//		True if elem has the specific role attribute and false if not.
			// 		For backwards compatibility if role parameter not provided,
			// 		returns true if has a role
			var waiRole = this.getWaiRole(elem);
			return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
		},

		getWaiRole: function(/*Element*/ elem){
			// summary:
			//		Gets the role for an element (which should be a wai role).
			// returns:
			//		The role of elem or an empty string if elem
			//		does not have a role.
			 return lang.trim((domAttr.get(elem, "role") || "").replace("wairole:",""));
		},

		setWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Sets the role on an element.
			// description:
			//		Replace existing role attribute with new role.

			domAttr.set(elem, "role", role);
		},

		removeWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Removes the specified role from an element.
			// 		Removes role attribute if no specific role provided (for backwards compat.)

			var roleValue = domAttr.get(elem, "role");
			if(!roleValue){ return; }
			if(role){
				var t = lang.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
				domAttr.set(elem, "role", t);
			}else{
				elem.removeAttribute("role");
			}
		},

		hasWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Determines if an element has a given state.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		true if elem has a value for the given state and
			//		false if it does not.

			return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
		},

		getWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Gets the value of a state on an element.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		The value of the requested state on elem
			//		or an empty string if elem has no value for state.

			return elem.getAttribute("aria-"+state) || "";
		},

		setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
			// summary:
			//		Sets a state on an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.setAttribute("aria-"+state, value);
		},

		removeWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Removes a state from an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.removeAttribute("aria-"+state);
		}
	});

	return dijit;
});

},
'dojo/dnd/Mover':function(){
define("dojo/dnd/Mover", ["../main", "../Evented", "../touch", "./common", "./autoscroll"], function(dojo, Evented, touch) {
	// module:
	//		dojo/dnd/Mover
	// summary:
	//		TODOC


dojo.declare("dojo.dnd.Mover", [Evented], {
	constructor: function(node, e, host){
		// summary:
		//		an object which makes a node follow the mouse, or touch-drag on touch devices.
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;
		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following two
			// connects are disconnected
			dojo.connect(d, touch.move, this, "onFirstMove"),

			// These are called continually during the drag
			dojo.connect(d, touch.move, this, "onMouseMove"),

			// And these are called at the end of the drag
			dojo.connect(d, touch.release,   this, "onMouseUp"),

			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent)
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY}, e);
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}

		// Disconnect onmousemove and ontouchmove events that call this function
		dojo.disconnect(this.events.shift());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

return dojo.dnd.Mover;
});

},
'url:idx/oneui/templates/HoverHelpTooltip.html':"<div class=\"idxOneuiHoverHelpTooltip idxOneuiHoverHelpTooltipLeft\" role=\"dialog\"\r\n\t><div role=\"document\"\r\n\t\t><span data-dojo-attach-point=\"closeButtonNode\" class=\"idxOneuiHoverHelpTooltipCloseIcon\" data-dojo-attach-event=\"ondijitclick: hideOnClickClose\" role=\"button\" tabIndex=\"0\"></span\r\n\t></div\r\n\t><div data-dojo-attach-point=\"outerContainerNode\" class=\"idxOneuiHoverHelpTooltipContainer idxOneuiHoverHelpTooltipContents\"\r\n\t\t><div data-dojo-attach-point=\"containerNode\" role=\"document\" tabindex=0></div\r\n\t\t><a target=\"_blank\" href=\"#updateme\" class=\"idxOneuiHoverHelpTooltipLearnLink\" data-dojo-attach-point=\"learnMoreNode\"><span>${learnMoreLabel}</span></a\r\n\t></div\r\n\t><div class=\"idxOneuiHoverHelpTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\r\n></div>",
'cwtk/util/AjaxHandler':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/util/AjaxHandler", [
    "dojo", 
    "dojo/_base/declare", 
    "dojox", 
    "dojox/xml/parser"
], function(dojo, declare, dojox){

		return declare("cwtk.util.AjaxHandler", null, {

			TIMEOUT: 0,

			call : function(link, parameters, callback) {
				console.log("Starting AJAX call for link " + link);
				var instance = this;
				dojo.xhrPost({
					url: link,
					content: parameters,
					timeout: instance.TIMEOUT,
					handle: function(dataOrError, args) {
							var doc = dojox.xml.parser.parse(dataOrError);
							var isError = dojo.query('error', doc).length > 0;
							if (isError){
								instance.handleError(dojo.query('error', doc)[0], args);
							} else {
								instance.handleData(dojo.query('data', doc)[0], args, callback);
							}
						 }
				});
			},
			
			handleError : function(err, args) {
				var message = "Error: " + dojox.xml.parser.textContent(dojo.query('message', err)[0]);
				console.log(message);
				alert(message);
			},
			
			handleData : function(data, args, callback) {
				if (callback) {
					callback(data, args);
				} else {
					console.log("No callback for data " + data);
				}
			},

			updateContent : function(contentPane, callback) {
			
				var contentPaneId = contentPane;
			    if (contentPane.id) {
			        contentPaneId = contentPane.id;
			    }
			    
				console.log("Updating view for " + contentPaneId);
				contentPane = dijit.registry.byId(contentPaneId);
				
				//destroying possible widgets to free up registry ID's
				dojo.forEach(dijit.findWidgets(contentPane), function(w) {
					console.log("destroying registered widget..." + w);
					w.destroyRecursive(true);
				});
				dojo.forEach(contentPane.getChildren(), function(w) {
					console.log("destroying registered widget..." + w);
					w.destroyRecursive(true);
				});            
					
				// GUM-3783
				// Ensure that preventCache=true on updates
				contentPane.preventCache = true;
				
				//replace loading message with current snapshot (plain html)       
				contentPane.loadingMessage =  contentPane.attr('content');
				contentPane.onDownloadEnd = callback;
				contentPane.onLoad = function() {
					dojo.animateProperty({node: dojo.byId(contentPane.id), 
									properties: {opacity: {start: 0.5, end: 1}}, duration: 1000}).play();
				};
				contentPane.refresh();
			}
		});

});
},
'dijit/form/Select':function(){
require({cache:{
'url:dijit/form/templates/Select.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode\" cellspacing='0' cellpadding='0'\n\trole=\"combobox\" aria-haspopup=\"true\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\" role=\"presentation\"\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  data-dojo-attach-point=\"containerNode,_popupStateNode\"></span\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\n\t\t/></td><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t></tr></tbody\n></table>\n"}});
define("dijit/form/Select", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-geometry", // domGeometry.setMarginBox
	"dojo/_base/event", // event.stop
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch
	"./_FormSelectWidget",
	"../_HasDropDown",
	"../Menu",
	"../MenuItem",
	"../MenuSeparator",
	"../Tooltip",
	"dojo/text!./templates/Select.html",
	"dojo/i18n!./nls/validate"
], function(array, declare, domAttr, domClass, domConstruct, domGeometry, event, i18n, lang,
			_FormSelectWidget, _HasDropDown, Menu, MenuItem, MenuSeparator, Tooltip, template){

/*=====
	var _FormSelectWidget = dijit.form._FormSelectWidget;
	var _HasDropDown = dijit._HasDropDown;
	var _FormSelectWidget = dijit._FormSelectWidget;
	var Menu = dijit.Menu;
	var MenuItem = dijit.MenuItem;
	var MenuSeparator = dijit.MenuSeparator;
	var Tooltip = dijit.Tooltip;
=====*/

// module:
//		dijit/form/Select
// summary:
//		This is a "styleable" select box - it is basically a DropDownButton which
//		can take a <select> as its input.


var _SelectMenu = declare("dijit.form._SelectMenu", Menu, {
	// summary:
	//		An internally-used menu for dropdown that allows us a vertical scrollbar
	buildRendering: function(){
		// summary:
		//		Stub in our own changes, so that our domNode is not a table
		//		otherwise, we won't respond correctly to heights/overflows
		this.inherited(arguments);
		var o = (this.menuTableNode = this.domNode);
		var n = (this.domNode = domConstruct.create("div", {style: {overflowX: "hidden", overflowY: "scroll"}}));
		if(o.parentNode){
			o.parentNode.replaceChild(n, o);
		}
		domClass.remove(o, "dijitMenuTable");
		n.className = o.className + " dijitSelectMenu";
		o.className = "dijitReset dijitMenuTable";
		o.setAttribute("role", "listbox");
		n.setAttribute("role", "presentation");
		n.appendChild(o);
	},

	postCreate: function(){
		// summary:
		//		stop mousemove from selecting text on IE to be consistent with other browsers

		this.inherited(arguments);

		this.connect(this.domNode, "onmousemove", event.stop);
	},

	resize: function(/*Object*/ mb){
		// summary:
		//		Overridden so that we are able to handle resizing our
		//		internal widget.  Note that this is not a "full" resize
		//		implementation - it only works correctly if you pass it a
		//		marginBox.
		//
		// mb: Object
		//		The margin box to set this dropdown to.
		if(mb){
			domGeometry.setMarginBox(this.domNode, mb);
			if("w" in mb){
				// We've explicitly set the wrapper <div>'s width, so set <table> width to match.
				// 100% is safer than a pixel value because there may be a scroll bar with
				// browser/OS specific width.
				this.menuTableNode.style.width = "100%";
			}
		}
	}
});

var Select = declare("dijit.form.Select", [_FormSelectWidget, _HasDropDown], {
	// summary:
	//		This is a "styleable" select box - it is basically a DropDownButton which
	//		can take a <select> as its input.

	baseClass: "dijitSelect",

	templateString: template,

	// required: Boolean
	//		Can be true or false, default is false.
	required: false,

	// state: [readonly] String
	//		"Incomplete" if this select is required but unset (i.e. blank value), "" otherwise
	state: "",

	// message: String
	//		Currently displayed error/prompt message
	message: "",

	//	tooltipPosition: String[]
	//		See description of dijit.Tooltip.defaultPosition for details on this parameter.
	tooltipPosition: [],

	// emptyLabel: string
	//		What to display in an "empty" dropdown
	emptyLabel: "&#160;",	// &nbsp;

	// _isLoaded: Boolean
	//		Whether or not we have been loaded
	_isLoaded: false,

	// _childrenLoaded: Boolean
	//		Whether or not our children have been loaded
	_childrenLoaded: false,

	_fillContent: function(){
		// summary:
		//		Set the value to be the first, or the selected index
		this.inherited(arguments);
		// set value from selected option
		if(this.options.length && !this.value && this.srcNodeRef){
			var si = this.srcNodeRef.selectedIndex || 0; // || 0 needed for when srcNodeRef is not a SELECT
			this.value = this.options[si >= 0 ? si : 0].value;
		}
		// Create the dropDown widget
		this.dropDown = new _SelectMenu({id: this.id + "_menu"});
		domClass.add(this.dropDown.domNode, this.baseClass + "Menu");
	},

	_getMenuItemForOption: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, return the menu item that should be
		//		used to display it.  This can be overridden as needed
		if(!option.value && !option.label){
			// We are a separator (no label set for it)
			return new MenuSeparator();
		}else{
			// Just a regular menu option
			var click = lang.hitch(this, "_setValueAttr", option);
			var item = new MenuItem({
				option: option,
				label: option.label || this.emptyLabel,
				onClick: click,
				disabled: option.disabled || false
			});
			item.focusNode.setAttribute("role", "listitem");
			return item;
		}
	},

	_addOptionItem: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, add an option to our dropdown.
		//		If the option doesn't have a value, then a separator is added
		//		in that place.
		if(this.dropDown){
			this.dropDown.addChild(this._getMenuItemForOption(option));
		}
	},

	_getChildren: function(){
		if(!this.dropDown){
			return [];
		}
		return this.dropDown.getChildren();
	},

	_loadChildren: function(/*Boolean*/ loadMenuItems){
		// summary:
		//		Resets the menu and the length attribute of the button - and
		//		ensures that the label is appropriately set.
		//	loadMenuItems: Boolean
		//		actually loads the child menu items - we only do this when we are
		//		populating for showing the dropdown.

		if(loadMenuItems === true){
			// this.inherited destroys this.dropDown's child widgets (MenuItems).
			// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
			// issues later in _setSelected). (see #10296)
			if(this.dropDown){
				delete this.dropDown.focusedChild;
			}
			if(this.options.length){
				this.inherited(arguments);
			}else{
				// Drop down menu is blank but add one blank entry just so something appears on the screen
				// to let users know that they are no choices (mimicing native select behavior)
				array.forEach(this._getChildren(), function(child){ child.destroyRecursive(); });
				var item = new MenuItem({label: "&#160;"});
				this.dropDown.addChild(item);
			}
		}else{
			this._updateSelection();
		}

		this._isLoaded = false;
		this._childrenLoaded = true;

		if(!this._loadingStore){
			// Don't call this if we are loading - since we will handle it later
			this._setValueAttr(this.value);
		}
	},

	_setValueAttr: function(value){
		this.inherited(arguments);
		domAttr.set(this.valueNode, "value", this.get("value"));
		this.validate(this.focused);	// to update this.state
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this.inherited(arguments);
		this.validate(this.focused);	// to update this.state
	},

	_setRequiredAttr: function(/*Boolean*/ value){
		this._set("required", value);
		this.focusNode.setAttribute("aria-required", value);
		this.validate(this.focused);	// to update this.state
	},

	_setDisplay: function(/*String*/ newDisplay){
		// summary:
		//		sets the display for the given value (or values)
		var lbl = newDisplay || this.emptyLabel;
		this.containerNode.innerHTML = '<span class="dijitReset dijitInline ' + this.baseClass + 'Label">' + lbl + '</span>';
		this.focusNode.setAttribute("aria-valuetext", lbl);
	},

	validate: function(/*Boolean*/ isFocused){
		// summary:
		//		Called by oninit, onblur, and onkeypress, and whenever required/disabled state changes
		// description:
		//		Show missing or invalid messages if appropriate, and highlight textbox field.
		//		Used when a select is initially set to no value and the user is required to
		//		set the value.

		var isValid = this.disabled || this.isValid(isFocused);
		this._set("state", isValid ? "" : "Incomplete");
		this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
		var message = isValid ? "" : this._missingMsg;
		if(message && this.focused && this._hasBeenBlurred){
			Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
		}else{
			Tooltip.hide(this.domNode);
		}
		this._set("message", message);
		return isValid;
	},

	isValid: function(/*Boolean*/ /*===== isFocused =====*/){
		// summary:
		//		Whether or not this is a valid value.  The only way a Select
		//		can be invalid is when it's required but nothing is selected.
		return (!this.required || this.value === 0 || !(/^\s*$/.test(this.value || ""))); // handle value is null or undefined
	},

	reset: function(){
		// summary:
		//		Overridden so that the state will be cleared.
		this.inherited(arguments);
		Tooltip.hide(this.domNode);
		this.validate(this.focused);	// to update this.state
	},

	postMixInProperties: function(){
		// summary:
		//		set the missing message
		this.inherited(arguments);
		this._missingMsg = i18n.getLocalization("dijit.form", "validate",
									this.lang).missingMessage;
	},

	postCreate: function(){
		// summary:
		//		stop mousemove from selecting text on IE to be consistent with other browsers

		this.inherited(arguments);

		this.connect(this.domNode, "onmousemove", event.stop);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		this.inherited(arguments);
		domClass.toggle(this.domNode, this.baseClass + "FixedWidth", !!this.domNode.style.width);
	},

	isLoaded: function(){
		return this._isLoaded;
	},

	loadDropDown: function(/*Function*/ loadCallback){
		// summary:
		//		populates the menu
		this._loadChildren(true);
		this._isLoaded = true;
		loadCallback();
	},

	closeDropDown: function(){
		// overriding _HasDropDown.closeDropDown()
		this.inherited(arguments);

		if(this.dropDown && this.dropDown.menuTableNode){
			// Erase possible width: 100% setting from _SelectMenu.resize().
			// Leaving it would interfere with the next openDropDown() call, which
			// queries the natural size of the drop down.
			this.dropDown.menuTableNode.style.width = "";
		}
	},

	uninitialize: function(preserveDom){
		if(this.dropDown && !this.dropDown._destroyed){
			this.dropDown.destroyRecursive(preserveDom);
			delete this.dropDown;
		}
		this.inherited(arguments);
	},

	_onFocus: function(){
		this.validate(true);	// show tooltip if second focus of required tooltip, but no selection
		this.inherited(arguments);
	},

	_onBlur: function(){
		Tooltip.hide(this.domNode);
		this.inherited(arguments);
	}
});

Select._Menu = _SelectMenu;	// for monkey patching

return Select;
});

},
'dijit/Calendar':function(){
define("dijit/Calendar", [
	"dojo/_base/array", // array.map
	"dojo/date",
	"dojo/date/locale",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove domClass.toggle
	"dojo/_base/event", // event.stop
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/sniff", // has("ie")
	"./CalendarLite",
	"./_Widget",
	"./_CssStateMixin",
	"./_TemplatedMixin",
	"./form/DropDownButton",
	"./hccss"	// not used directly, but sets CSS class on <body>
], function(array, date, local, declare, domAttr, domClass, event, kernel, keys, lang, has,
			CalendarLite, _Widget, _CssStateMixin, _TemplatedMixin, DropDownButton){

/*=====
	var CalendarLite = dijit.CalendarLite;
	var _CssStateMixin = dijit._CssStateMixin;
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var DropDownButton = dijit.form.DropDownButton;
=====*/

	// module:
	//		dijit/Calendar
	// summary:
	//		A simple GUI for choosing a date in the context of a monthly calendar.

	var Calendar = declare("dijit.Calendar",
		[CalendarLite, _Widget, _CssStateMixin], // _Widget for deprecated methods like setAttribute()
		{
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		See CalendarLite for general description.   Calendar extends CalendarLite, adding:
		//			- month drop down list
		//			- keyboard navigation
		//			- CSS classes for hover/mousepress on date, month, and year nodes
		//			- support of deprecated methods (will be removed in 2.0)

		// Set node classes for various mouse events, see dijit._CssStateMixin for more details
		cssStateNodes: {
			"decrementMonth": "dijitCalendarArrow",
			"incrementMonth": "dijitCalendarArrow",
			"previousYearLabelNode": "dijitCalendarPreviousYear",
			"nextYearLabelNode": "dijitCalendarNextYear"
		},

		setValue: function(/*Date*/ value){
			// summary:
			//      Deprecated.   Use set('value', ...) instead.
			// tags:
			//      deprecated
			kernel.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return new Calendar._MonthDropDownButton({
				id: this.id + "_mddb",
				tabIndex: -1,
				onMonthSelect: lang.hitch(this, "_onMonthSelect"),
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Events specific to Calendar, not used in CalendarLite
			this.connect(this.domNode, "onkeypress", "_onKeyPress");
			this.connect(this.dateRowsNode, "onmouseover", "_onDayMouseOver");
			this.connect(this.dateRowsNode, "onmouseout", "_onDayMouseOut");
			this.connect(this.dateRowsNode, "onmousedown", "_onDayMouseDown");
			this.connect(this.dateRowsNode, "onmouseup", "_onDayMouseUp");
		},

		_onMonthSelect: function(/*Number*/ newMonth){
			// summary:
			//      Handler for when user selects a month from the drop down list
			// tags:
			//      protected

			// move to selected month, bounding by the number of days in the month
			// (ex: dec 31 --> jan 28, not jan 31)
			this._setCurrentFocusAttr(this.dateFuncObj.add(this.currentFocus, "month",
				newMonth - this.currentFocus.getMonth()));
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse over events on days, sets hovered style
			// tags:
			//      protected

			// event can occur on <td> or the <span> inside the td,
			// set node to the <td>.
			var node =
				domClass.contains(evt.target, "dijitCalendarDateLabel") ?
				evt.target.parentNode :
				evt.target;

			if(node && (
				(node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate"))
					|| node == this.previousYearLabelNode || node == this.nextYearLabelNode
				)){
				domClass.add(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse out events on days, clears hovered style
			// tags:
			//      protected

			if(!this._currentNode){ return; }

			// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
			if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){ return; }
			var cls = "dijitCalendarHoveredDate";
			if(domClass.contains(this._currentNode, "dijitCalendarActiveDate")){
				cls += " dijitCalendarActiveDate";
			}
			domClass.remove(this._currentNode, cls);
			this._currentNode = null;
		},

		_onDayMouseDown: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")){
				domClass.add(node, "dijitCalendarActiveDate");
				this._currentNode = node;
			}
		},

		_onDayMouseUp: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				domClass.remove(node, "dijitCalendarActiveDate");
			}
		},

		handleKey: function(/*Event*/ evt){
			// summary:
			//		Provides keyboard navigation of calendar.
			// description:
			//		Called from _onKeyPress() to handle keypress on a stand alone Calendar,
			//		and also from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.DateTextBox` to be handled in this widget
			// returns:
			//		False if the key was recognized as a navigation key,
			//		to indicate that the event was handled by Calendar and shouldn't be propogated
			// tags:
			//		protected
			var increment = -1,
				interval,
				newValue = this.currentFocus;
			switch(evt.charOrCode){
				case keys.RIGHT_ARROW:
					increment = 1;
					//fallthrough...
				case keys.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){ increment *= -1; }
					break;
				case keys.DOWN_ARROW:
					increment = 1;
					//fallthrough...
				case keys.UP_ARROW:
					interval = "week";
					break;
				case keys.PAGE_DOWN:
					increment = 1;
					//fallthrough...
				case keys.PAGE_UP:
					interval = evt.ctrlKey || evt.altKey ? "year" : "month";
					break;
				case keys.END:
					// go to the next month
					newValue = this.dateFuncObj.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
					//fallthrough...
				case keys.HOME:
					newValue = new this.dateClassObj(newValue);
					newValue.setDate(1);
					break;
				case keys.ENTER:
				case " ":
					this.set("value", this.currentFocus);
					break;
				default:
					return true;
			}

			if(interval){
				newValue = this.dateFuncObj.add(newValue, interval, increment);
			}

			this._setCurrentFocusAttr(newValue);

			return false;
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		For handling keypress events on a stand alone calendar
			if(!this.handleKey(evt)){
				event.stop(evt);
			}
		},

		onValueSelected: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Deprecated.   Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//      Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
			//      to get notification when the user has clicked a date.  Now onExecute() (above) is used.
			// tags:
			//      protected
		},

		onChange: function(value){
			this.onValueSelected(value);	// remove in 2.0
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	});

	Calendar._MonthDropDownButton = declare("dijit.Calendar._MonthDropDownButton", DropDownButton, {
		// summary:
		//		DropDownButton for the current month.    Displays name of current month
		//		and a list of month names in the drop down

		onMonthSelect: function(){ },

		postCreate: function(){
			this.inherited(arguments);
			this.dropDown = new Calendar._MonthDropDown({
				id: this.id + "_mdd", //do not change this id because it is referenced in the template
				onChange: this.onMonthSelect
			});
		},
		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
			this.dropDown.set("months", monthNames);

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.containerNode.innerHTML =
				(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + this.dropDown.domNode.innerHTML + "</div>") +
				"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +  monthNames[month.getMonth()] + "</div>";
		}
	});

	Calendar._MonthDropDown = declare("dijit.Calendar._MonthDropDown", [_Widget, _TemplatedMixin], {
		// summary:
		//		The list-of-months drop down from the MonthDropDownButton

		// months: String[]
		//		List of names of months, possibly w/some undefined entries for Hebrew leap months
		//		(ex: ["January", "February", undefined, "April", ...])
		months: [],

		templateString: "<div class='dijitCalendarMonthMenu dijitMenu' " +
			"data-dojo-attach-event='onclick:_onClick,onmouseover:_onMenuHover,onmouseout:_onMenuHover'></div>",

		_setMonthsAttr: function(/*String[]*/ months){
			this.domNode.innerHTML = array.map(months, function(month, idx){
					return month ? "<div class='dijitCalendarMonthLabel' month='" + idx +"'>" + month + "</div>" : "";
				}).join("");
		},

		_onClick: function(/*Event*/ evt){
			this.onChange(domAttr.get(evt.target, "month"));
		},

		onChange: function(/*Number*/ /*===== month =====*/){
			// summary:
			//		Callback when month is selected from drop down
		},

		_onMenuHover: function(evt){
			domClass.toggle(evt.target, "dijitCalendarMonthLabelHover", evt.type == "mouseover");
		}
	});

	return Calendar;
});

},
'dijit/_base/manager':function(){
define("dijit/_base/manager", [
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"../registry",
	".."	// for setting exports to dijit namespace
], function(array, config, registry, dijit){

	// module:
	//		dijit/_base/manager
	// summary:
	//		Shim to methods on registry, plus a few other declarations.
	//		New code should access dijit/registry directly when possible.

	/*=====
	dijit.byId = function(id){
		// summary:
		//		Returns a widget by it's id, or if passed a widget, no-op (like dom.byId())
		// id: String|dijit._Widget
		return registry.byId(id); // dijit._Widget
	};

	dijit.getUniqueId = function(widgetType){
		// summary:
		//		Generates a unique id for a given widgetType
		// widgetType: String
		return registry.getUniqueId(widgetType); // String
	};

	dijit.findWidgets = function(root){
		// summary:
		//		Search subtree under root returning widgets found.
		//		Doesn't search for nested widgets (ie, widgets inside other widgets).
		// root: DOMNode
		return registry.findWidgets(root);
	};

	dijit._destroyAll = function(){
		// summary:
		//		Code to destroy all widgets and do other cleanup on page unload

		return registry._destroyAll();
	};

	dijit.byNode = function(node){
		// summary:
		//		Returns the widget corresponding to the given DOMNode
		// node: DOMNode
		return registry.byNode(node); // dijit._Widget
	};

	dijit.getEnclosingWidget = function(node){
		// summary:
		//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
		//		the node is not contained within the DOM tree of any widget
		// node: DOMNode
		return registry.getEnclosingWidget(node);
	};
	=====*/
	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		dijit[name] = registry[name];
	});

	/*=====
	dojo.mixin(dijit, {
		// defaultDuration: Integer
		//		The default fx.animation speed (in ms) to use for all Dijit
		//		transitional fx.animations, unless otherwise specified
		//		on a per-instance basis. Defaults to 200, overrided by
		//		`djConfig.defaultDuration`
		defaultDuration: 200
	});
	=====*/
	dijit.defaultDuration = config["defaultDuration"] || 200;

	return dijit;
});

},
'dijit/form/ComboButton':function(){
require({cache:{
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:_onClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n"}});
define("dijit/form/ComboButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"../focus",		// focus.focus()
	"./DropDownButton",
	"dojo/text!./templates/ComboButton.html"
], function(declare, event, keys, focus, DropDownButton, template){

/*=====
	var DropDownButton = dijit.form.DropDownButton;
=====*/

// module:
//		dijit/form/ComboButton
// summary:
//		A combination button and drop-down button.

return declare("dijit.form.ComboButton", DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button data-dojo-type="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div data-dojo-type="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: template,

	// Map widget attributes to DOMNode attributes.
	_setIdAttr: "",	// override _FormWidgetMixin which puts id on the focusNode
	_setTabIndexAttr: ["focusNode", "titleNode"],
	_setTitleAttr: "titleNode",

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
	// mouse action over specified node
	cssStateNodes: {
		"buttonNode": "dijitButtonNode",
		"titleNode": "dijitButtonContents",
		"_popupStateNode": "dijitDownArrowButton"
	},

	_focusedNode: null,

	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			focus.focus(this._popupStateNode);
			event.stop(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			focus.focus(this.titleNode);
			event.stop(evt);
		}
	},

	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		if(!this.disabled){
			focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
		}
	}
});

});

},
'dijit/WidgetSet':function(){
define("dijit/WidgetSet", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/window", // win.global
	"./registry"	// to add functions to dijit.registry
], function(array, declare, win, registry){

	// module:
	//		dijit/WidgetSet
	// summary:
	//		Legacy registry code.   New modules should just use registry.
	//		Will be removed in 2.0.

	var WidgetSet = declare("dijit.WidgetSet", null, {
		// summary:
		//		A set of widgets indexed by id. A default instance of this class is
		//		available as `dijit.registry`
		//
		// example:
		//		Create a small list of widgets:
		//		|	var ws = new dijit.WidgetSet();
		//		|	ws.add(dijit.byId("one"));
		//		| 	ws.add(dijit.byId("two"));
		//		|	// destroy both:
		//		|	ws.forEach(function(w){ w.destroy(); });
		//
		// example:
		//		Using dijit.registry:
		//		|	dijit.registry.forEach(function(w){ /* do something */ });

		constructor: function(){
			this._hash = {};
			this.length = 0;
		},

		add: function(/*dijit._Widget*/ widget){
			// summary:
			//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit._Widget
			//		Any dijit._Widget subclass.
			if(this._hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			this._hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
			//		removes the reference.
			if(this._hash[id]){
				delete this._hash[id];
				this.length--;
			}
		},

		forEach: function(/*Function*/ func, /* Object? */thisObj){
			// summary:
			//		Call specified function for each widget in this set.
			//
			// func:
			//		A callback function to run for each item. Is passed the widget, the index
			//		in the iteration, and the full hash, similar to `array.forEach`.
			//
			// thisObj:
			//		An optional scope parameter
			//
			// example:
			//		Using the default `dijit.registry` instance:
			//		|	dijit.registry.forEach(function(widget){
			//		|		console.log(widget.declaredClass);
			//		|	});
			//
			// returns:
			//		Returns self, in order to allow for further chaining.

			thisObj = thisObj || win.global;
			var i = 0, id;
			for(id in this._hash){
				func.call(thisObj, this._hash[id], i++, this._hash);
			}
			return this;	// dijit.WidgetSet
		},

		filter: function(/*Function*/ filter, /* Object? */thisObj){
			// summary:
			//		Filter down this WidgetSet to a smaller new WidgetSet
			//		Works the same as `array.filter` and `NodeList.filter`
			//
			// filter:
			//		Callback function to test truthiness. Is passed the widget
			//		reference and the pseudo-index in the object.
			//
			// thisObj: Object?
			//		Option scope to use for the filter function.
			//
			// example:
			//		Arbitrary: select the odd widgets in this list
			//		|	dijit.registry.filter(function(w, i){
			//		|		return i % 2 == 0;
			//		|	}).forEach(function(w){ /* odd ones */ });

			thisObj = thisObj || win.global;
			var res = new WidgetSet(), i = 0, id;
			for(id in this._hash){
				var w = this._hash[id];
				if(filter.call(thisObj, w, i++, this._hash)){
					res.add(w);
				}
			}
			return res; // dijit.WidgetSet
		},

		byId: function(/*String*/ id){
			// summary:
			//		Find a widget in this list by it's id.
			// example:
			//		Test if an id is in a particular WidgetSet
			//		| var ws = new dijit.WidgetSet();
			//		| ws.add(dijit.byId("bar"));
			//		| var t = ws.byId("bar") // returns a widget
			//		| var x = ws.byId("foo"); // returns undefined

			return this._hash[id];	// dijit._Widget
		},

		byClass: function(/*String*/ cls){
			// summary:
			//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
			//
			// cls: String
			//		The Class to scan for. Full dot-notated string.
			//
			// example:
			//		Find all `dijit.TitlePane`s in a page:
			//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

			var res = new WidgetSet(), id, widget;
			for(id in this._hash){
				widget = this._hash[id];
				if(widget.declaredClass == cls){
					res.add(widget);
				}
			 }
			 return res; // dijit.WidgetSet
		},

		toArray: function(){
			// summary:
			//		Convert this WidgetSet into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(dijit.registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in this._hash){
				ar.push(this._hash[id]);
			}
			return ar;	// dijit._Widget[]
		},

		map: function(/* Function */func, /* Object? */thisObj){
			// summary:
			//		Create a new Array from this WidgetSet, following the same rules as `array.map`
			// example:
			//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
			//
			// returns:
			//		A new array of the returned values.
			return array.map(this.toArray(), func, thisObj); // Array
		},

		every: function(func, thisObj){
			// summary:
			// 		A synthetic clone of `array.every` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first false return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || win.global;
			var x = 0, i;
			for(i in this._hash){
				if(!func.call(thisObj, this._hash[i], x++, this._hash)){
					return false; // Boolean
				}
			}
			return true; // Boolean
		},

		some: function(func, thisObj){
			// summary:
			// 		A synthetic clone of `array.some` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first true return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || win.global;
			var x = 0, i;
			for(i in this._hash){
				if(func.call(thisObj, this._hash[i], x++, this._hash)){
					return true; // Boolean
				}
			}
			return false; // Boolean
		}

	});

	// Add in 1.x compatibility methods to dijit.registry.
	// These functions won't show up in the API doc but since they are deprecated anyway,
	// that's probably for the best.
	array.forEach(["forEach", "filter", "byClass", "map", "every", "some"], function(func){
		registry[func] = WidgetSet.prototype[func];
	});


	return WidgetSet;
});

},
'dijit/form/RangeBoundTextBox':function(){
define("dijit/form/RangeBoundTextBox", [
	"dojo/_base/declare", // declare
	"dojo/i18n", // i18n.getLocalization
	"./MappedTextBox"
], function(declare, i18n, MappedTextBox){

/*=====
	var MappedTextBox = dijit.form.MappedTextBox;
=====*/

	// module:
	//		dijit/form/RangeBoundTextBox
	// summary:
	//		Base class for textbox form widgets which defines a range of valid values.

	/*=====
		dijit.form.RangeBoundTextBox.__Constraints = function(){
			// min: Number
			//		Minimum signed value.  Default is -Infinity
			// max: Number
			//		Maximum signed value.  Default is +Infinity
			this.min = min;
			this.max = max;
		}
	=====*/

	return declare("dijit.form.RangeBoundTextBox", MappedTextBox, {
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.get('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.get('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.get('value');
			if(v !== null && v !== '' && v !== undefined && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			this.inherited(arguments);
			if(this.focusNode){ // not set when called from postMixInProperties
				if(this.constraints.min !== undefined){
					this.focusNode.setAttribute("aria-valuemin", this.constraints.min);
				}else{
					this.focusNode.removeAttribute("aria-valuemin");
				}
				if(this.constraints.max !== undefined){
					this.focusNode.setAttribute("aria-valuemax", this.constraints.max);
				}else{
					this.focusNode.removeAttribute("aria-valuemax");
				}
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', ...) works.

			this.focusNode.setAttribute("aria-valuenow", value);
			this.inherited(arguments);
		},

		applyTextDir: function(/*===== element, text =====*/){
			// summary:
			//		The function overridden in the _BidiSupport module,
			//		originally used for setting element.dir according to this.textDir.
			//		In this case does nothing.
			// element: Object
			// text: String
			// tags:
			//		protected.
		}
	});
});

},
'url:idx/oneui/templates/_MenuColumn.html':"<td class=\"dijitReset oneuiMenuColumn\" data-dojo-attach-point=\"columnNodes\">\r\n\t<table class=\"dijitReset\" cellspacing=\"0\" width=\"100%\" role=\"presentation\">\r\n\t\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"_containerNodes\">\r\n<!-- this must be kept in synch with column 0 included in Menu.html -->\r\n\t\t</tbody>\r\n\t</table>\r\n</td>",
'dojo/touch':function(){
define("dojo/touch", ["./_base/kernel", "./on", "./has", "./mouse"], function(dojo, on, has, mouse){
// module:
//		dojo/touch

/*=====
	dojo.touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//
		// example:
		//		1. Used with dojo.connect()
		//		|	dojo.connect(node, dojo.touch.press, function(e){});
		//		|	dojo.connect(node, dojo.touch.move, function(e){});
		//		|	dojo.connect(node, dojo.touch.release, function(e){});
		//		|	dojo.connect(node, dojo.touch.cancel, function(e){});
		//
		//		2. Used with dojo.on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		//
		//		3. Used with dojo.touch.* directly
		//		|	dojo.touch.press(node, function(e){});
		//		|	dojo.touch.move(node, function(e){});
		//		|	dojo.touch.release(node, function(e){});
		//		|	dojo.touch.cancel(node, function(e){});
		
		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener to 'touchmove'|'mousemove' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to 'touchend'|'mouseup' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
=====*/

	function _handle(/*String - press | move | release | cancel*/type){
		return function(node, listener){//called by on(), see dojo.on
			return on(node, type, listener);
		};
	}
	var touch = has("touch");
	//device neutral events - dojo.touch.press|move|release|cancel
	dojo.touch = {
		press: _handle(touch ? "touchstart": "mousedown"),
		move: _handle(touch ? "touchmove": "mousemove"),
		release: _handle(touch ? "touchend": "mouseup"),
		cancel: touch ? _handle("touchcancel") : mouse.leave
	};
	return dojo.touch;
});
},
'cwtk/widget/InlineDropDown':function(){
require({cache:{
'url:cwtk/widget/templates/InlineDropDown.html':"<div id=\"${id}\" class=\"cw-inline-dropdown\">\n\t<div class=\"cw-inline-dropdown-container-wrapper\" \n\t\tdata-dojo-attach-point=\"containerWrapper\">\n\t\t<div class=\"cw-inline-dropdown-container\" \n\t\t\tdata-dojo-attach-point=\"containerNode\">\n\t\t</div>\n\t</div>\n\t<div id=\"${id}_dropdown\" class=\"cw-inline-dropdown-div\" \n\t\tdata-dojo-type=\"cwtk.widget.DropDown\"\n\t\tdata-dojo-attach-point=\"dropdownNode\"\n\t\tposition=\"below\">\n\t\t<div>\n\t\t\t<div id=\"${id}_button\" class=\"cw-inline-dropdown-button\" \n\t\t\t\tdata-dojo-attach-point=\"buttonNode\">\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"cw-tooltip-dialog cw-inline-dropdown-tooltip\" \n\t\t\tdata-dojo-type=\"dijit.TooltipDialog\">\n\t\t\t<div class=\"cw-inline-dropdown-tooltip-container\" \n\t\t\t\tdata-dojo-attach-point=\"tooltipContainer\"></div>\n\t\t</div>\n\t</div>\n</div>\n"}});
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/InlineDropDown", [
    "dojo", 
    "dojo/_base/declare", 
    "dojo/_base/lang", 
    "dijit/_Widget",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dojo/text!./templates/InlineDropDown.html"
], function(dojo, declare, lang, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, template){

		return declare("cwtk.widget.InlineDropDown", [_Widget,_TemplatedMixin,_WidgetsInTemplateMixin], {
		
		   buttonNode: null,
		   dropdownNode: null,
		   tooltipContainer: null,
		   containerWrapper: null,
		   
		   templateString: template,
		   
		   /* Properties */
		   
		   maxWidth : '50%', 
		   
		   postMixInProperties : function() {
		       this.inherited(arguments);
	       },
		   
		   buildRendering : function() {
               this.inherited(arguments);
		   },
		   
           startup : function() {
               this.inherited(arguments);
               dojo.connect(this, "resize", this._onResize);
               dojo.connect(this.dropdownNode, "openDropDown", dojo.hitch(this, function(){ 
                   this.fixDropDown();
               }));
               dojo.place(dojo.clone(this.containerNode), this.tooltipContainer);
               setTimeout(dojo.hitch(this, function(){this._onResize();}), 300);
           },
           
           _onResize : function() {
               this.fixLayout();
           },
           
           fixDropDown : function() {
		   
			   //reset margins
			   this.dropdownNode.dropDown.domNode.style.marginLeft = 0;
		       this.dropdownNode.connector.style.marginLeft = 0;
			   
			   var posAround = dojo.position(this.dropdownNode.aroundNode, true);
			   var posConnector = dojo.position(this.dropdownNode.connector, true);
			   var posWrapper = dojo.position(this.containerWrapper, true);
			   var posTooltip = dojo.position(this.tooltipContainer, true);
			   
			   //calculate position
    		   var shiftConnector = (posAround.x + posAround.w / 2) - (posConnector.x + posConnector.w / 2);
    		   var shiftContainer = posWrapper.x - posTooltip.x;
			   
			   this.dropdownNode.connector.style.marginLeft = (shiftConnector - shiftContainer) + "px";
			   this.dropdownNode.dropDown.domNode.style.marginLeft = shiftContainer + "px";
			   
		   },
           
           fixLayout : function() {
           
               var containerWidth = 0;
               dojo.query(">", this.containerNode).forEach(function(node){
                   var pos = dojo.position(node);
                   containerWidth += pos.w;
               });
               dojo.style(this.containerNode, 'width', containerWidth + 'px');
               
               
               var wrapperWidth;
               if (this.maxWidth.indexOf('%') > -1) {
                   wrapperWidth = dojo.position(this.domNode.parentNode).w * parseInt(this.maxWidth) / 100;
               } else {
                   wrapperWidth = parseInt(this.maxWidth);
               }
               
               if (containerWidth <= wrapperWidth) {
                   dojo.addClass(this.dropdownNode.domNode, 'dijitHidden');
                   dojo.style(this.containerWrapper, 'width', wrapperWidth + 'px');
               } else {
                   dojo.removeClass(this.dropdownNode.domNode, 'dijitHidden');
                   var posAround = dojo.position(this.dropdownNode.aroundNode, true);
                   dojo.style(this.containerWrapper, 'width', wrapperWidth - posAround.w + 'px');
               }
           },
           
           destroy : function() {
               this.inherited(arguments);
           }
        });

});
},
'dojo/cache':function(){
define("dojo/cache", ["./_base/kernel", "./text"], function(dojo, text){
	// module:
	//		dojo/cache
	// summary:
	//		The module defines dojo.cache by loading dojo/text.

	//dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'dijit/DialogUnderlay':function(){
define("dijit/DialogUnderlay", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe"
], function(declare, domAttr, win, winUtils, _Widget, _TemplatedMixin, BackgroundIframe){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/DialogUnderlay
	// summary:
	//		The component that blocks the screen behind a `dijit.Dialog`

	return declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' data-dojo-attach-point='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		_setDialogIdAttr: function(id){
			domAttr.set(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			win.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = winUtils.getBox();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
		}
	});
});

},
'dijit/form/_ToggleButtonMixin':function(){
define("dijit/form/_ToggleButtonMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

// module:
//		dijit/form/_ToggleButtonMixin
// summary:
//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

return declare("dijit.form._ToggleButtonMixin", null, {
	// summary:
	//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	// aria-pressed for toggle buttons, and aria-checked for checkboxes
	_aria_attr: "aria-pressed",

	_onClick: function(/*Event*/ evt){
		var original = this.checked;
		this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
		var ret = this.inherited(arguments); // the user could reset the value here
		this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
		return ret;
	},

	_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
		this._set("checked", value);
		domAttr.set(this.focusNode || this.domNode, "checked", value);
		(this.focusNode || this.domNode).setAttribute(this._aria_attr, value ? "true" : "false"); // aria values should be strings
		this._handleOnChange(value, priorityChange);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.set('checked', this.params.checked || false);
	}
});

});

},
'url:cwtk/widget/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" waiRole=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${iconSrc}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n",
'dojo/store/util/SimpleQueryEngine':function(){
define("dojo/store/util/SimpleQueryEngine", ["../../_base/array"], function(arrayUtil) {
  //  module:
  //    dojo/store/util/SimpleQueryEngine
  //  summary:
  //    The module defines a simple filtering query engine for object stores. 

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	// 		used to match strings by more complex expressions
	// 		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo.store.util.SimpleQueryEngine.__queryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = dojo.store.util.SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return dojo.store.util.QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						if(!required.test(object[key])){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		if(options && options.sort){
			results.sort(function(a, b){
				for(var sort, i=0; sort = options.sort[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					if (aValue != bValue) {
						return !!sort.descending == aValue > bValue ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};
});

},
'dijit/_TemplatedMixin':function(){
define("dijit/_TemplatedMixin", [
	"dojo/_base/lang", // lang.getObject
	"dojo/touch",
	"./_WidgetBase",
	"dojo/string", // string.substitute string.trim
	"dojo/cache",	// dojo.cache
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window" // win.doc
], function(lang, touch, _WidgetBase, string, cache, array, declare, domConstruct, has, unload, win) {

/*=====
	var _WidgetBase = dijit._WidgetBase;
=====*/

	// module:
	//		dijit/_TemplatedMixin
	// summary:
	//		Mixin for widgets that are instantiated from a template

	var _TemplatedMixin = declare("dijit._TemplatedMixin", null, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
 		_attachPoints: [],
 =====*/

/*=====
		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
 		_attachEvents: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
			this._attachEvents = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this.templateString){
				this.templateString = cache(this.templatePath, {sanitize: true});
			}

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache);

			var node;
			if(lang.isString(cached)){
				node = domConstruct.toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// Call down to _Widget.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node, function(n,p){ return n.getAttribute(p); });

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin

			this._fillContent(this.srcNodeRef);
		},

		_beforeFillContent: function(){
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			//		Alternately, if rootNode is an array of widgets, then will process data-dojo-attach-point
			//		etc. for those widgets.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint/data-dojo-attach-point
			//			* dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode|Widget[]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			var nodes = lang.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = lang.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
					continue;
				}
				// Process data-dojo-attach-point
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(lang.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process data-dojo-attach-event
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = lang.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							// Map "press", "move" and "release" to keys.touch, keys.move, keys.release
							this._attachEvents.push(this.connect(baseNode, touch[event] || event, thisFunc));
						}
					}
				}
			}
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			array.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];

			this.inherited(arguments);
		}
	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == win.doc){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		unload.addOnWindowUnload(function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	lang.extend(_WidgetBase,{
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});

	return _TemplatedMixin;
});

},
'curam/util/ui/refresh/RefreshEvent':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/ui/refresh/RefreshEvent", [], function() {
  
  /*
   * Modification History
   * --------------------
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * @name curam.util.ui.refresh.RefreshEvent
   * @namespace Represents a UI element refresh event.
   * 
   */
  var RefreshEvent = dojo.declare("curam.util.ui.refresh.RefreshEvent", null,
  /**
   * @lends curam.util.ui.refresh.RefreshEvent.prototype
   */
  {
    /** Event type constant. */
    TYPE_ONLOAD: "onload",
    
    /** Event type constant. */
    TYPE_ONSUBMIT: "onsubmit",
    
    /** Event context constant. */
    SOURCE_CONTEXT_MAIN: "main-content",
    
    /** Event context constant. */
    SOURCE_CONTEXT_DIALOG: "dialog",
    
    /** Event context constant. */
    SOURCE_CONTEXT_INLINE: "inline",

    /** Holds the type of the event. */
    _type: null,
    
    /** Holds the context of the event. */
    _context: null,
    
    /**
     * Creates an instance of the refresh event.
     * 
     * @param {String}
     *                type The event type. Only accepted values will be the ones
     *                provided as constants in this class.
     * @param {String}
     *                context The event context. Only accepted values will be the
     *                ones provided as constants in this class.
     */
    constructor: function(type, context) {
      if (!type || !context) {
        throw "Required parameters missing.";
      }
      if (!(type == this.TYPE_ONLOAD || type == this.TYPE_ONSUBMIT)) {
        throw "Unknown type: " + type;
      }
      if (!(context == this.SOURCE_CONTEXT_DIALOG
          || context == this.SOURCE_CONTEXT_INLINE
          || context == this.SOURCE_CONTEXT_MAIN)) {
        throw "Unknown context: " + context;
      }

      this._type = type;
      this._context = context;
    },
    
    /**
     * Determines if the specified event is the same as this one.
     * 
     * @param other
     *                The event to check.
     * @returns {Boolean} True if the other event is the same, otherwise false.
     */
    equals: function(other) {
      // check for undefined, null and variable types other than object
      if (typeof other != "object") {
        return false;
      }
      
      // check for Dojo class name
      if (other.declaredClass != this.declaredClass) {
        return false;
      }
      
      return this._type === other._type
          && this._context === other._context;
    }
  });
  
  return RefreshEvent;
});

},
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:_onClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n",
'cwtk/util/LoadingHandler':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/util/LoadingHandler", [
    "dojo", 
    "dojo/_base/declare",
    "dijit/Dialog"
], function(dojo, declare, localDialog){

		return declare("cwtk.util.LoadingHandler", null, {
		
		    title: 'Loading',
		    
		    description: '',
		    
		    dialog: null,
		    
		    template: '<div class=\"cw-loading-pane-div\"><div class=\"cw-loading-pane-description\">{description}</div><div class=\"cw-loading-pane-image\"/></div>',

            getDialog : function() {
            
                if (this.dialog == null) {
                    this.dialog = new localDialog({
                        toggle: 'fade'
                    });
                    dojo.addClass(this.dialog.domNode, 
                        'cw-loading-pane-dialog');
                }
                return this.dialog;
            },
            
			/* object {title, description}*/
			show : function(obj) {
					
				var d = this.getDialog();
                var title = this.title;                     
                var description = this.description;
                
                if (obj) {
                    title = obj.title || title;
                    description = obj.description || description;
                }
                     
                d.set('title', title);
                d.set('content', this.template.replace("{description}", 
                    description));     
                  
                this.dialog.show();
				
			},
			
			hide : function() {
			    this.getDialog().hide();
			}
		});

});
},
'dijit/form/_TextBoxMixin':function(){
define("dijit/form/_TextBoxMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	".."	// for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, event, keys, lang, dijit){

// module:
//		dijit/form/_TextBoxMixin
// summary:
//		A mixin for textbox form input widgets

var _TextBoxMixin = declare("dijit.form._TextBoxMixin", null, {
	// summary:
	//		A mixin for textbox form input widgets

	// trim: Boolean
	//		Removes leading and trailing whitespace if true.  Default is false.
	trim: false,

	// uppercase: Boolean
	//		Converts all characters to uppercase if true.  Default is false.
	uppercase: false,

	// lowercase: Boolean
	//		Converts all characters to lowercase if true.  Default is false.
	lowercase: false,

	// propercase: Boolean
	//		Converts the first character of each word to uppercase if true.
	propercase: false,

	// maxLength: String
	//		HTML INPUT tag maxLength declaration.
	maxLength: "",

	// selectOnClick: [const] Boolean
	//		If true, all text will be selected when focused with mouse
	selectOnClick: false,

	// placeHolder: String
	//		Defines a hint to help users fill out the input field (as defined in HTML 5).
	//		This should only contain plain text (no html markup).
	placeHolder: "",

	_getValueAttr: function(){
		// summary:
		//		Hook so get('value') works as we like.
		// description:
		//		For `dijit.form.TextBox` this basically returns the value of the <input>.
		//
		//		For `dijit.form.MappedTextBox` subclasses, which have both
		//		a "displayed value" and a separate "submit value",
		//		This treats the "displayed value" as the master value, computing the
		//		submit value from it via this.parse().
		return this.parse(this.get('displayedValue'), this.constraints);
	},

	_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
		// summary:
		//		Hook so set('value', ...) works.
		//
		// description:
		//		Sets the value of the widget to "value" which can be of
		//		any type as determined by the widget.
		//
		// value:
		//		The visual element value is also set to a corresponding,
		//		but not necessarily the same, value.
		//
		// formattedValue:
		//		If specified, used to set the visual element value,
		//		otherwise a computed visual value is used.
		//
		// priorityChange:
		//		If true, an onChange event is fired immediately instead of
		//		waiting for the next blur event.

		var filteredValue;
		if(value !== undefined){
			// TODO: this is calling filter() on both the display value and the actual value.
			// I added a comment to the filter() definition about this, but it should be changed.
			filteredValue = this.filter(value);
			if(typeof formattedValue != "string"){
				if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
					formattedValue = this.filter(this.format(filteredValue, this.constraints));
				}else{ formattedValue = ''; }
			}
		}
		if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
			this.textbox.value = formattedValue;
			this._set("displayedValue", this.get("displayedValue"));
		}

		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, formattedValue);
		}

		this.inherited(arguments, [filteredValue, priorityChange]);
	},

	// displayedValue: String
	//		For subclasses like ComboBox where the displayed value
	//		(ex: Kentucky) and the serialized value (ex: KY) are different,
	//		this represents the displayed value.
	//
	//		Setting 'displayedValue' through set('displayedValue', ...)
	//		updates 'value', and vice-versa.  Otherwise 'value' is updated
	//		from 'displayedValue' periodically, like onBlur etc.
	//
	//		TODO: move declaration to MappedTextBox?
	//		Problem is that ComboBox references displayedValue,
	//		for benefit of FilteringSelect.
	displayedValue: "",

	_getDisplayedValueAttr: function(){
		// summary:
		//		Hook so get('displayedValue') works.
		// description:
		//		Returns the displayed value (what the user sees on the screen),
		// 		after filtering (ie, trimming spaces etc.).
		//
		//		For some subclasses of TextBox (like ComboBox), the displayed value
		//		is different from the serialized value that's actually
		//		sent to the server (see dijit.form.ValidationTextBox.serialize)

		// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
		// this method
		// TODO: this isn't really the displayed value when the user is typing
		return this.filter(this.textbox.value);
	},

	_setDisplayedValueAttr: function(/*String*/ value){
		// summary:
		//		Hook so set('displayedValue', ...) works.
		// description:
		//		Sets the value of the visual element to the string "value".
		//		The widget value is also set to a corresponding,
		//		but not necessarily the same, value.

		if(value === null || value === undefined){ value = '' }
		else if(typeof value != "string"){ value = String(value) }

		this.textbox.value = value;

		// sets the serialized value to something corresponding to specified displayedValue
		// (if possible), and also updates the textbox.value, for example converting "123"
		// to "123.00"
		this._setValueAttr(this.get('value'), undefined);

		this._set("displayedValue", this.get('displayedValue'));

		// textDir support
		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, value);
		}
	},

	format: function(value /*=====, constraints =====*/){
		// summary:
		//		Replaceable function to convert a value to a properly formatted string.
		// value: String
		// constraints: Object
		// tags:
		//		protected extension
		return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
	},

	parse: function(value /*=====, constraints =====*/){
		// summary:
		//		Replaceable function to convert a formatted string to a value
		// value: String
		// constraints: Object
		// tags:
		//		protected extension

		return value;	// String
	},

	_refreshState: function(){
		// summary:
		//		After the user types some characters, etc., this method is
		//		called to check the field for validity etc.  The base method
		//		in `dijit.form.TextBox` does nothing, but subclasses override.
		// tags:
		//		protected
	},

	/*=====
	onInput: function(event){
		// summary:
		//		Connect to this function to receive notifications of various user data-input events.
		//		Return false to cancel the event and prevent it from being processed.
		// event:
		//		keydown | keypress | cut | paste | input
		// tags:
		//		callback
	},
	=====*/
	onInput: function(){},

	__skipInputEvent: false,
	_onInput: function(){
		// summary:
		//		Called AFTER the input event has happened
		// set text direction according to textDir that was defined in creation
		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, this.focusNode.value);
		}

		this._refreshState();

		// In case someone is watch()'ing for changes to displayedValue
		this._set("displayedValue", this.get("displayedValue"));
	},

	postCreate: function(){
		// setting the value here is needed since value="" in the template causes "undefined"
		// and setting in the DOM (instead of the JS object) helps with form reset actions
		this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

		this.inherited(arguments);

		// normalize input events to reduce spurious event processing
		//	onkeydown: do not forward modifier keys
		//	           set charOrCode to numeric keycode
		//	onkeypress: do not forward numeric charOrCode keys (already sent through onkeydown)
		//	onpaste & oncut: set charOrCode to 229 (IME)
		//	oninput: if primary event not already processed, set charOrCode to 229 (IME), else do not forward
		var handleEvent = function(e){
			var charCode = e.charOrCode || e.keyCode || 229;
			if(e.type == "keydown"){
				switch(charCode){ // ignore "state" keys
					case keys.SHIFT:
					case keys.ALT:
					case keys.CTRL:
					case keys.META:
					case keys.CAPS_LOCK:
						return;
					default:
						if(charCode >= 65 && charCode <= 90){ return; } // keydown for A-Z can be processed with keypress
				}
			}
			if(e.type == "keypress" && typeof charCode != "string"){ return; }
			if(e.type == "input"){
				if(this.__skipInputEvent){ // duplicate event
					this.__skipInputEvent = false;
					return;
				}
			}else{
				this.__skipInputEvent = true;
			}
			// create fake event to set charOrCode and to know if preventDefault() was called
			var faux = lang.mixin({}, e, {
				charOrCode: charCode,
				wasConsumed: false,
				preventDefault: function(){
					faux.wasConsumed = true;
					e.preventDefault();
				},
				stopPropagation: function(){ e.stopPropagation(); }
			});
			// give web page author a chance to consume the event
			if(this.onInput(faux) === false){
				event.stop(faux); // return false means stop
			}
			if(faux.wasConsumed){ return; } // if preventDefault was called
			setTimeout(lang.hitch(this, "_onInput", faux), 0); // widget notification after key has posted
		};
		array.forEach([ "onkeydown", "onkeypress", "onpaste", "oncut", "oninput", "oncompositionend" ], function(event){
			this.connect(this.textbox, event, handleEvent);
		}, this);
	},

	_blankValue: '', // if the textbox is blank, what value should be reported
	filter: function(val){
		// summary:
		//		Auto-corrections (such as trimming) that are applied to textbox
		//		value on blur or form submit.
		// description:
		//		For MappedTextBox subclasses, this is called twice
		// 			- once with the display value
		//			- once the value as set/returned by set('value', ...)
		//		and get('value'), ex: a Number for NumberTextBox.
		//
		//		In the latter case it does corrections like converting null to NaN.  In
		//		the former case the NumberTextBox.filter() method calls this.inherited()
		//		to execute standard trimming code in TextBox.filter().
		//
		//		TODO: break this into two methods in 2.0
		//
		// tags:
		//		protected extension
		if(val === null){ return this._blankValue; }
		if(typeof val != "string"){ return val; }
		if(this.trim){
			val = lang.trim(val);
		}
		if(this.uppercase){
			val = val.toUpperCase();
		}
		if(this.lowercase){
			val = val.toLowerCase();
		}
		if(this.propercase){
			val = val.replace(/[^\s]+/g, function(word){
				return word.substring(0,1).toUpperCase() + word.substring(1);
			});
		}
		return val;
	},

	_setBlurValue: function(){
		this._setValueAttr(this.get('value'), true);
	},

	_onBlur: function(e){
		if(this.disabled){ return; }
		this._setBlurValue();
		this.inherited(arguments);

		if(this._selectOnClickHandle){
			this.disconnect(this._selectOnClickHandle);
		}
	},

	_isTextSelected: function(){
		return this.textbox.selectionStart == this.textbox.selectionEnd;
	},

	_onFocus: function(/*String*/ by){
		if(this.disabled || this.readOnly){ return; }

		// Select all text on focus via click if nothing already selected.
		// Since mouse-up will clear the selection need to defer selection until after mouse-up.
		// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
		if(this.selectOnClick && by == "mouse"){
			this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
				// Only select all text on first click; otherwise users would have no way to clear
				// the selection.
				this.disconnect(this._selectOnClickHandle);

				// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
				// and if not, then select all the text
				if(this._isTextSelected()){
					_TextBoxMixin.selectInputText(this.textbox);
				}
			});
		}
		// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
		// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
		this.inherited(arguments);

		this._refreshState();
	},

	reset: function(){
		// Overrides dijit._FormWidget.reset().
		// Additionally resets the displayed textbox value to ''
		this.textbox.value = '';
		this.inherited(arguments);
	},
	_setTextDirAttr: function(/*String*/ textDir){
		// summary:
		//		Setter for textDir.
		// description:
		//		Users shouldn't call this function; they should be calling
		//		set('textDir', value)
		// tags:
		//		private

		// only if new textDir is different from the old one
		// and on widgets creation.
		if(!this._created
			|| this.textDir != textDir){
				this._set("textDir", textDir);
				// so the change of the textDir will take place immediately.
				this.applyTextDir(this.focusNode, this.focusNode.value);
		}
	}
});


_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	if(element.setSelectionRange){
		element.setSelectionRange(start, stop);
	}
};

_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	element = dom.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	try{
		element.focus();
		_TextBoxMixin._setSelectionRange(element, start, stop);
	}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */ }
};

return _TextBoxMixin;
});

},
'dijit/a11y':function(){
define("dijit/a11y", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/config", // defaultDuration
	"dojo/_base/declare", // declare
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // style.style
	"dojo/_base/sniff", // has("ie")
	"./_base/manager",	// manager._isElementShown
	"."	// for exporting methods to dijit namespace
], function(array, config, declare, dom, domAttr, domStyle, has, manager, dijit){

	// module:
	//		dijit/a11y
	// summary:
	//		Accessibility utility functions (keyboard, tab stops, etc.)

	var shown = (dijit._isElementShown = function(/*Element*/ elem){
		var s = domStyle.get(elem);
		return (s.visibility != "hidden")
			&& (s.visibility != "collapsed")
			&& (s.display != "none")
			&& (domAttr.get(elem, "type") != "hidden");
	});

	dijit.hasDefaultTabStop = function(/*Element*/ elem){
		// summary:
		//		Tests if element is tab-navigable even without an explicit tabIndex setting

		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return domAttr.has(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				var body;
				try{
					// non-IE
					var contentDocument = elem.contentDocument;
					if("designMode" in contentDocument && contentDocument.designMode == "on"){
						return true;
					}
					body = contentDocument.body;
				}catch(e1){
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						body = elem.contentWindow.document.body;
					}catch(e2){
						return false;
					}
				}
				return body && (body.contentEditable == 'true' ||
					(body.firstChild && body.firstChild.contentEditable == 'true'));
			default:
				return elem.contentEditable == 'true';
		}
	};

	var isTabNavigable = (dijit.isTabNavigable = function(/*Element*/ elem){
		// summary:
		//		Tests if an element is tab-navigable

		// TODO: convert (and rename method) to return effective tabIndex; will save time in _getTabNavigable()
		if(domAttr.get(elem, "disabled")){
			return false;
		}else if(domAttr.has(elem, "tabIndex")){
			// Explicit tab index setting
			return domAttr.get(elem, "tabIndex") >= 0; // boolean
		}else{
			// No explicit tabIndex setting, so depends on node type
			return dijit.hasDefaultTabStop(elem);
		}
	});

	dijit._getTabNavigable = function(/*DOMNode*/ root){
		// summary:
		//		Finds descendants of the specified root node.
		//
		// description:
		//		Finds the following descendants of the specified root node:
		//		* the first tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the last tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the first element in document order with the lowest
		//		  positive tabIndex value
		//		* the last element in document order with the highest
		//		  positive tabIndex value
		var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

		function radioName(node){
			// If this element is part of a radio button group, return the name for that group.
			return node && node.tagName.toLowerCase() == "input" &&
				node.type && node.type.toLowerCase() == "radio" &&
				node.name && node.name.toLowerCase();
		}

		var walkTree = function(/*DOMNode*/parent){
			for(var child = parent.firstChild; child; child = child.nextSibling){
				// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
				// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
				if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
					continue;
				}

				if(isTabNavigable(child)){
					var tabindex = domAttr.get(child, "tabIndex");
					if(!domAttr.has(child, "tabIndex") || tabindex == 0){
						if(!first){
							first = child;
						}
						last = child;
					}else if(tabindex > 0){
						if(!lowest || tabindex < lowestTabindex){
							lowestTabindex = tabindex;
							lowest = child;
						}
						if(!highest || tabindex >= highestTabindex){
							highestTabindex = tabindex;
							highest = child;
						}
					}
					var rn = radioName(child);
					if(domAttr.get(child, "checked") && rn){
						radioSelected[rn] = child;
					}
				}
				if(child.nodeName.toUpperCase() != 'SELECT'){
					walkTree(child);
				}
			}
		};
		if(shown(root)){
			walkTree(root);
		}
		function rs(node){
			// substitute checked radio button for unchecked one, if there is a checked one with the same name.
			return radioSelected[radioName(node)] || node;
		}

		return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
	};
	dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is first in the tabbing order
		var elems = dijit._getTabNavigable(dom.byId(root));
		return elems.lowest ? elems.lowest : elems.first; // DomNode
	};

	dijit.getLastInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is last in the tabbing order
		var elems = dijit._getTabNavigable(dom.byId(root));
		return elems.last ? elems.last : elems.highest; // DomNode
	};

	return {
		hasDefaultTabStop: dijit.hasDefaultTabStop,
		isTabNavigable: dijit.isTabNavigable,
		_getTabNavigable: dijit._getTabNavigable,
		getFirstInTabbingOrder: dijit.getFirstInTabbingOrder,
		getLastInTabbingOrder: dijit.getLastInTabbingOrder
	};
});

},
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n",
'dijit/form/TextBox':function(){
require({cache:{
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"}});
define("dijit/form/TextBox", [
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/sniff", // has("ie") has("mozilla")
	"dojo/_base/window", // win.doc.selection.createRange
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	".."	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, has, win,
			_FormValueWidget, _TextBoxMixin, template, dijit){

/*=====
	var _FormValueWidget = dijit.form._FormValueWidget;
	var _TextBoxMixin = dijit.form._TextBoxMixin;
=====*/

	// module:
	//		dijit/form/TextBox
	// summary:
	//		A base class for textbox form inputs

	var TextBox = declare(/*====="dijit.form.TextBox", =====*/ [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		_onInput: function(e){
			this.inherited(arguments);
			if(this.intermediateChanges){ // _TextBoxMixin uses onInput
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.get('value'), false); }, 0);
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				// dijitInputField class gives placeHolder same padding as the input field
				// parent node already has dijitInputField class but it doesn't affect this <span>
				// since it's position: absolute.
				this._phspan = domConstruct.create('span',{ onmousedown:function(e){ e.preventDefault(); }, className:'dijitPlaceHolder dijitInputField'},this.textbox,'after');
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(document.createTextNode(v));
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display=(this.placeHolder&&!this.focused&&!this.textbox.value)?"":"none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use set('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie")){
		TextBox = declare(/*===== "dijit.form.TextBox.IEMixin", =====*/ TextBox, {
			declaredClass: "dijit.form.TextBox",	// for user code referencing declaredClass

			_isTextSelected: function(){
				var range = win.doc.selection.createRange();
				var parent = range.parentElement();
				return parent == this.textbox && range.text.length == 0;
			},

			postCreate: function(){
				this.inherited(arguments);
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the setTimeout gives IE a chance to render the TextBox and to deal with font inheritance
				setTimeout(lang.hitch(this, function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
						shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				}), 0);
			}
		});

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}else if(has("mozilla")){
		TextBox = declare(/*===== "dijit.form.TextBox.MozMixin", =====*/TextBox, {
			declaredClass: "dijit.form.TextBox",	// for user code referencing declaredClass

			_onBlur: function(e){
				this.inherited(arguments);
				if(this.selectOnClick){
						// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		});
	}else{
		TextBox.prototype.declaredClass = "dijit.form.TextBox";
	}
	lang.setObject("dijit.form.TextBox", TextBox);	// don't do direct assignment, it confuses API doc parser

	return TextBox;
});

},
'cwtk/util/FormHandler':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("cwtk/util/FormHandler", [
    "dojo", 
    "dojo/_base/declare",
    "dojo/_base/connect"
], function(dojo, declare, connect){

		return declare("cwtk.util.FormHandler", null, {
        
            _updateStack: new Array(),
            
            addUpdateListener: function(listener) {
                this._updateStack.push(listener);
            },
            
            clearUpdateListeners: function() {
                this._updateStack = new Array(); //clear stack for next execution
            },
            
            notifyUpdateListeners: function() {
                var listener = null;
                while (listener = this._updateStack.pop()) {
                    try {
                        listener();
                    } catch(e) {
                        console.log(e);
                    }
                }
                
            },
            
            /*
             * Load fragment and register next page form.
             * 
             */
            load : function(pane, pageID, params) {
                var cp = this._getContentPane(pane);
                dojo.addOnLoad(function(){
                    cw.fragment.get({
                        targetID : cp.id,
                        pageID : pageID,
                        params : params,
                        onLoad : function(data) {
                            console.log(data);
                        }
                    });
                });
            },
            
            /*
             * Dismiss function.
             * In case of background panel, return to page through transitions.
             * In case of modal dialog, close the window.
             * Otherwise, do nothing.
             */
            dismiss : function(node) {
                this._dismissNode(node);
                this.clearUpdateListeners();
            },
             
            dismissUpdate : function(node) {
                this._dismissNode(node);
                this.notifyUpdateListeners();
            }, 
                       
            _dismissNode : function(node) {
                if(node.domNode) {
                    node = node.domNode;
                }
                connect.publish("cw_dismiss", {node:node});
            },
            
            _getForm : function(node) {
                if (node.domNode) {
                    node = node.domNode;
                }
                return dojo.query(node).parents("form")[0];
            },
            
            _getContentPane : function(node) {
                var form = this._getForm(node);
                return dojo.query(form).parents(".dijitContentPane")[0];
            }
            
        });

});
},
'idx/oneui/form/_FocusManager':function(){
define("idx/oneui/form/_FocusManager", [
	"dijit/focus",
	"dojo/_base/window",
	"dojo/window",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr",
	"dojo/dom-class",
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend	
	"dijit/registry"
], function(focus, win, winUtils, dom, domAttr, domClass, declare, lang, registry){
	focus._onTouchNode = function(/*DomNode*/ node, /*String*/ by){
		var srcNode = node;
		if(this._clearActiveWidgetsTimer){
			clearTimeout(this._clearActiveWidgetsTimer);
			delete this._clearActiveWidgetsTimer;
		}
		var newStack=[];
		try{
			while(node){
				var popupParent = domAttr.get(node, "dijitPopupParent");
				if(popupParent){
					node=registry.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					if(node === win.body()){
						break;
					}
					node=winUtils.get(node.ownerDocument).frameElement;
				}else{
					var id = node.getAttribute && node.getAttribute("widgetId"),
						widget = id && registry.byId(id);
					if(widget && !(by == "mouse" && widget.get("disabled"))){
						if(!widget._isValidFocusNode || widget._isValidFocusNode(srcNode)){
							newStack.unshift(id);
						}
					}
					node=node.parentNode;
				}
			}
		}catch(e){}
		this._setStack(newStack, by);
	}
	return focus;
});

},
'dijit/layout/StackContainer':function(){
define("dijit/layout/StackContainer", [
	"dojo/_base/array", // array.forEach array.indexOf array.some
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/_base/kernel",	// kernel.isAsync
	"dojo/_base/lang",	// lang.extend
	"dojo/ready",
	"dojo/topic", // publish
	"../registry",	// registry.byId
	"../_WidgetBase",
	"./_LayoutWidget",
	"dojo/i18n!../nls/common"
], function(array, cookie, declare, domClass, kernel, lang, ready, topic,
			registry, _WidgetBase, _LayoutWidget){

/*=====
var _WidgetBase = dijit._WidgetBase;
var _LayoutWidget = dijit.layout._LayoutWidget;
var StackController = dijit.layout.StackController;
=====*/

// module:
//		dijit/layout/StackContainer
// summary:
//		A container that has multiple children, but shows only one child at a time.

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/layout/StackController"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
lang.extend(_WidgetBase, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "dijitNoIcon",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true
});

return declare("dijit.layout.StackContainer", _LayoutWidget, {
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	buildRendering: function(){
		this.inherited(arguments);
		domClass.add(this.domNode, "dijitLayoutContainer");
		this.containerNode.setAttribute("role", "tabpanel");
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		array.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
		}else{
			array.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		topic.publish(this.id+"-startup", {children: children, selected: selected});

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible). If this is the first time we've been made
		// visible then show our first child.
		if(!this._hasBeenShown){
			this._hasBeenShown = true;
			var selected = this.selectedChildWidget;
			if(selected){
				this._showChild(selected);
			}
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		domClass.replace(child.domNode, "dijitHidden", "dijitVisible");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			topic.publish(this.id+"-addChild", child, insertIndex);	// publish

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild().
			// If this is updated to not layout [except for initial child added / last child removed], update
			// "childless startup" test in StackContainer.html to check for no resize event after second addChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			topic.publish(this.id + "-removeChild", page);	// publish
		}

		// If all our children are being destroyed than don't run the code below (to select another page),
		//  because we are deleting every page one by one
		if(this._descendantsBeingDestroyed){ return; }

		// Select new page to display, also updating TabController to show the respective tab.
		// Do this before layout call because it can affect the height of the TabController.
		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}

		if(this._started){
			// In case the tab titles now take up one line instead of two lines
			// (note though that ScrollingTabController never overflows to multiple lines),
			// or the height has changed slightly because of addition/removal of tab which close icon
			this.layout();
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page, /*Boolean*/ animate){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = registry.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			var d = this._transition(page, this.selectedChildWidget, animate);
			this._set("selectedChildWidget", page);
			topic.publish(this.id+"-selectChild", page);	// publish

			if(this.persist){
				cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}

		return d;		// If child has an href, promise that fires when the child's href finishes loading
	},

	_transition: function(newWidget, oldWidget /*===== ,  animate =====*/){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// newWidget: dijit._Widget
		//		The newly selected widget.
		// oldWidget: dijit._Widget
		//		The previously selected widget.
		// animate: Boolean
		//		Used by AccordionContainer to turn on/off slide effect.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		var d = this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}

		return d;	// If child has an href, promise that fires when the child's href finishes loading
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = array.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		return this.selectChild(this._adjacent(true), true);
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		return this.selectChild(this._adjacent(false), true);
	},

	_onKeyPress: function(e){
		topic.publish(this.id+"-containerKeyPress", { e: e, page: this});	// publish
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		var child = this.selectedChildWidget;
		if(child && child.resize){
			if(this.doLayout){
				child.resize(this._containerContentBox || this._contentBox);
			}else{
				child.resize();
			}
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		// returns:
		//		Promise that fires when page has finished showing, or true if there's no href
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page._set("selected", true);

		domClass.replace(page.domNode, "dijitVisible", "dijitHidden");

		return (page._onShow && page._onShow()) || true;
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page._set("selected", false);
		domClass.replace(page.domNode, "dijitHidden", "dijitVisible");

		page.onHide && page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		this._descendantsBeingDestroyed = true;
		this.selectedChildWidget = undefined;
		array.forEach(this.getChildren(), function(child){
			if(!preserveDom){
				this.removeChild(child);
			}
			child.destroyRecursive(preserveDom);
		}, this);
		this._descendantsBeingDestroyed = false;
	}
});

});

},
'dijit/form/_RadioButtonMixin':function(){
define("dijit/form/_RadioButtonMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/event", // event.stop
	"dojo/_base/lang", // lang.hitch
	"dojo/query", // query
	"dojo/_base/window", // win.doc
	"../registry"	// registry.getEnclosingWidget
], function(array, declare, domAttr, event, lang, query, win, registry){

	// module:
	//		dijit/form/_RadioButtonMixin
	// summary:
	// 		Mixin to provide widget functionality for an HTML radio button

	return declare("dijit.form._RadioButtonMixin", null, {
		// summary:
		// 		Mixin to provide widget functionality for an HTML radio button

		// type: [private] String
		//		type attribute on <input> node.
		//		Users should not change this value.
		type: "radio",

		_getRelatedWidgets: function(){
			// Private function needed to help iterate over all radio buttons in a group.
			var ary = [];
			query("input[type=radio]", this.focusNode.form || win.doc).forEach( // can't use name= since query doesn't support [] in the name
				lang.hitch(this, function(inputNode){
					if(inputNode.name == this.name && inputNode.form == this.focusNode.form){
						var widget = registry.getEnclosingWidget(inputNode);
						if(widget){
							ary.push(widget);
						}
					}
				})
			);
			return ary;
		},

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					if(widget != this && widget.checked){
						widget.set('checked', false);
					}
				}));
			}
		},

		_onClick: function(/*Event*/ e){
			if(this.checked || this.disabled){ // nothing to do
				event.stop(e);
				return false;
			}
			if(this.readOnly){ // ignored by some browsers so we have to resync the DOM elements with widget values
				event.stop(e);
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					domAttr.set(this.focusNode || this.domNode, 'checked', widget.checked);
				}));
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'curam/util/external':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

  /*
   * Modification History
   * --------------------
   * 25-Mar-2014 MV  [CR00423311] Initial version.  
   */
define("curam/util/external", ['curam/util'
        ], function(util) {
  
  /**
   * @name curam.util.external
   * @namespace Contains functions of general use for the external application
   *    container.
   */
  curam.define.singleton("curam.util.external",
  /**
   * @lends curam.util.external.prototype
   */
  {
    /**
     * Determines whether we are running within an external application
     * container or not.
     * 
     * @return True if we are in external app container, otherwise false.
     */
    inExternalApp: function() {
      return jsScreenContext.hasContextBits("EXTAPP");
    },
    
    /**
     * Determines the iframe to be used as parent for a UIM modal dialog.
     * 
     * @returns iframe or null.
     */
    getUimParentWindow: function() {
      if (util.getTopmostWindow() === dojo.global) {
        return null;

      } else {
        return dojo.global;
      }
    }
  });

  return curam.util.external;
});

},
'idx/oneui/HoverHelpTooltip':function(){
require({cache:{
'url:idx/oneui/templates/HoverHelpTooltip.html':"<div class=\"idxOneuiHoverHelpTooltip idxOneuiHoverHelpTooltipLeft\" role=\"dialog\"\r\n\t><div role=\"document\"\r\n\t\t><span data-dojo-attach-point=\"closeButtonNode\" class=\"idxOneuiHoverHelpTooltipCloseIcon\" data-dojo-attach-event=\"ondijitclick: hideOnClickClose\" role=\"button\" tabIndex=\"0\"></span\r\n\t></div\r\n\t><div data-dojo-attach-point=\"outerContainerNode\" class=\"idxOneuiHoverHelpTooltipContainer idxOneuiHoverHelpTooltipContents\"\r\n\t\t><div data-dojo-attach-point=\"containerNode\" role=\"document\" tabindex=0></div\r\n\t\t><a target=\"_blank\" href=\"#updateme\" class=\"idxOneuiHoverHelpTooltipLearnLink\" data-dojo-attach-point=\"learnMoreNode\"><span>${learnMoreLabel}</span></a\r\n\t></div\r\n\t><div class=\"idxOneuiHoverHelpTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\r\n></div>"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("idx/oneui/HoverHelpTooltip", ["dojo/_base/declare", "dojo/_base/fx", // fx.fadeIn fx.fadeOut
 "dojo/keys", // keys
 "dojo/_base/array", // array.forEach array.indexOf array.map
 "dojo/dom", // dom.byId
 "dojo/_base/lang", // lang.hitch lang.isArrayLike
 "dojo/_base/sniff", // has("ie")
 "dijit/focus", "dojo/_base/event", // event.stop
 "dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
 "dijit/place", "dijit/a11y", // _getTabNavigable
 "dijit/BackgroundIframe", "dojo/dom-style", // domStyle.set, domStyle.get
 "dojo/_base/window", // win.body
 "dijit/_base/manager", // manager.defaultDuration
 "dijit/_Widget", "dijit/_TemplatedMixin", "dijit/Tooltip", "dojo/text!./templates/HoverHelpTooltip.html", "dijit/dijit", "dojo/i18n", "dojo/i18n!./nls/HoverHelpTooltip"], function(declare, fx, keys, array, dom, lang, has, dijitfocus, event, domGeometry, place, a11y, BackgroundIframe, domStyle, win, manager, _Widget, _TemplatedMixin, Tooltip, template, dijit, i18n){
    /**
     * @name idx.oneui.HoverHelpTooltip
     * @class HoverHelpTooltip provides pop-up information that displays when users hover the mouse pointer over an help indicator.
     * HoverHelpTooltip is implemented following the standard and specified IBM One UI(tm)
     * <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y20&vsub=*&hsub=*&openpanes=1111111111">Hover Help</a></b>
     * @augments dijit.Tooltip
     * @example
     &lt;span data-dojo-type="idx.oneui.HoverHelpTooltip" data-dojo-props='
     connectId:["anchor"],
     forceFocus: true,
     showLearnMore:true,
     learnMoreLinkValue:"http://www.ibm.com"'
     style="width: 300px"&gt;
     Passwords must be between 5 and 20 characters. There must be a combination of alphanumeric characters, starting with a letter and at least one number.&lt;br /&gt;&lt;br /&gt;
     &lt;/span&gt;
     * @see dijit.Tooltip
     **/
    var HoverHelpTooltip = declare("idx.oneui.HoverHelpTooltip", Tooltip, {
        /** @lends idx.oneui.HoverHelpTooltip.prototype */
         showDelay: 500,
        hideDelay: 800,
        /**
         * Whether to show Learn more link
         * @type Boolean
         */
        showLearnMore: false,
        /**
         * Learn more link value
         * @type String
         */
        learnMoreLinkValue: "#updateme",
        
        showCloseIcon: true,
        /**
         * Focus HoverHelpTooltip once it shown.
         * @type Boolean
         */
        forceFocus: true,
        
        _onHover: function(/*Event*/e){
            // summary:
            //		Despite the name of this method, it actually handles both hover and focus
            //		events on the target node, setting a timer to show the HoverHelpTooltip.
            // tags:
            //		private
            if (!HoverHelpTooltip._showTimer) {
                var target = e.target;
                HoverHelpTooltip._showTimer = setTimeout(lang.hitch(this, function(){
                    this.open(target)
                }), this.showDelay);
            }
            if (HoverHelpTooltip._hideTimer) {
                clearTimeout(HoverHelpTooltip._hideTimer);
                delete HoverHelpTooltip._hideTimer;
            }
        },
        
        _onUnHover: function(/*Event*/ /*===== e =====*/){
            // summary:
            //		Despite the name of this method, it actually handles both mouseleave and blur
            //		events on the target node, hiding the HoverHelpTooltip.
            // tags:
            //		private
            
            // keep a HoverHelpTooltip open if the associated element still has focus (even though the
            // mouse moved away)
            if (HoverHelpTooltip._showTimer) {
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
            if (!HoverHelpTooltip._hideTimer) {
                HoverHelpTooltip._hideTimer = setTimeout(lang.hitch(this, function(){
                    this.close()
                }), this.hideDelay);
            }
        },
        
        /**
         * Display the HoverHelpTooltip
         * @private
         */
        open: function(/*DomNode*/target){
            // summary:
            //		
            // tags:
            //		private
            if (HoverHelpTooltip._showTimer) {
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
            HoverHelpTooltip.show(
				this.label || this.domNode.innerHTML, 
				target, this.position, !this.isLeftToRight(), 
				this.textDir, this.showLearnMore, this.learnMoreLinkValue, 
				this.showCloseIcon, this.forceFocus);
            this._connectNode = target;
            this.onShow(target, this.position);
        },
		
        close: function(){
            // summary:
            //		Hide the tooltip or cancel timer for show of tooltip
            // tags:
            //		private
            if (this._connectNode) {
                // if tooltip is currently shown
                HoverHelpTooltip.hide(this._connectNode);
                delete this._connectNode;
                this.onHide();
            }
            if (HoverHelpTooltip._showTimer) {
                // if tooltip is scheduled to be shown (after a brief delay)
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
        },
        _setConnectIdAttr: function(/*String|String[]*/newId){
            // summary:
            //		Connect to specified node(s)
            
            // Remove connections to old nodes (if there are any)
            array.forEach(this._connections || [], function(nested){
                array.forEach(nested, lang.hitch(this, "disconnect"));
            }, this);
            
            // Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
            this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []), function(id){
                return dom.byId(id);
            });
            
            // Make connections
            this._connections = array.map(this._connectIds, function(id){
                var node = dom.byId(id);
                return [
					this.connect(node, "onmouseenter", "_onHover"),
					this.connect(node, "onmouseleave", "_onUnHover"), 
					this.connect(node, "onclick", "_onHover"),
					this.connect(node, "onkeypress", "_onConnectIdKey")
				];
            }, this);
            
            this._set("connectId", newId);
        },
        _onConnectIdKey: function(/*Event*/evt){
            // summary:
            //		Handler for keyboard events
            // description:
            // tags:
            //		private
            var node = evt.target;
            
            if (evt.charOrCode == keys.ENTER || evt.charOrCode == keys.SPACE || evt.charOrCode == " " || evt.charOrCode == keys.F1) {
                // Use setTimeout to avoid crash on IE, see #10396.
                HoverHelpTooltip._showTimer = setTimeout(lang.hitch(this, function(){
                    this.open(node)
                }), this.showDelay);
                
                event.stop(evt);
            }
        }
        
    });
    
    var MasterHoverHelpTooltip = declare("idx.oneui._MasterHoverHelpTooltip", [_Widget, _TemplatedMixin], {
		/**
		 * Milliseconds to fade in/fade out
		 * @type Integer
		 */
        duration: manager.defaultDuration,
        
        templateString: template,
		
        learnMoreLabel: "",
        
        /**
         * draggable: Boolean
         *		Toggles the moveable aspect of the HoverHelpTooltip. If true, HoverHelpTooltip
         *		can be dragged by it's grippy bar. If false it will remain positioned
         *		relative to the attached node
         *		@type boolean
         **/
        draggable: true,
        
        _firstFocusItem: null,
		
        _lastFocusItem: null,
        
        postMixInProperties: function(){
            this.learnMoreLabel = i18n.getLocalization("idx.oneui", "HoverHelpTooltip", this.lang).learnMoreLabel;
        },
        postCreate: function(){
            win.body().appendChild(this.domNode);
            
            this.bgIframe = new BackgroundIframe(this.domNode);
            
            // Setup fade-in and fade-out functions.
            this.fadeIn = fx.fadeIn({
                node: this.domNode,
                duration: this.duration,
                onEnd: lang.hitch(this, "_onShow")
            });
            this.fadeOut = fx.fadeOut({
                node: this.domNode,
                duration: this.duration,
                onEnd: lang.hitch(this, "_onHide")
            });
            this.connect(this.domNode, "onkeypress", "_onKey");
            this.connect(this.domNode, "onmouseenter", lang.hitch(this, function(e){
				if(HoverHelpTooltip._hideTimer) {
	                clearTimeout(HoverHelpTooltip._hideTimer);
	                delete HoverHelpTooltip._hideTimer;
	            }
				this.focus();
                this._keepShowing = true;
				this.fadeOut.stop();
				this.fadeIn.play();
            }));
			this.connect(this.domNode, "onmouseleave", lang.hitch(this, function(e){
				this._keepShowing = false;
				HoverHelpTooltip._hideTimer = setTimeout(lang.hitch(this, function(){this.hide(this.aroundNode)}), 800);
			}));
        },
        show: function(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, learnMoreLinkValue, showCloseIcon, forceFocus){
			this._lastFocusNode = dijitfocus.curNode;
            if (showLearnMore) {
                this.learnMoreNode.style.display = "inline";
                this.learnMoreNode.href = learnMoreLinkValue;
            }
            else {
                this.learnMoreNode.style.display = "none";
            }
            if (showCloseIcon || showCloseIcon == null) 
                this.closeButtonNode.style.display = "inline";
            else {
                this.closeButtonNode.style.display = "none";
            }
            //in case connectorNode was hidden on a previous call to hide
            this.connectorNode.hidden = false;
            
            if (this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML) {
                return;
            }
            
            
            // reset width; it may have been set by orient() on a previous HoverHelpTooltip show()
            this.domNode.width = "auto";
            
            if (this.fadeOut.status() == "playing") {
                // previous HoverHelpTooltip is being hidden; wait until the hide completes then show new one
                this._onDeck = arguments;
                return;
            }
            
            this.containerNode.innerHTML = innerHTML;
            
            this.set("textDir", textDir);
            this.containerNode.align = rtl ? "right" : "left"; //fix the text alignment
            var pos = place.around(this.domNode, aroundNode, position && position.length ? position : HoverHelpTooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));
            
            // Position the HoverHelpTooltip connector for middle alignment.
            // This could not have been done in orient() since the HoverHelpTooltip wasn't positioned at that time.
            var aroundNodeCoords = pos.aroundNodePos;
            if (pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M') {
                this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
                this.connectorNode.style.left = "";
            }
            else 
                if (pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M') {
                    this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
                }
            // show it
            domStyle.set(this.domNode, "opacity", 0);
            this.fadeIn.play();
            this.isShowingNow = true;
            this.aroundNode = aroundNode;
			if (forceFocus) {
                this.focus();
            }
        },
        
        
        orient: function(/*DomNode*/node, /*String*/ aroundCorner, /*String*/ HoverHelpTooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
            // summary:
            //		Private function to set CSS for HoverHelpTooltip node based on which position it's in.
            //		This is called by the dijit popup code.   It will also reduce the HoverHelpTooltip's
            //		width to whatever width is available
            // tags:
            //		protected
            this.connectorNode.style.top = ""; //reset to default
            //Adjust the spaceAvailable width, without changing the spaceAvailable object
            var HoverHelpTooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;
            
            node.className = "idxOneuiHoverHelpTooltip " +
            {
                "MR-ML": "idxOneuiHoverHelpTooltipRight",
                "ML-MR": "idxOneuiHoverHelpTooltipLeft",
                "TM-BM": "idxOneuiHoverHelpTooltipAbove",
                "BM-TM": "idxOneuiHoverHelpTooltipBelow",
                "BL-TL": "idxOneuiHoverHelpTooltipBelow idxOneuiHoverHelpTooltipABLeft",
                "TL-BL": "idxOneuiHoverHelpTooltipAbove idxOneuiHoverHelpTooltipABLeft",
                "BR-TR": "idxOneuiHoverHelpTooltipBelow idxOneuiHoverHelpTooltipABRight",
                "TR-BR": "idxOneuiHoverHelpTooltipAbove idxOneuiHoverHelpTooltipABRight",
                "BR-BL": "idxOneuiHoverHelpTooltipRight",
                "BL-BR": "idxOneuiHoverHelpTooltipLeft",
                "TR-TL": "idxOneuiHoverHelpTooltipRight"
            }[aroundCorner + "-" + HoverHelpTooltipCorner];
            
            // reduce HoverHelpTooltip's width to the amount of width available, so that it doesn't overflow screen
            this.domNode.style.width = "auto";
            var size = domGeometry.getContentBox(this.domNode);
            
            var width = Math.min((Math.max(HoverHelpTooltipSpaceAvaliableWidth, 1)), size.w);
            var widthWasReduced = width < size.w;
            
            this.domNode.style.width = width + "px";
            
            //Adjust width for HoverHelpTooltips that have a really long word or a nowrap setting
            if (widthWasReduced) {
                this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our HoverHelpTooltip needs to be wider to support the content
                var scrollWidth = this.containerNode.scrollWidth;
                this.containerNode.style.overflow = "visible"; //change it back
                if (scrollWidth > width) {
                    scrollWidth = scrollWidth + domStyle.get(this.domNode, "paddingLeft") + domStyle.get(this.domNode, "paddingRight");
                    this.domNode.style.width = scrollWidth + "px";
                }
            }
            
            // Reposition the HoverHelpTooltip connector.
            if (HoverHelpTooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B') {
                var mb = domGeometry.getMarginBox(node);
                var HoverHelpTooltipConnectorHeight = this.connectorNode.offsetHeight;
                if (mb.h > spaceAvailable.h) {
                    // The HoverHelpTooltip starts at the top of the page and will extend past the aroundNode
                    var aroundNodePlacement = spaceAvailable.h - ((aroundNodeCoords.h + HoverHelpTooltipConnectorHeight) >> 1);
                    this.connectorNode.style.top = aroundNodePlacement + "px";
                    this.connectorNode.style.bottom = "";
                }
                else {
                    // Align center of connector with center of aroundNode, except don't let bottom
                    // of connector extend below bottom of HoverHelpTooltip content, or top of connector
                    // extend past top of HoverHelpTooltip content
                    this.connectorNode.style.bottom = Math.min(Math.max(aroundNodeCoords.h / 2 - HoverHelpTooltipConnectorHeight / 2, 0), mb.h - HoverHelpTooltipConnectorHeight) +
                    "px";
                    this.connectorNode.style.top = "";
                }
            }
            else {
                // reset the HoverHelpTooltip back to the defaults
                this.connectorNode.style.top = "";
                this.connectorNode.style.bottom = "";
            }
            
            return Math.max(0, size.w - HoverHelpTooltipSpaceAvaliableWidth);
        },
        
        focus: function(){
			if(this._focus){return;}
            this._getFocusItems(this.outerContainerNode);
            this._focus = true;
            dijitfocus.focus(this._firstFocusItem);
        },
        
        _onShow: function(){
            // summary:
            //		Called at end of fade-in operation
            // tags:
            //		protected
            if (has("ie")) {
                // the arrow won't show up on a node w/an opacity filter
                this.domNode.style.filter = "";
            }
        },
        
        hide: function(aroundNode){
            // summary:
            //		Hide the HoverHelpTooltip
            if(this._keepShowing){this._keepShowing = false; return;}
            if (this._onDeck && this._onDeck[1] == aroundNode) {
            
                // this hide request is for a show() that hasn't even started yet;
                // just cancel the pending show()
                this._onDeck = null;
            }
            else if(this.aroundNode === aroundNode || this.isShowingNow){
                    // this hide request is for the currently displayed HoverHelpTooltip
                    this._forceHide();
                }
        },
        hideOnClickClose: function(){
            // summary:
            //		Hide the HoverHelpTooltip
            // this hide request is for the currently displayed HoverHelpTooltip            
            this._forceHide();
        },
        _forceHide: function(){
            dijitfocus.focus(this._lastFocusNode);
			this._lastFocusNode = null;
			this._firstFocusItem = null;
			this._lastFocusItem = null;
            this._focus = false;
            this.fadeIn.stop();
            this.isShowingNow = false;
            this.fadeOut.play();
        },
        _getFocusItems: function(){
            // summary:
            //		Finds focusable items in dialog,
            //		and sets this._firstFocusItem and this._lastFocusItem
            // tags:
            //		protected
			if(this._firstFocusItem){
				this._firstFocusItem = this.closeButtonNode;
				return;
			}
			this._firstFocusItem = this.containerNode;
			if(domStyle.get(this.learnMoreNode, "display") == "none"){
				var elems = a11y._getTabNavigable(this.containerNode);
				this._lastFocusItem = elems.last || elems.highest || this.containerNode;
			}else{
				this._lastFocusItem = this.learnMoreNode;
			}
        },
        _onKey: function(/*Event*/evt){
            // summary:
            //		Handler for keyboard events
            // description:
            // tags:
            //		private
            
            var node = evt.target;
            if (evt.charOrCode === keys.TAB) {
                this._getFocusItems(this.outerContainerNode);
            }
            var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
            if (evt.charOrCode == keys.ESCAPE) {
                // Use setTimeout to avoid crash on IE, see #10396.
                setTimeout(lang.hitch(this, "hideOnClickClose"), 0);
                event.stop(evt);
            }
            else 
                if (node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB) {
                    if (!singleFocusItem) {
                        dijitfocus.focus(this._lastFocusItem); // send focus to last item in dialog
                    }
                    event.stop(evt);
                }
                else 
                    if (node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey) {
                        if (!singleFocusItem) {
                            dijitfocus.focus(this._firstFocusItem); // send focus to first item in dialog
                        }
                        event.stop(evt);
                    }
                    else 
                        if (evt.charOrCode === keys.TAB) {
                            // we want the browser's default tab handling to move focus
                            // but we don't want the tab to propagate upwards
                            evt.stopPropagation();
                        }
        },
        _onHide: function(){
            // summary:
            //		Called at end of fade-out operation
            // tags:
            //		protected
            
            this.domNode.style.cssText = ""; // to position offscreen again
            this.containerNode.innerHTML = "";
            if (this._onDeck) {
                // a show request has been queued up; do it now
                this.show.apply(this, this._onDeck);
                this._onDeck = null;
            }
			this.aroundNode = null;
        },
        onBlur: function(){
            this._forceHide();
        },
        _setAutoTextDir: function(/*Object*/node){
            // summary:
            //	    Resolve "auto" text direction for children nodes
            // tags:
            //		private
            
            this.applyTextDir(node, has("ie") ? node.outerText : node.textContent);
            array.forEach(node.children, function(child){
                this._setAutoTextDir(child);
            }, this);
        },
        
        _setTextDirAttr: function(/*String*/textDir){
            // summary:
            //		Setter for textDir.
            // description:
            //		Users shouldn't call this function; they should be calling
            //		set('textDir', value)
            // tags:
            //		private
            
            this._set("textDir", typeof textDir != 'undefined' ? textDir : "");
            if (textDir == "auto") {
                this._setAutoTextDir(this.containerNode);
            }
            else {
                this.containerNode.dir = this.textDir;
            }
        }
    }); //end declare
    //    var MasterHoverHelpTooltip = Tooltip._MasterTooltip;
    
    HoverHelpTooltip._MasterHoverHelpTooltip = MasterHoverHelpTooltip; // for monkey patching
    // summary:
    //		Static method to display HoverHelpTooltip w/specified contents in specified position.
    //		See description of idx.oneui.HoverHelpTooltip.defaultPosition for details on position parameter.
    //		If position is not specified then idx.oneui.HoverHelpTooltip.defaultPosition is used.
    // innerHTML: String
    //		Contents of the HoverHelpTooltip
    // aroundNode: dijit.__Rectangle
    //		Specifies that HoverHelpTooltip should be next to this node / area
    // position: String[]?
    //		List of positions to try to position HoverHelpTooltip (ex: ["right", "above"])
    // rtl: Boolean?
    //		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
    //		means "rtl"; specifies GUI direction, not text direction.
    // textDir: String?
    //		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.	
    HoverHelpTooltip.show = idx.oneui.showHoverHelpTooltip = function(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, learnMoreLinkValue, showCloseIcon, forceFocus){
    
        if (!HoverHelpTooltip._masterTT) {
            idx.oneui._masterTT = HoverHelpTooltip._masterTT = new MasterHoverHelpTooltip();
        }
        return HoverHelpTooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, learnMoreLinkValue, showCloseIcon, forceFocus);
    };
    
    // summary:
    //		Static method to hide the HoverHelpTooltip displayed via showHoverHelpTooltip()
    HoverHelpTooltip.hide = idx.oneui.hideHoverHelpTooltip = function(aroundNode){
    
        return HoverHelpTooltip._masterTT && HoverHelpTooltip._masterTT.hide(aroundNode);
    };
    
    HoverHelpTooltip.defaultPosition = ["after-centered", "before-centered", "below", "above"];
    
    
    return HoverHelpTooltip;
});

},
'dojox/storage/CookieStorageProvider':function(){
// wrapped by build app
define("dojox/storage/CookieStorageProvider", ["dijit","dojo","dojox","dojo/require!dojox/storage/Provider,dojox/storage/manager,dojo/cookie"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.CookieStorageProvider");

dojo.require("dojox.storage.Provider");
dojo.require("dojox.storage.manager");
dojo.require("dojo.cookie");

dojo.declare(
	"dojox.storage.CookieStorageProvider",
	[dojox.storage.Provider],
	{
		store: null,

		cookieName: 'dojoxStorageCookie',

		storageLife: 730, // in days

		initialize: function(){

			this.store = dojo.fromJson(dojo.cookie(this.cookieName)) || {};

			this.initialized = true;
			dojox.storage.manager.loaded();
		},

		isAvailable: function(){ /*Boolean*/
			return dojo.cookie.isSupported();
		},

		put: function(	/*string*/ key,
						/*object*/ value,
						/*function*/ resultsHandler,
						/*string?*/ namespace){

			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			fullKey = this.getFullKey(key,namespace);

			this.store[fullKey] = dojo.toJson(value);
			this._save();

			var success = dojo.toJson(this.store) === dojo.cookie(this.cookieName);

			if(!success){
				this.remove(key,namespace);
			}

			if(resultsHandler){
				resultsHandler(success ? this.SUCCESS : this.FAILED, key, null, namespace);
			}

		},

		get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			// get our full key name, which is namespace + key
			key = this.getFullKey(key, namespace);

			return this.store[key] ? dojo.fromJson(this.store[key]) : null;
		},

		getKeys: function(/*string?*/ namespace){ /*Array*/
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			var keys = [];
			for(var currentKey in this.store){
				if(this._beginsWith(currentKey,namespace)){
					currentKey = currentKey.substring(namespace.length);
					keys.push(currentKey);
				}
			}

			return keys;
		},

		clear: function(/*string?*/ namespace){
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			for(var currentKey in this.store){
				if(this._beginsWith(currentKey,namespace)){
					delete(this.store[currentKey]);
				}
			}

			this._save();
		},

		remove: function(/*string*/ key, /*string?*/ namespace){
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			this._assertIsValidKey(key);
			key = this.getFullKey(key, namespace);

			delete this.store[key];
			this._save();
		},

		getNamespaces: function(){ /*string[]*/
			// There must be a better way than
			// to execute a regex on *every*
			// item in the store.

			var results = [this.DEFAULT_NAMESPACE];

			var found = {};
			found[this.DEFAULT_NAMESPACE] = true;
			var tester = /^__([^_]*)_/;

			for(var currentKey in this.store){
				if(tester.test(currentKey) == true){
					var currentNS = currentKey.match(tester)[1];
					if(typeof found[currentNS] == "undefined"){
						found[currentNS] = true;
						results.push(currentNS);
					}
				}
			}

			return results;
		},

		isPermanent: function(){ /*Boolean*/
			return true;
		},

		getMaximumSize: function(){ /* mixed */
			return 4;
		},

		hasSettingsUI: function(){ /*Boolean*/
			return false;
		},

		isValidKey: function(/*string*/ keyName){ /*Boolean*/
			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z_-]*$/.test(keyName);
		},

		isValidNamespace: function(/*string*/ keyName){ /*Boolean*/
			// we *must* prevent namespaces from having
			// underscores - else lookup of namespaces
			// via RegEx (e.g. in getNamespaces ) would
			// return wrong results.
			//
			// The only way around this would be to
			// disallow underscores in keys.

			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z-]*$/.test(keyName);
		},

		getFullKey: function(key, namespace){
			// checks for valid namespace and
			// key are already performed.
			return "__" + namespace + "_" + key;
		},

		_save: function(){
			dojo.cookie(this.cookieName,dojo.toJson(this.store),{expires: this.storageLife});
		},

		_beginsWith: function(/* string */ haystack, /* string */ needle) {
			if(needle.length > haystack.length) {
				return false;
			}
			return haystack.substring(0,needle.length) === needle;
		},

		_assertIsValidNamespace: function(/* string */ namespace){
			if(this.isValidNamespace(namespace) === false){
				throw new Error("Invalid namespace given: " + namespace);
			}
		},

		_assertIsValidKey: function(/* string */ key){
			if(this.isValidKey(key) === false){
				throw new Error("Invalid key given: " + key);
			}
		}
	}
);

dojox.storage.manager.register("dojox.storage.CookieStorageProvider", new dojox.storage.CookieStorageProvider());

});

},
'curam/util/RuntimeContext':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/RuntimeContext", [
        ], function() {

/*
 * Modification History
 * --------------------
 * 02-Aug-2011  MV  [CR00283023] Added the contextObject() function.
 * 21-Jun-2011  KW  [CR00275353] Initial version.
 */

/**
 * @name curam.util.RuntimeContext
 * @namespace Provides access to the browser Window object.
 * 
   */
  var RuntimeContext = dojo.declare("curam.util.RuntimeContext", null, {

  /**
   * @private
   */
  _window: null,

  /**
   * comments to follow
   *
   * @constructor
   * @private
   */
  constructor: function(window) {
    this._window = window;
  },
  
  /**
   * Comments to follow
   * 
   */
  getHref: function(){
    return this._window.location.href;
  },
  
  /**
   * Returns the path name of the url from the window's location object.
   * @Returns {String} Url path name.
   */
  getPathName: function() {
    return this._window.location.pathName;
  },

  /**
   * Returns the underlying context object of this runtime context.
   * @returns The underlying context object of this runtime context.
   */
  contextObject: function() {
    return this._window;
  }
  });
  
  return RuntimeContext;
});

},
'url:cwtk/widget/templates/TitlePane.html':"<div id=\"${id}\" class=\"cw-title-pane\">\r\n  <div class=\"cw-title-pane-title\" data-dojo-attach-point=\"_titleNode\">\r\n    <div class=\"cw-title-pane-text-div\">\r\n      ${title}\r\n    </div>\r\n    <div class=\"cw-title-pane-link-div\">\r\n      <div class=\"cw-title-pane-show-div\"\r\n        data-dojo-attach-point=\"_showButtonDiv\"\r\n        data-dojo-attach-event=\"ondijitclick: _slideEvent\" style=\"display:none\">\r\n        <a title=\"${labelShow}\" class=\"cw-title-pane-show-image\">${labelShow}</a>\r\n      </div>\r\n      <div class=\"cw-title-pane-hide-div\"\r\n        data-dojo-attach-point=\"_hideButtonDiv\"\r\n        data-dojo-attach-event=\"ondijitclick: _slideEvent\">\r\n        <a title=\"${labelHide}\" class=\"cw-title-pane-hide-image\">${labelHide}</a>\r\n      </div>\r\n      <div class=\"cw-title-pane-help\" data-dojo-attach-point=\"_helpNode\">\r\n        <!--title pane help-->\r\n        <div class=\"cw-popup-link cw-popup-link-dialog\">\r\n          <div data-dojo-attach-event=\"ondijitclick: _helpEvent\" class=\"cw-title-pane-help\">\r\n            <a title=\"${labelHelp}\" class=\"cw-title-pane-help-image\">${labelHelp}</a>\r\n          </div>\r\n          <div class=\"cw-dialog\" data-dojo-type=\"dijit.Dialog\" data-dojo-attach-point=\"_helpDialog\"\r\n            data-dojo-props=\"title: '${labelHelp}'\">\r\n            <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-attach-point=\"_helpPanel\"\r\n              href=\"${hrefHelp}\">\r\n              <!--help-->\r\n              <button data-dojo-type=\"dijit.form.Button\" onclick=\"cw.form.dismiss(this);\">\r\n                Dismiss\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"cw-title-pane-actions\" data-dojo-attach-point=\"_actionsNode\">\r\n        <!--title pane actions-->\r\n        <span class=\"cw-title-pane-actions\" data-dojo-type=\"cwtk.widget.DropDown\"\r\n          data-dojo-props=\"forcedOrientation:'R'\">\r\n          <div>\r\n            <a title=\"${labelActions}\" class=\"cw-title-pane-actions-image\">${labelActions}</a>\r\n          </div>\r\n          <div class=\"cw-tooltip-dialog\" data-dojo-type=\"dijit.TooltipDialog\" data-dojo-attach-point=\"_actionsDialog\">\r\n            <div data-dojo-type=\"dijit.layout.ContentPane\"\r\n              data-dojo-attach-point=\"_actionsPanel\" href=\"${hrefActions}\">\r\n              <!--actions-->\r\n            </div>\r\n          </div> </span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"cw-title-pane-display-panel\" data-dojo-attach-point=\"containerNode\">\r\n    <!--Content here.-->\r\n  </div>\r\n</div>",
'dijit/form/_FormWidgetMixin':function(){
define("dijit/form/_FormWidgetMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/_base/sniff", // has("webkit")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"	// a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, has, win, winUtils, a11y){

// module:
//		dijit/form/_FormWidgetMixin
// summary:
//		Mixin for widgets corresponding to native HTML elements such as <checkbox> or <button>,
//		which can be children of a <form> node or a `dijit.form.Form` widget.

return declare("dijit.form._FormWidgetMixin", null, {
	// summary:
	//		Mixin for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// name: [const] String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: [const] String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",
	_setTabIndexAttr: "focusNode",	// force copy even when tabIndex default value, needed since Button is <span>

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
	// works with screen reader
	_setIdAttr: "focusNode",

	_setDisabledAttr: function(/*Boolean*/ value){
		this._set("disabled", value);
		domAttr.set(this.focusNode, 'disabled', value);
		if(this.valueNode){
			domAttr.set(this.valueNode, 'disabled', value);
		}
		this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");

		if(value){
			// reset these, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._set("hovering", false);
			this._set("active", false);

			// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
			var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
				("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
			array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
				var node = this[attachPointName];
				// complex code because tabIndex=-1 on a <div> doesn't work on FF
				if(has("webkit") || a11y.hasDefaultTabStop(node)){	// see #11064 about webkit bug
					node.setAttribute('tabIndex', "-1");
				}else{
					node.removeAttribute('tabIndex');
				}
			}, this);
		}else{
			if(this.tabIndex != ""){
				this.set('tabIndex', this.tabIndex);
			}
		}
	},

	_onFocus: function(/*String*/ by){
		// If user clicks on the widget, even if the mouse is released outside of it,
		// this widget's focusNode should get focus (to mimic native browser hehavior).
		// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
		if(by == "mouse" && this.isFocusable()){
			// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
			var focusConnector = this.connect(this.focusNode, "onfocus", function(){
				this.disconnect(mouseUpConnector);
				this.disconnect(focusConnector);
			});
			// Set a global event to handle mouseup, so it fires properly
			// even if the cursor leaves this.domNode before the mouse up event.
			var mouseUpConnector = this.connect(win.body(), "onmouseup", function(){
				this.disconnect(mouseUpConnector);
				this.disconnect(focusConnector);
				// if here, then the mousedown did not focus the focusNode as the default action
				if(this.focused){
					this.focus();
				}
			});
		}
		if(this.scrollOnFocus){
			this.defer(function(){ winUtils.scrollIntoView(this.domNode); }); // without defer, the input caret position can change on mouse click
		}
		this.inherited(arguments);
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.  Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		if(!this.disabled && this.focusNode.focus){
			try{ this.focusNode.focus(); }catch(e){}/*squelch errors from hidden nodes*/
		}
	},

	compare: function(/*anything*/ val1, /*anything*/ val2){
		// summary:
		//		Compare 2 values (as returned by get('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(/*===== newValue =====*/){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		this._pendingOnChange = this._pendingOnChange
			|| (typeof newValue != typeof this._lastValueReported)
			|| (this.compare(newValue, this._lastValueReported) != 0);
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
			this._lastValueReported = newValue;
			this._pendingOnChange = false;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					this._onChangeHandle.remove();
				}
				// defer allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = this.defer(
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			this._onChangeHandle.remove();
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	}
});

});

},
'cwtk/widget/DateTextBox':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/DateTextBox", [
    "dojo/_base/declare",
    "idx/oneui/form/DateTextBox",
    "dojo/date/locale"
], function(declare, DateTextBox) {
	return declare([idx.oneui.form.DateTextBox], {

		serializationFormat: null,

		serialize: function(value, options)
		{
			if(this.serializationFormat != null) {
				value = dojo.date.locale.format(
					value,
					{selector: "date", fullYear: true, datePattern: this.serializationFormat}
				);
			}
			return value;
		}

	});
});

},
'curam/util/ContextPanel':function(){
/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/ContextPanel", ["curam/util",
        "curam/tab",
        "curam/debug",
        "curam/define",
        "curam/util/ResourceBundle"
        ], function() {

/*
 * Modification History
 * --------------------
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 21-Oct-2012  SK  [CR00346419] Correctly unsubscribes from the onload registry
 *                               when a tab is closed.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 10-Sep-2012  MV  [CR00344216] Only subscribe one listener to tab ready event.
 * 31-Jul-2012  MV  [CR00336202] Refactor to also work in IE7.
 * 17-Jul-2012  MV  [CR00329547] Load context panel only after tab is ready.
 * 15-Dec-2011  MV [CR00299726] Synchronize initial load of panel with
 *                              subsequent refreshes. 
 * 26-Aug-2011  JK [TEC-7914]   Added title to context panel.
 * 29-Jul-2011  MV [CR00269970] Added refresh() function.
 * 20-Jan-2011  MV [CR00244126] Initial version.
 */

/**
 * Creating Resource Bundle Object to access localized resources.
 */
dojo.requireLocalization("curam.application", "Debug");  
var bundle = new curam.util.ResourceBundle("Debug");
  
/**
 * @namespace Functions specific to the context panel.
 */
  curam.define.singleton("curam.util.ContextPanel", {
    
    /** Name of the attribute on content iframe that holds the URL of the frame
     * content. */
    CONTENT_URL_ATTRIB: "data-content-url",
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     */
    setupLoadEventPublisher: function(eventName, tabWidgetId, iframeId) {
      curam.util.ContextPanel._doSetup(eventName, tabWidgetId, iframeId,
          function(tabWidgetId) { return dijit.byId(tabWidgetId); });
    },
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     * @param getTab A function to get tab widget based on ID.
     */
    _doSetup: function(eventName, tabWidgetId, iframeId, getTab) {
    var unsToken = curam.util.getTopmostWindow().dojo.subscribe(
          eventName, function() {
            var tab = getTab(tabWidgetId);
            var iframe = curam.util.ContextPanel._getIframe(tab);
  
          //publish when the detailsPanel is fully loaded
            curam.debug
              .log(bundle.getProperty("curam.util.ContextPanel.loaded"));
            curam.util.getTopmostWindow().dojo.publish(
                '/curam/frame/detailsPanelLoaded', [{ loaded: true }, tabWidgetId]);
  
            // mark the frame as loaded
            iframe._finishedLoading = true;
  
            // effect a scheduled refresh if there is one
            if (iframe._scheduledRefresh) {
              curam.util.ContextPanel.refresh(tab);
              // scheduled refresh done - reset the indicator
              iframe._scheduledRefresh = false;
            }
        });

    curam.util.onLoad.addSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    
    curam.tab.unsubscribeOnTabClose(unsToken, tabWidgetId);
    curam.tab.executeOnTabClose(function() {
      curam.util.onLoad.removeSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    }, tabWidgetId);
  },
  
  /**
   * Refreshes the content panel of the specified tab.
   * This function is expected to be called in the top window runtime context. 
   */
  refresh: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        curam.debug.log(bundle
          .getProperty("curam.util.ContextPanel.refresh.prep"));
        if (iframe._finishedLoading) {
          curam.debug.log(bundle
            .getProperty("curam.util.ContextPanel.refresh"));
          // we will be reloading so reset the flag to guard against in-flight
          // refreshes interrupting
          iframe._finishedLoading = false;
          var doc =  iframe.contentDocument // W3C
                  || iframe.contentWindow.document; //IE
          // force reload of the context panel
      doc.location.reload(true);
  
        } else {
          // frame not yet loaded, delay the refresh after it has loaded fully
          curam.debug.log(bundle
            .getProperty("curam.util.ContextPanel.refresh.delay"));
          iframe._scheduledRefresh = true;
        }
      }
    },
    
    /**
     * 
     * @param tab The tab to look for context panel in.
     * @returns A context panel iframe or undefined if it was not found. 
     */
    _getIframe: function(tab) {
      var frames = dojo.query("iframe.detailsPanelFrame", tab.domNode);
      return frames[0];
  },
  
  addTitle: function(iframeId) {
    var iframe = dojo.query("." + iframeId)[0];
    var pageTitle = iframe.contentWindow.document.title;
    iframe.setAttribute("title", CONTEXT_PANEL_TITLE + " - " + pageTitle);
    },
    
    /**
     * Loads the context panel content in its iframe.
     * The function gracefully handles situations where there is no context
     * panel on the tab or it has been loaded already.
     * 
     * Initially context panel iframe has no src attribute so that we can
     * control at which point in time the content is loaded.
     * 
     * @param tab The tab object to load context panel content for.
     */
    load: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        var source = dojo.attr(iframe,
            curam.util.ContextPanel.CONTENT_URL_ATTRIB);
        if (source && source != "undefined") {
          iframe[curam.util.ContextPanel.CONTENT_URL_ATTRIB] = undefined;
          dojo.attr(iframe, "src", source);
        }
      }
    }
  });
  
  /* Only load the context panel when the tab is setup completely.
   * This is to work around the issue in IE9 that was causing the iframe to be
   * garbage collected inadvertently.
   */
  var topWin = curam.util.getTopmostWindow();
  if (typeof topWin._curamContextPanelTabReadyListenerRegistered != "boolean") {
    topWin.dojo.subscribe(
        "/curam/application/tab/ready", null, function(newTab) {
          curam.util.ContextPanel.load(newTab);
        });
    topWin._curamContextPanelTabReadyListenerRegistered = true;
  }
  
  return curam.util.ContextPanel;
});

},
'curam/widget/form/ToggleButtonGroup':function(){
define("curam/widget/form/ToggleButtonGroup", ["dojo/_base/declare",
        "dojo/_base/connect",
        "dijit/form/ToggleButton"],
        function(declare,
        		connect,
        		toggleButton) {
	return declare("curam.widget.form.ToggleButtonGroup",[toggleButton], 
{
		/**
		 * An extension of a toggle button that allows one button at a time to be 
		 * selected with in a group.
		 */
		
		_connectHandler : null,
		_unselectChannel : null,
        groupName: 'toggleButtonGroup', 
        
        postMixInProperties:function(){ 
                this.inherited(arguments); 
                this._unselectChannel = '/toggleButtonGroup%$��!|WE/' + this.groupName;
                this._connectHandler = connect.subscribe(this._unselectChannel, this, '_unselect'); 
        },
        
        /**
         * Unselect other buttons with in the group
         */
        _unselect: function(/*Object*/button) { 
                if (button !== this && this.checked) { 
                        this.set('checked', false); 
                } 
        }, 
        
        /**
         * handler function that will call the
         * internal select function
         */
        _onClick: function(e) { 
                if (this.disabled) { 
                        return false; 
                } 
                if (!this.checked) { 
                        this._select(); 
                } 
                return this.onClick(e);
        }, 
        
        /**
         * Publish to other buttons that they need
         * to unselect
         */
        _select: function() {
                dojo.publish(this._unselectChannel, [this]); 
                this.set('checked', true); 
        },
        
        /**
         * Handler that will up date the other buttons if this 
         * buttons value gets changed
         */
    	_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
    		
    		dojo.publish(this._unselectChannel, [this]); 
			this.inherited(arguments);
    	},
		
		/**
		 * Clean up functions
		 */
		destroy: function() {
			try
			{
				connect.disconnect(this._connectHandler);				
			}	
	  		catch(err){
				console.error(err);
			}

			this.inherited(arguments);
		}
	});
});

},
'dijit/_base/place':function(){
define("dijit/_base/place", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/lang", // lang.isArray
	"dojo/window", // windowUtils.getBox
	"../place",
	".."	// export to dijit namespace
], function(array, lang, windowUtils, place, dijit){

	// module:
	//		dijit/_base/place
	// summary:
	//		Back compatibility module, new code should use dijit/place directly instead of using this module.

	dijit.getViewport = function(){
		// summary:
		//		Deprecated method to return the dimensions and scroll position of the viewable area of a browser window.
		//		New code should use windowUtils.getBox()

		return windowUtils.getBox();
	};

	/*=====
	dijit.placeOnScreen = function(node, pos, corners, padding){
		// summary:
		//		Positions one of the node's corners at specified position
		//		such that node is fully visible in viewport.
		//		Deprecated, new code should use dijit.place.at() instead.
	};
	=====*/
	dijit.placeOnScreen = place.at;

	/*=====
	dijit.placeOnScreenAroundElement = function(node, aroundElement, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
		//		for the "around" argument and finds a proper processor to place a node.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	====*/
	dijit.placeOnScreenAroundElement = function(node, aroundNode, aroundCorners, layoutNode){
		// Convert old style {"BL": "TL", "BR": "TR"} type argument
		// to style needed by dijit.place code:
		//		[
		// 			{aroundCorner: "BL", corner: "TL" },
		//			{aroundCorner: "BR", corner: "TR" }
		//		]
		var positions;
		if(lang.isArray(aroundCorners)){
			positions = aroundCorners;
		}else{
			positions = [];
			for(var key in aroundCorners){
				positions.push({aroundCorner: key, corner: aroundCorners[key]});
			}
		}

		return place.around(node, aroundNode, positions, true, layoutNode);
	};

	/*=====
	dijit.placeOnScreenAroundNode = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Position node adjacent or kitty-corner to aroundNode
		//		such that it's fully visible in viewport.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	=====*/
	dijit.placeOnScreenAroundNode = dijit.placeOnScreenAroundElement;

	/*=====
	dijit.placeOnScreenAroundRectangle = function(node, aroundRect, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except that the "around"
		//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
		//		instead of a dom node.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	=====*/
	dijit.placeOnScreenAroundRectangle = dijit.placeOnScreenAroundElement;

	dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
		// summary:
		//		Deprecated method, unneeded when using dijit/place directly.
		//		Transforms the passed array of preferred positions into a format suitable for
		//		passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
		//
		// position: String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		// leftToRight: Boolean
		//		Whether the popup will be displaying in leftToRight mode.
		//
		var align = {};
		array.forEach(position, function(pos){
			var ltr = leftToRight;
			switch(pos){
				case "after":
					align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
					break;
				case "before":
					align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
					break;
				case "below-alt":
					ltr = !ltr;
					// fall through
				case "below":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
					align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
					break;
				case "above-alt":
					ltr = !ltr;
					// fall through
				case "above":
				default:
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
					align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
					break;
			}
		});
		return align;
	};

	return dijit;
});

},
'cwtk/widget/MenuItem':function(){
require({cache:{
'url:cwtk/widget/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" waiRole=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${iconSrc}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"}});
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/MenuItem", [
    "dojo", 
    "dojo/_base/declare", 
    "dijit/MenuItem", 
    "dojo/text!./templates/MenuItem.html"
], function(dojo, declare, MenuItem, template){

		return declare("cwtk.widget.MenuItem", MenuItem, {
           iconSrc: "", 
           templateString: template,
           startup : function() {
               this.inherited(arguments);
               dojo.connect(this, "onClick", this.closeParent);
           }, 
           destroy : function() {
               this.inherited(arguments);
           },
           closeParent : function() {
        	   dojo.query(this.domNode).parents(".dijitTooltipDialog, .dijitDialog").forEach(function(d) {
        		   dijit.popup.close(dijit.byId(d.id));
        	   });
           }
        });

});
},
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n",
'dojox/main':function(){
define("dojox/main", ["dojo/_base/kernel"], function(dojo) {
	// module:
	//		dojox/main
	// summary:
	//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.

	return dojo.dojox;
});
},
'url:dijit/templates/Calendar.html':"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" aria-labelledby=\"${id}_mddb ${id}_year\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\n\t\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\">\n\t\t\t\t<div data-dojo-attach-point=\"monthNode\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\n\t\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t${!dayCellsHtml}\n\t\t</tr>\n\t</thead>\n\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"onclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t\t${!dateRowsHtml}\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\" role=\"presentation\">\n\t\t\t\t<div class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n",
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode\" data-dojo-attach-event='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' data-dojo-attach-point='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' data-dojo-attach-point='tabContent'>\n        \t<div role=\"presentation\" data-dojo-attach-point='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" data-dojo-attach-point='iconNode' />\n\t\t        <span data-dojo-attach-point='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t        \t\tdata-dojo-attach-event='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n",
'url:dojox/layout/resources/ExpandoPane.html':"<div class=\"dojoxExpandoPane\">\n\t<div dojoAttachPoint=\"titleWrapper\" class=\"dojoxExpandoTitle\">\n\t\t<div class=\"dojoxExpandoIcon\" dojoAttachPoint=\"iconNode\" dojoAttachEvent=\"onclick:toggle\"><span class=\"a11yNode\">X</span></div>\t\t\t\n\t\t<span class=\"dojoxExpandoTitleNode\" dojoAttachPoint=\"titleNode\">${title}</span>\n\t</div>\n\t<div class=\"dojoxExpandoWrapper\" dojoAttachPoint=\"cwrapper\" dojoAttachEvent=\"ondblclick:_trap\">\n\t\t<div class=\"dojoxExpandoContent\" dojoAttachPoint=\"containerNode\"></div>\n\t</div>\n</div>\n",
'idx/oneui/Menu':function(){
require({cache:{
'url:idx/oneui/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\r\n\t<tbody class=\"dijitReset\">\r\n\t\t<tr data-dojo-attach-point=\"_columnContainerNode\">\r\n\t\t\t<td class=\"dijitReset oneuiMenuColumn\" data-dojo-attach-point=\"columnNodes\">\r\n\t\t\t\t<table class=\"dijitReset\" cellspacing=\"0\" width=\"100%\" role=\"presentation\">\r\n\t\t\t\t\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"_containerNodes,containerNode\">\r\n<!-- this is column 0, which also starts out as the container node so menu items are initially loaded here.\r\n     containerNode changes to point to _columnContainerNode once the widget has initialised, so the whole set of columns is the container.\r\n\t this must be kept in synch with _MenuColumn.html -->\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n",
'url:idx/oneui/templates/_MenuColumn.html':"<td class=\"dijitReset oneuiMenuColumn\" data-dojo-attach-point=\"columnNodes\">\r\n\t<table class=\"dijitReset\" cellspacing=\"0\" width=\"100%\" role=\"presentation\">\r\n\t\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"_containerNodes\">\r\n<!-- this must be kept in synch with column 0 included in Menu.html -->\r\n\t\t</tbody>\r\n\t</table>\r\n</td>"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/Menu", ["dojo/_base/array",
		"dojo/_base/declare",
		"dojo/_base/event",
		"dojo/dom-geometry",
		"dijit/_TemplatedMixin",
		"dijit/_WidgetBase",
		"dijit/Menu",
		"dijit/MenuItem",
		"dijit/registry",
		"idx/oneui/_MenuOpenOnHoverMixin",
		"dojo/text!../oneui/templates/Menu.html",
		"dojo/text!../oneui/templates/_MenuColumn.html"],
		function(array,
				 declare,
				 event,
				 domgeometry,
				 _TemplatedMixin,
				 _WidgetBase,
				 Menu,
				 MenuItem,
				 registry,
				 _MenuOpenOnHoverMixin,
				 template,
				 columntemplate){
				 	
	var icons = {
		"error":        "oneuiErrorMenuItemIcon",
		"warning":      "oneuiWarningMenuItemIcon",
		"confirmation": "oneuiConfirmationMenuItemIcon",
		"information":  "oneuiInformationMenuItemIcon",
		"success":      "oneuiSuccessMenuItemIcon",
		"critical":     "oneuiCriticalMenuItemIcon",
		"attention":    "oneuiAttentionMenuItemIcon",
		"compliance":   "oneuiComplianceMenuItemIcon"
	}

	/**
	 * Creates a new idx.oneui.Menu
	 * @name idx.oneui.Menu
	 * @class The Menu widget provides a menu that facilitates event routing and
	 * functional linkage when used inside an idx.oneui.MenuDialog, and
	 * provides cascade-on-hover behaviour when the menu is used "flat". It
	 * also provides multi-column menu support including keyboard navigation.
	 * <p>
	 * Instances can be supplied as the "popup" parameter for dijit.PopupMenuItem
	 * and dijit.PopupMenuBarItem, and will operate as dijit.Menu. Instances can
	 * operate as popup menus on arbitrary DOM nodes, or for the whole window,
	 * and will operate as dijit.Menu. Instances can be placed "flat" within a
	 * layout in the UI, and will operate as dijit.Menu except that
	 * cascade-on-hover behaviour is available (controlled by the openOnHover
	 * property). Instances can be placed "flat" within an idx.oneui.MenuDialog,
	 * and can operate as a drop-down menu in combination with the containing
	 * dialog (controlled by the menuForDialog property).
	 * </p>
	 * <p>
	 * When menu items are added to this widget, the "column" property on each
	 * item can be used to specify the column in which the item should be placed.
	 * Columns will be created as needed to accommodate each new item, and can be
	 * styled by CSS.
	 * </p>
	 * @augments dijit.Menu
	 * @augments idx.oneui._MenuOpenOnHoverMixin
	 * @borrows idx.oneui._MenuOpenOnHoverMixin#openOnHover as this.openOnHover
	 * @example
	 * &lt;div data-dojo-type="idx.oneui.MenuDialog"&gt;
  &lt;div data-dojo-type="idx.oneui.Menu"&gt;
    &lt;div data-dojo-type="dijit.MenuItem" onclick="..."&gt;
      ...
    &lt;/div&gt;
      ...
  &lt;/div&gt;</span>
    ...
&lt;/div&gt;
	 */
	var Menu = declare("idx.oneui.Menu", [Menu, _MenuOpenOnHoverMixin], 
	/** @lends idx.oneui.Menu.prototype */
	{
		/**
		 * An array of the DOM nodes (tbody's), one per column, that
		 * contain the items that are in each column.
		 * @type DOMNode[]
		 * @private
		 */		
		_containerNodes: null,
		
		/**
		 * An array of the DOM nodes that can be used for styling individual
		 * columns in a multi-column menu. The nodes are ('td's), one per column,
		 * which are in a table row that implements the multiple columns, 
		 * and each of which contains
		 * a single column table containing the menu items. The column nodes
		 * are higher up in the DOM structure than the container nodes, but
		 * have a 1 to 1 relationship. They are externalised as they are more 
		 * suitable for styling the columns than the container nodes.
		 * @type DOMNode[]
		 */ 
		columnNodes: null,
		
		/**
		 * Indicates if this menu should be used by an idx.oneui.MenuDialog it
		 * is in to provide the primary menu functionality.
		 * @type boolean 
		 */
		menuForDialog: true,
		
		/**
	 	 * The template HTML for the widget.
		 * @constant
		 * @type string
		 * @private
		 * @default Loaded from idx/oneui/templates/Menu.html.
		 */
		templateString: template,
		
		/**
		 * Constructor.
		 * @private
		 */
		constructor: function(){
			this._containerNodes = [];
			this.columnNodes = [];
		},
		
		/**
		 * Returns the next or previous focusable child, compared to "child".
		 * Overridden because original does not work if the child widgets are
		 * not immediate peers in the DOM.
		 * <p>THIS IMPLEMENTATION ASSUMES THAT getChildren() RETURNS THE
		 * CHILDREN IN THE CORRECT ORDER FOR NAVIGATION. THIS IS TRUE
		 * AS OF DOJO V1.7</p>
		 * @param {dijit._Widget} child The current widget.
		 * @param {number} dir Integer: 1 = after, -1 = before.
		 */
		_getNextFocusableChild: function(child, dir){
			var nextFocusableChild = null;
			var children = this.getChildren();
			var startIndex;
			if(child != null){
				startIndex = array.indexOf(children, child);
				if (startIndex != -1) {
					startIndex += dir;
					if(startIndex < 0) 
						startIndex = children.length - 1;
					if(startIndex >= children.length) 
						startIndex = 0;
				}
			}
			else if(children.length == 0) 
				startIndex = -1;
			else 
				startIndex = (dir == 1) ? 0 : children.length - 1;
			
			if(startIndex != -1){
				// If there are children and the specifed start child if any
				// is one of them. Then iterate through the array of children
				// starting at the start position plus/minus. If either end of 
				// the array is hit then loop to the other end and continue
				// until a focusable child is found or the start position is
				// reached.
				var i = startIndex;
				do{
					if (children[i].isFocusable()) {
						nextFocusableChild = children[i];
						break;
					}
					i += dir;
					if(i < 0)
						i = children.length - 1;
					if(i >= children.length)
						i = 0;
				}while(i != startIndex);
			}
			
			return nextFocusableChild;
		},
		
		/**
		 * Finds the closest column in the specified direction with one or
		 * more focusable menu items in it and moves focus to the one level
		 * with the top of the currently focused menu item, or next higher or
		 * lower if that is not possible.
		 * @param {number} dir Direction - indicates whether to move focus to
		 * the next (+1) or previous (-1) column.
		 * @returns true if focus sucessfully moved, else false.
		 */
		_moveToColumn: function(dir){
			
			// Identify the column containing the currently focused menu
			// item and determine its y-position.
			if(this.focusedChild){
				for(var i = 0; i < this._containerNodes.length; i++){
					if(this.focusedChild.domNode.parentNode == this._containerNodes[i]){
						var focusedCol = i, yPos = domgeometry.getMarginBox(this.focusedChild.domNode).t;
						break;
					}
				}
			}
			if(focusedCol != undefined){
				// Try to locate the closest column in the appropriate direction
				// with at least one focusable item in it.
				for (i = focusedCol + dir; i >= 0 && i < this._containerNodes.length; i += dir) {
					var children = registry.findWidgets(this._containerNodes[i]);
					var focusableChildren = dojo.filter(children, function(child){ return child.isFocusable() })
					if(focusableChildren.length > 0){
						var targetColumn = i;
						break;
					}
				}
				if(targetColumn != undefined){
					// Iterate through the focusable children and transfer 
					// focus to the item level with the currently focused
					// one, or the next higher, or the next lower, in that
					// order.
					for (i = 0; i < focusableChildren.length; i++){
						var child = focusableChildren[i];
						var childBox = domgeometry.getMarginBox(child.domNode);
						if(yPos >= childBox.t && yPos <= childBox.t + childBox.h - 1){
							this.focusChild(child);
							return true;
						} 
						else if(yPos < childBox.t){
							if(i > 0){
								this.focusChild(focusableChildren[i - 1]);
								return true;
							}else{
								this.focusChild(child);
								return true;
							}
						}else if(i == focusableChildren.length - 1){
							this.focusChild(child);
							return true;
						} 
					}
				}
			}
			
			// If the method didn't get to the point of focusing another menu
			// item then it failed.
			return false;
		},

		/**
		 * We replace _onKeyPress because our base class does NOT stop a
		 * close-sub-menu-key event even when it has handled the event
		 * (by cancelling itself or passing the navigation request to a
		 * parent menu bar). Curiously, it DOES stop the keypress event
		 * when it DOESN'T handle it, and this seems exactly the wrong way
		 * around. If the base class key handling changes so that handled
		 * keypress are also stopped, this override version can be deleted.
		 * @param {Event} evt
		 */		
		_onKeyPress: function(evt){

			if(evt.ctrlKey || evt.altKey){ return; }

			switch(evt.charOrCode){
				case this._openSubMenuKey:
					if (!this._moveToColumn(+1)) {
						this._moveToPopup(evt);
					}
					event.stop(evt);
					break;
				case this._closeSubMenuKey:
					if(!this._moveToColumn(-1)){
						if(this.parentMenu){
							if(this.parentMenu._isMenuBar){
								this.parentMenu.focusPrev();
							}else{
								this.onCancel(false);
							}
						}
					}				
					event.stop(evt);
					break;
			}
		},
		
		/**
		 * Refresh the layout of the menu items in the columns.
		 */
		refresh: function(){

			// Make sure that all child widgets are in the correct columns.
			var children = this.getChildren();
			for(var i = 0; i < children.length; i++){
				this.addChild(children[i]);
			}
		},		

		/**
		 * Standard widget lifecycle startup() method.
		 * @private
		 */		
		startup: function(){

			if(this._started){ return; }
			this._started = true;
			this.inherited(arguments);
			
			// When the widget is created the container node is associated
			// with column 0 (by the template), so that menu items are 
			// inserted into column 0 by the default template logic. The
			// container node now needs to be moved up the DOM tree so that 
			// it covers all the columns of menu items, and the menu items that
			// were initially loaded into column 0 moved to other columns, if 
			// necessary.
			this.containerNode = this._columnContainerNode;
			this.refresh();
		},
		
		/**
		 * Override of standard container addChild() method, to allocate
		 * menuitems and separators to specified columns. 
		 * @param {dijit._Widget} widget Menu item, separator or heading to be
		 * added to the menu.
		 * @param {number} insertIndex Optional position to insert the item
		 * into the column in.
		 */
		addChild: function(widget, insertIndex){

			// Create new columns for the menu as necessary, if the item is
			// to be placed in a column that does not exist yet.
			while(this._containerNodes.length <= (widget.column || 0)){
				var node = _TemplatedMixin.getCachedTemplate(columntemplate).cloneNode(true);
				this._attachTemplateNodes(node, function(n,p){ return n.getAttribute(p); });
				this._columnContainerNode.appendChild(node);			
			}
			
			// Add the item to the column by temporarily making the column 
			// node the container node for the widget and then invoking the
			// standard, inherited dijit._Container functionality.
			this.containerNode = this._containerNodes[widget.column || 0];		
			this.inherited(arguments);
			this.containerNode = this._columnContainerNode;
		}
	});
	
	/**
	 * Create a menu item that represents a single message and which
	 * can be inserted into One UI message menus (menus which have the
	 * additional CSS class "oneuiMessageMenu").
	 * @name createMessageMenuItem
	 * @function
	 * @memberOf idx.oneui.Menu
	 * @param {Object} args An object containing some the following fields,
	 * which are all optional:
	 * <ul>
	 * 	<li>
	 * 	  type: {string}
	 * 		The type of message. This can be "error", "warning",
	 *          "information", or "success".
	 *  </li>
	 * 	<li>
	 * 	  content: {string}
	 * 		The message content.
	 *  </li>
	 * 	<li>
	 * 	  messageId: {string}
	 * 	    An identifier for the message, displayed alongside the
	 *          content.
	 *  </li>
	 * 	<li>
	 * 	  timestamp: {string}
	 * 	    The date/time that the message was originated, displayed
	 *          alongside the content.
	 *  </li>
	 * </ul>
	 * @example var menuItem = Menu.createMessageMenuItem({
     *	type: "error",    // or "warning", "information" or "success"
     *	content: "Hello, world!",
     *	timestamp: locale.format(new Date(), { formatLength: "medium", 
     *	                                       locale: this.lang }),
     *	messageId: "CAT123456"
     *});
	 */
	Menu.createMessageMenuItem = function(args){

		var label = "";
		
		if(args){
			if(args.timestamp){
				label += '\u200f<span class="messageMenuTimestamp messagesContrast">\u200e' + args.timestamp + '\u200f</span>\u200e';
			}
			
			if(args.content){
				label += '\u200f <span class="messageTitles">\u200e' + args.content + '\u200f</span>\u200e';
			}
			
			if(args.messageId){
				label += '\u200f <span class="messagesContrast">(\u200e' + args.messageId + '\u200f)</span>\u200e';
			}
		}

		return new MenuItem({ label: label, iconClass: args && args.type && icons[args.type] });
	}
	
	return Menu;
});
},
'dojox/collections/Dictionary':function(){
define("dojox/collections/Dictionary", ["dojo/_base/kernel", "dojo/_base/array", "./_base"], function(dojo, darray, dxc){
/*=====
var dxc = dojox.collections;
=====*/
	dxc.Dictionary=function(/* dojox.collections.Dictionary? */dictionary){
		//	summary
		//	Returns an object of type dojox.collections.Dictionary
		var items={};
		this.count=0;

		//	comparator for property addition and access.
		var testObject={};

		this.add=function(/* string */k, /* object */v){
			//	summary
			//	Add a new item to the Dictionary.
			var b=(k in items);
			items[k]=new dxc.DictionaryEntry(k,v);
			if(!b){
				this.count++;
			}
		};
		this.clear=function(){
			//	summary
			//	Clears the internal dictionary.
			items={};
			this.count=0;
		};
		this.clone=function(){
			//	summary
			//	Returns a new instance of dojox.collections.Dictionary; note the the dictionary is a clone but items might not be.
			return new dxc.Dictionary(this);	//	dojox.collections.Dictionary
		};
		this.contains=this.containsKey=function(/* string */k){
			//	summary
			//	Check to see if the dictionary has an entry at key "k".
			if(testObject[k]){
				return false;			// bool
			}
			return (items[k]!=null);	//	bool
		};
		this.containsValue=function(/* object */v){
			//	summary
			//	Check to see if the dictionary has an entry with value "v".
			var e=this.getIterator();
			while(e.get()){
				if(e.element.value==v){
					return true;	//	bool
				}
			}
			return false;	//	bool
		};
		this.entry=function(/* string */k){
			//	summary
			//	Accessor method; similar to dojox.collections.Dictionary.item but returns the actual Entry object.
			return items[k];	//	dojox.collections.DictionaryEntry
		};
		this.forEach=function(/* function */ fn, /* object? */ scope){
			//	summary
			//	functional iterator, following the mozilla spec.
			var a=[];	//	Create an indexing array
			for(var p in items) {
				if(!testObject[p]){
					a.push(items[p]);	//	fill it up
				}
			}
			dojo.forEach(a, fn, scope);
		};
		this.getKeyList=function(){
			//	summary
			//	Returns an array of the keys in the dictionary.
			return (this.getIterator()).map(function(entry){
				return entry.key;
			});	//	array
		};
		this.getValueList=function(){
			//	summary
			//	Returns an array of the values in the dictionary.
			return (this.getIterator()).map(function(entry){
				return entry.value;
			});	//	array
		};
		this.item=function(/* string */k){
			//	summary
			//	Accessor method.
			if(k in items){
				return items[k].valueOf();	//	object
			}
			return undefined;	//	object
		};
		this.getIterator=function(){
			//	summary
			//	Gets a dojox.collections.DictionaryIterator for iteration purposes.
			return new dxc.DictionaryIterator(items);	//	dojox.collections.DictionaryIterator
		};
		this.remove=function(/* string */k){
			//	summary
			//	Removes the item at k from the internal collection.
			if(k in items && !testObject[k]){
				delete items[k];
				this.count--;
				return true;	//	bool
			}
			return false;	//	bool
		};

		if (dictionary){
			var e=dictionary.getIterator();
			while(e.get()) {
				 this.add(e.element.key, e.element.value);
			}
		}
	};
	return dxc.Dictionary;
});

},
'dojox/storage/_common':function(){
// wrapped by build app
define("dojox/storage/_common", ["dijit","dojo","dojox","dojo/require!dojox/storage/Provider,dojox/storage/manager,dojox/storage/LocalStorageProvider,dojox/storage/WhatWGStorageProvider,dojox/storage/BehaviorStorageProvider,dojox/storage/CookieStorageProvider"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage._common");
dojo.require("dojox.storage.Provider");
dojo.require("dojox.storage.manager");

/*
  Note: if you are doing Dojo Offline builds you _must_
  have offlineProfile=true when you run the build script:
  ./build.sh action=release profile=offline offlineProfile=true
*/
dojo.require("dojox.storage.LocalStorageProvider");
dojo.require("dojox.storage.WhatWGStorageProvider");
dojo.require("dojox.storage.BehaviorStorageProvider");
dojo.require("dojox.storage.CookieStorageProvider");

// now that we are loaded and registered tell the storage manager to
// initialize itself
dojox.storage.manager.initialize();

});

},
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'dojo/fx':function(){
define("dojo/fx", [
	"./_base/lang",
	"./Evented",
	"./_base/kernel",
	"./_base/array",
	"./_base/connect",
	"./_base/fx",
	"./dom",
	"./dom-style",
	"./dom-geometry",
	"./ready",
	"require" // for context sensitive loading of Toggler
], function(lang, Evented, dojo, arrayUtil, connect, baseFx, dom, domStyle, geom, ready, require) {

	// module:
	//		dojo/fx
	// summary:
	//		TODOC


	/*=====
	dojo.fx = {
		// summary: Effects library on top of Base animations
	};
	var coreFx = dojo.fx;
	=====*/
	
// For back-compat, remove in 2.0.
if(!dojo.isAsync){
	ready(0, function(){
		var requires = ["./fx/Toggler"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

	var coreFx = dojo.fx = {};

	var _baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		arrayUtil.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	_chain.prototype = new Evented();
	lang.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			connect.disconnect(this._onAnimateCtx);
			connect.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = connect.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = connect.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = connect.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = connect.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = connect.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					connect.disconnect(beforeBegin);
					connect.disconnect(onBegin);
					connect.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				connect.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = connect.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				connect.disconnect(this._onEndCtx);
			}
			this._onEndCtx = connect.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = connect.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						connect.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			arrayUtil.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = connect.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						connect.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ connect.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ connect.disconnect(this._onEndCtx); }
		}
	});
	lang.extend(_chain, _baseObj);

	coreFx.chain = /*===== dojo.fx.chain = =====*/ function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations); // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		arrayUtil.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(connect.connect(a, "onEnd", this, "_onEnd"));
		}, this);

		this._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		arrayUtil.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(connect.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	lang.extend(_combine, {
		_doAction: function(action, args){
			arrayUtil.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			arrayUtil.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			arrayUtil.forEach(this._connects, connect.disconnect);
		}
	});
	lang.extend(_combine, _baseObj);

	coreFx.combine = /*===== dojo.fx.combine = =====*/ function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel,
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	coreFx.wipeIn = /*===== dojo.fx.wipeIn = =====*/ function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = domStyle.get(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		var fini = function(){
			s.height = "auto";
			s.overflow = o;
		};
		connect.connect(anim, "onStop", fini);
		connect.connect(anim, "onEnd", fini);

		return anim; // dojo.Animation
	};

	coreFx.wipeOut = /*===== dojo.fx.wipeOut = =====*/ function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		connect.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		var fini = function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		};
		connect.connect(anim, "onStop", fini);
		connect.connect(anim, "onEnd", fini);

		return anim; // dojo.Animation
	};

	coreFx.slideTo = /*===== dojo.fx.slideTo = =====*/ function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = dom.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = domStyle.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = geom.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		connect.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	};

	return coreFx;
});

},
'curam/widget/componentWrappers/ListWraper':function(){
define("curam/widget/componentWrappers/ListWraper", ["dojo/_base/declare",
        "dojo/on",
        "dijit/_Widget",
        "dojo/dom-construct",
        "dojo/dom-geometry",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-attr"],
        function(declare,
                        on,
                        _Widget,
                        domConstruct,
                        domGeom,
                        domStyle,
                        domClass,
                        domAttr) {
        return declare("curam.widget.componentWrappers.ListWraper",[_Widget], 
{
                baseClass : "navMenu",
                
                
                _listTypeUnordered : "ul",
                _listTypeOrdered : "ol",
                
                listType : this._listTypeOrdered,               
                baseClass : "listWrapper",
                
                itemClass : null,
                itemStyle : null,
                
                role  : null,
                
                buildRendering : function() {
                  
                        if(this.listType == this._listTypeUnordered)
                        {
                                this.domNode = domConstruct.create("ul");
                        }
                        else
                        {
                                this.domNode = domConstruct.create("ol");
                        }
                        
                        if(this.role != null)
                        {
                                domAttr.set(this.domNode, "role", this.role);
                        }

                        this.inherited(arguments);
                },
                
                _setItemAttr : function(item, possion)
                {
                        if(possion == null)
                        {
                                possion = "last";
                        }
                                
                        
                        var listItem = domConstruct.create("li", null, this.domNode, possion);
                        
                        this._doBeforeItemSet(item, listItem);
                        
                        domConstruct.place(item.domNode ? item.domNode : item, listItem);
                        
                        this._doAfterItemSet(item, listItem);

                        if(this.itemStyle){
                                domStyle.set(listItem, this.itemStyle);
                        }
                        
                        if(this.itemClass){
                                domClass.add(listItem, this.itemClass);
                        }
                },
                
                _doBeforeItemSet : function(item, listItem)
                {
                        
                },
                
                _doAfterItemSet : function(item, listItem)
                {
                        
                },
                
                _getItemCountAttr : function()
                {
                        return this.domNode.children.length;
                },
                
                _getContainerHeightAttr : function()
                {
                        var container = domGeom.getContentBox(this.domNode);
                        return container.h;
                },
                
                getChildElament : function(index)
                {
                        var elament = this.domNode.childNodes[index];
                        
                        return elament;
                },
                
                placeItemToPostion : function(item, index)
                {
                        var elament = this.domNode.childNodes[index];
                        domConstruct.place(elament, item);
                },
                
                deleteChild : function(index)
                {
                        var elament = this.getChildElament(index);
                        
                        domConstruct.destroy(elament);
                },
                
                deleteAllChildern : function()
                {
                        while(this.domNode.children.length > 0)
                        {
                                this.deleteChild(0);
                        }
                }
        
        });
});
},
'dijit/_base/sniff':function(){
define("dijit/_base/sniff", [ "dojo/uacss" ], function(){
	// module:
	//		dijit/_base/sniff
	// summary:
	//		Back compatibility module, new code should require dojo/uacss directly instead of this module.
});

},
'curam/util/LocalConfig':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 04-Mar-2014  MV  [CR00421036] Added implementation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

/**
 * @name curam.util.LocalConfig
 * @namespace Provides support for accessing application properties
 *    from JavaScript and overriding their values locally.
 *      <p/>
 *    The basic idea is that desired options are determined at application
 *    init time (in the main app page) and they are "seeded" using this API.
 *    From then on JavaScript code can access the values of these options.
 *      <p/>
 *    It is then possible to override individual option values and the API
 *    will persist the overrides in local Web storage. This allows
 *    for individual users to control the behaviour of the application
 *    without the need to set options globally for all users in admin pages.
 *      <p/>
 *    Please note the option values and overrides are stored in the "top"
 *    browser window, even if the API is used from nested iframes.
 */
define("curam/util/LocalConfig", [
        ], function() {
  
  // the code below ensures we store the values globally
  var globalName = function(name) {
        return 'curam_util_LocalConfig_' + name;
      },
      initGlobal = function(name, value) {
        var gName = globalName(name);
        
        // only initialize if it doesn't already exist!
        if (typeof top[gName] === 'undefined') {
          top[gName] = value;
        }
        
        return top[gName];
      },
      getGlobal = function(name) {
        return top[globalName(name)];
      };
  
  initGlobal('seedValues', {}),
  initGlobal('overrides', {});
  
  var _checkIsString = function(value, valName) {
    if (typeof value !== 'undefined' && typeof value !== 'string') {
      throw new Error('Invalid ' + valName + ' type: ' + typeof value
          + '; expected string');
    }
  };
  
  var LocalConfig =
  /**
   * @lends curam.util.LocalConfig.prototype
   */
  {
    /**
     * Sets the "global" value for the option.
     * This can be later overriden to provide a local value. 
     *
     * @param name Name of the option to set.
     * @param value Value of the option to set. If this is undefined
     *  then default value will be used instead.
     * @param defaultValue Default value to be used if value is not specified.
     */
    seedOption: function(name, value, defaultValue) {
      _checkIsString(value, 'value');
      _checkIsString(defaultValue, 'defaultValue');
      
      // code below treats null as a valid value to be used
      getGlobal('seedValues')[name] =
          (typeof value !== 'undefined') ? value : defaultValue;
    },
    
    /**
     * Sets local override for the value of given option.
     * The override is persisted to local Web storage, if available.
     * 
     * @param name Name of the option to override.
     * @param value The local value to be used.
     */
    overrideOption: function(name, value) {
      _checkIsString(value, 'value');

      // persist the value, if possible
      if(typeof(Storage) !== "undefined") {
        localStorage[name] = value;

      // otherwise just store in memory - override will not be permanent
      } else {
        getGlobal('overrides')[name] = value;
      }
    },
    
    /**
     * Reads the value of the given option. It takes the values in the following
     * precedence order. The first that is found is returned.
     * <ul>
     * <li>override from local persistent Web storage</li>
     * <li>override from session memory</li>
     * <li>the global value</li>
     * <li>return the provided default value</li>
     * </ul>
     * 
     * @param name Name of the option to read.
     * @param defaultValue Default value to return if value is not set.
     * @returns Value of the option or provided default value.
     */
    readOption: function(name, defaultValue) {
      _checkIsString(defaultValue, 'defaultValue');

      var finalValue = null;

      // use local persistent value, if possible and if available
      if (typeof(Storage) !== "undefined"
          && typeof localStorage[name] !== 'undefined') {
        finalValue = localStorage[name];
    
      // otherwise fall back to local non-persistent override
      } else if (typeof getGlobal('overrides')[name] !== 'undefined') {
        finalValue = getGlobal('overrides')[name];
  
      // otherwise fall back to the seed value
      } else if (typeof getGlobal('seedValues')[name] !== 'undefined') {
        finalValue = getGlobal('seedValues')[name];
  
      // otherwise fall back to the specified default value
      } else {
        finalValue = defaultValue;
      }

      return finalValue;
    },
    
    /**
     * Completely removes the option from configuration.
     * After using this method the readOption() will return the provided
     * default value.
     *
     * @param name Name of the option to clear.
     */
    clearOption: function(name) {
      if(typeof(Storage) !== "undefined") {
        localStorage.removeItem(name);
      }
      delete getGlobal('overrides')[name];
      delete getGlobal('seedValues')[name];
    }
  };
  
  return LocalConfig;
  
});

},
'cwtk/eligibilityresults/ProgramAction':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/eligibilityresults/ProgramAction", [
    "dojo", 
    "dojo/_base/declare"
], function(dojo, declare){

		return declare("cwtk.eligibilityresults.ProgramAction", null, {
		
            execute : function(args) {
                var motivationID = args.motivationID;	
                var programID = args.programID;	
                var url = args.url;	
        		this.action(motivationID, programID, url);
        		
        	},
        	
        	action: function(motivationID, programID, url) {
        	
        	    var actionId = 'program-action-button-' + programID + '_button';
        	    
        		cw.eligibilityResult.transitions.openEnrollment(dojo.byId(actionId));
        		
        		cw.fragment.load("background-panel", url, {motivationID:motivationID, programID:programID});
        		
        		cw.form.clearUpdateListeners();
                cw.form.addUpdateListener(function(){
                    cw.ajax.updateContent('cw-eligibility-results-context-bar')
                });
                cw.form.addUpdateListener(function(){
                    cw.ajax.updateContent('program-right-' + programID)
                });
        	}  
		          
		});

});


},
'dojo/data/util/sorter':function(){
define("dojo/data/util/sorter", ["dojo/_base/lang"], function(lang) {
	// module:
	//		dojo/data/util/sorter
	// summary:
	//		TODOC

var sorter = lang.getObject("dojo.data.util.sorter", true);

sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	//	summary:
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.

	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

sorter.createSortFunction = function(	/* attributes array */sortSpec, /*dojo.data.core.Read*/ store){
	//	summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

return sorter;
});

},
'url:idx/oneui/templates/MenuHeading.html':"<tr class=\"dijitReset dijitMenuItem oneuiMenuHeading\" role=\"presentation\" tabindex=\"-1\">\r\n\t<td class=\"dijitReset dijitMenuItemLabel oneuiMenuHeadingLabel\" colspan=\"4\" data-dojo-attach-point=\"containerNode\"></td>\r\n</tr>",
'cwtk/widget/TitlePane':function(){
require({cache:{
'url:cwtk/widget/templates/TitlePane.html':"<div id=\"${id}\" class=\"cw-title-pane\">\r\n  <div class=\"cw-title-pane-title\" data-dojo-attach-point=\"_titleNode\">\r\n    <div class=\"cw-title-pane-text-div\">\r\n      ${title}\r\n    </div>\r\n    <div class=\"cw-title-pane-link-div\">\r\n      <div class=\"cw-title-pane-show-div\"\r\n        data-dojo-attach-point=\"_showButtonDiv\"\r\n        data-dojo-attach-event=\"ondijitclick: _slideEvent\" style=\"display:none\">\r\n        <a title=\"${labelShow}\" class=\"cw-title-pane-show-image\">${labelShow}</a>\r\n      </div>\r\n      <div class=\"cw-title-pane-hide-div\"\r\n        data-dojo-attach-point=\"_hideButtonDiv\"\r\n        data-dojo-attach-event=\"ondijitclick: _slideEvent\">\r\n        <a title=\"${labelHide}\" class=\"cw-title-pane-hide-image\">${labelHide}</a>\r\n      </div>\r\n      <div class=\"cw-title-pane-help\" data-dojo-attach-point=\"_helpNode\">\r\n        <!--title pane help-->\r\n        <div class=\"cw-popup-link cw-popup-link-dialog\">\r\n          <div data-dojo-attach-event=\"ondijitclick: _helpEvent\" class=\"cw-title-pane-help\">\r\n            <a title=\"${labelHelp}\" class=\"cw-title-pane-help-image\">${labelHelp}</a>\r\n          </div>\r\n          <div class=\"cw-dialog\" data-dojo-type=\"dijit.Dialog\" data-dojo-attach-point=\"_helpDialog\"\r\n            data-dojo-props=\"title: '${labelHelp}'\">\r\n            <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-attach-point=\"_helpPanel\"\r\n              href=\"${hrefHelp}\">\r\n              <!--help-->\r\n              <button data-dojo-type=\"dijit.form.Button\" onclick=\"cw.form.dismiss(this);\">\r\n                Dismiss\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"cw-title-pane-actions\" data-dojo-attach-point=\"_actionsNode\">\r\n        <!--title pane actions-->\r\n        <span class=\"cw-title-pane-actions\" data-dojo-type=\"cwtk.widget.DropDown\"\r\n          data-dojo-props=\"forcedOrientation:'R'\">\r\n          <div>\r\n            <a title=\"${labelActions}\" class=\"cw-title-pane-actions-image\">${labelActions}</a>\r\n          </div>\r\n          <div class=\"cw-tooltip-dialog\" data-dojo-type=\"dijit.TooltipDialog\" data-dojo-attach-point=\"_actionsDialog\">\r\n            <div data-dojo-type=\"dijit.layout.ContentPane\"\r\n              data-dojo-attach-point=\"_actionsPanel\" href=\"${hrefActions}\">\r\n              <!--actions-->\r\n            </div>\r\n          </div> </span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"cw-title-pane-display-panel\" data-dojo-attach-point=\"containerNode\">\r\n    <!--Content here.-->\r\n  </div>\r\n</div>"}});
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/TitlePane", [
    "dojo/_base/declare", 
    "dojo/_base/lang", 
    "dojo/query", 
    "dijit/layout/ContentPane", 
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin", 
    "dojo/text!./templates/TitlePane.html", 
    "dojo/fx/easing"
], function(declare, lang, query, ContentPane, _TemplatedMixin, _WidgetsInTemplateMixin, template) {
	return declare("cwtk.widget.TitlePane", [ContentPane, _TemplatedMixin, _WidgetsInTemplateMixin], {

		templateString : template,

		widgetsInTemplate : true,

		baseClass : "cw-title-pane",

		_titleNode : null,

		_showButtonDiv : null,
		_hideButtonDiv : null,

		_helpNode : null,
		_helpPanel : null,
		_helpDialog : null,

		_actionsNode : null,
		_actionsPanel : null,
		_actionsDialog : null,

        /* Properties */
		isPrimary : false,
		
		/* Labels */
		title : 'Title Pane',
		labelActions : 'Actions',
		labelHelp : 'Help',
		labelHide : 'Hide',
		labelShow : 'Show',
		
		/* Content */
		hrefActions : '',
		hrefHelp : '',

		/**
		 * Overridden to mixin the override resources if provided.
		 */
		postMixInProperties : function() {
			this.inherited(arguments);
		},

		/**
		 * Override to force startup/layout on BorderContainer.
		 */
		startup : function() {
			this.inherited(arguments);
			this._init();
		},

		/**
		 *
		 */
		_init : function() {
			console.log('init title pane');
		},

		_swap : function(nodeA, nodeB) {

			if (dojo.style(nodeA, 'display') === 'none') {
				nodeA.style.display = "";
				nodeB.style.display = "none";
			} else {
				nodeA.style.display = "none";
				nodeB.style.display = "";
			}

		},

		_slidePanel : function(panel) {

			var hidden = dojo.style(panel, 'display') === 'none';

			if (hidden) {
				dojo.fx.wipeIn({
					node : panel,
					duration : 300,
					easing : dojo.fx.easing.linear
				}).play();
			} else {
				dojo.fx.wipeOut({
					node : panel,
					duration : 300,
					easing : dojo.fx.easing.linear
				}).play();
			}
		},

		_slide : function() {

			this._swap(this._showButtonDiv, this._hideButtonDiv);

			this._slidePanel(this.containerNode);
		},

		_slideEvent : function(event) {
			this._slide();
		},

		_helpEvent : function(event) {
			dijit.byId(this._helpDialog).show();
		},
		
		refreshActions : function() {
		    if (this._actionPanel) {
		        dijit.byId(this._actionPanel.id).refresh();
		    }
		}
	});
});

},
'dojo/window':function(){
define("dojo/window", ["./_base/lang", "./_base/sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct) {

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

// module:
//		dojo/window
// summary:
//		TODOC

var window = lang.getObject("dojo.window", true);

/*=====
dojo.window = {
	// summary:
	//		TODO
};
window = dojo.window;
=====*/

window.getBox = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var
		scrollRoot = (baseWindow.doc.compatMode == 'BackCompat') ? baseWindow.body() : baseWindow.doc.documentElement,
		// get scroll position
		scroll = geom.docScroll(), // scrollRoot.scrollTop/Left should work
		w, h;

	if(has("touch")){ // if(scrollbars not supported)
		var uiWindow = baseWindow.doc.parentWindow || baseWindow.doc.defaultView;   // use UI window, not dojo.global window. baseWindow.doc.parentWindow probably not needed since it's not defined for webkit
		// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
		w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
		h = uiWindow.innerHeight || scrollRoot.clientHeight;
	}else{
		// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
		// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
		w = scrollRoot.clientWidth;
		h = scrollRoot.clientHeight;
	}
	return {
		l: scroll.x,
		t: scroll.y,
		w: w,
		h: h
	};
};

window.get = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(has("ie") && window !== document.parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc.parentWindow || doc.defaultView;	//	Window
};

window.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view using minimal movement, if it is not already.

	// Don't rely on node.scrollIntoView working just because the function is there since
	// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
	// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
	// and when there's a fixed position scrollable element

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
		node = dom.byId(node);
		var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
			body = baseWindow.body(doc),
			html = doc.documentElement || body.parentNode,
			isIE = has("ie"),
			isWK = has("webkit");
		// if an untested browser, then use the native method
		if(node == body || node == html){ return; }
		if(!(has("mozilla") || isIE || isWK || has("opera")) && ("scrollIntoView" in node)){
			node.scrollIntoView(false); // short-circuit to native if possible
			return;
		}
		var	backCompat = doc.compatMode == 'BackCompat',
			rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
			rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
			scrollRoot = (isWK || backCompat) ? body : html,
			nodePos = pos || geom.position(node),
			el = node.parentNode,
			isFixed = function(el){
				return (isIE <= 6 || (isIE == 7 && backCompat))
					? false
					: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
			};
		if(isFixed(node)){ return; } // nothing to do
		while(el){
			if(el == body){ el = scrollRoot; }
			var	elPos = geom.position(el),
				fixedPos = isFixed(el),
				rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

			if(el == scrollRoot){
				elPos.w = rootWidth; elPos.h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
				if(elPos.x < 0 || !isIE || isIE >= 9){ elPos.x = 0; } // older IE can have values > 0
				if(elPos.y < 0 || !isIE || isIE >= 9){ elPos.y = 0; }
			}else{
				var pb = geom.getPadBorderExtents(el);
				elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
				var clientSize = el.clientWidth,
					scrollBarSize = elPos.w - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
						elPos.x += scrollBarSize;
					}
					elPos.w = clientSize;
				}
				clientSize = el.clientHeight;
				scrollBarSize = elPos.h - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.h = clientSize;
				}
			}
			if(fixedPos){ // bounded by viewport, not parents
				if(elPos.y < 0){
					elPos.h += elPos.y; elPos.y = 0;
				}
				if(elPos.x < 0){
					elPos.w += elPos.x; elPos.x = 0;
				}
				if(elPos.y + elPos.h > rootHeight){
					elPos.h = rootHeight - elPos.y;
				}
				if(elPos.x + elPos.w > rootWidth){
					elPos.w = rootWidth - elPos.x;
				}
			}
			// calculate overflow in all 4 directions
			var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
				t = nodePos.y - elPos.y, // beyond top: < 0
				r = l + nodePos.w - elPos.w, // beyond right: > 0
				bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
			var s, old;
			if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
				s = Math[l < 0? "max" : "min"](l, r);
				if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
				old = el.scrollLeft;
				el.scrollLeft += s;
				s = el.scrollLeft - old;
				nodePos.x -= s;
			}
			if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
				s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
				old = el.scrollTop;
				el.scrollTop += s;
				s = el.scrollTop - old;
				nodePos.y -= s;
			}
			el = (el != scrollRoot) && !fixedPos && el.parentNode;
		}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

return window;
});

},
'dijit/_base/popup':function(){
define("dijit/_base/popup", [
	"dojo/dom-class", // domClass.contains
	"../popup",
	"../BackgroundIframe"	// just loading for back-compat, in case client code is referencing it
], function(domClass, popup){

// module:
//		dijit/_base/popup
// summary:
//		Old module for popups, new code should use dijit/popup directly


// Hack support for old API passing in node instead of a widget (to various methods)
var origCreateWrapper = popup._createWrapper;
popup._createWrapper = function(widget){
	if(!widget.declaredClass){
		// make fake widget to pass to new API
		widget = {
			_popupWrapper: (widget.parentNode && domClass.contains(widget.parentNode, "dijitPopup")) ?
				widget.parentNode : null,
			domNode: widget,
			destroy: function(){}
		};
	}
	return origCreateWrapper.call(this, widget);
};

// Support old format of orient parameter
var origOpen = popup.open;
popup.open = function(/*dijit.popup.__OpenArgs*/ args){
	// Convert old hash structure (ex: {"BL": "TL", ...}) of orient to format compatible w/new popup.open() API.
	// Don't do conversion for:
	//		- null parameter (that means to use the default positioning)
	//		- "R" or "L" strings used to indicate positioning for context menus (when there is no around node)
	//		- new format, ex: ["below", "above"]
	//		- return value from deprecated dijit.getPopupAroundAlignment() method,
	//			ex: ["below", "above"]
	if(args.orient && typeof args.orient != "string" && !("length" in args.orient)){
		var ary = [];
		for(var key in args.orient){
			ary.push({aroundCorner: key, corner: args.orient[key]});
		}
		args.orient = ary;
	}

	return origOpen.call(this, args);
};

return popup;
});

},
'dijit/registry':function(){
define("dijit/registry", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window", // win.body
	"."	// dijit._scopeName
], function(array, has, unload, win, dijit){

	// module:
	//		dijit/registry
	// summary:
	//		Registry of existing widget on page, plus some utility methods.
	//		Must be accessed through AMD api, ex:
	//		require(["dijit/registry"], function(registry){ registry.byId("foo"); })

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		A set of widgets indexed by id

		length: 0,

		add: function(/*dijit._Widget*/ widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit._Widget
			//		Any dijit._Widget subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit._Widget
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit._Widget
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(dijit.registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit._Widget[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(/*DomNode*/ root){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else{
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.getAttribute && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	/*=====
	dijit.registry = {
		// summary:
		//		A list of widgets on a page.
	};
	=====*/
	dijit.registry = registry;

	return registry;
});

},
'dijit/_base/focus':function(){
define("dijit/_base/focus", [
	"dojo/_base/array", // array.forEach
	"dojo/dom", // dom.isDescendant
	"dojo/_base/lang", // lang.isArray
	"dojo/topic", // publish
	"dojo/_base/window", // win.doc win.doc.selection win.global win.global.getSelection win.withGlobal
	"../focus",
	".."	// for exporting symbols to dijit
], function(array, dom, lang, topic, win, focus, dijit){

	// module:
	//		dijit/_base/focus
	// summary:
	//		Deprecated module to monitor currently focused node and stack of currently focused widgets.
	//		New code should access dijit/focus directly.

	lang.mixin(dijit, {
		// _curFocus: DomNode
		//		Currently focused item on screen
		_curFocus: null,

		// _prevFocus: DomNode
		//		Previously focused item on screen
		_prevFocus: null,

		isCollapsed: function(){
			// summary:
			//		Returns true if there is no text selected
			return dijit.getBookmark().isCollapsed;
		},

		getBookmark: function(){
			// summary:
			//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
			var bm, rg, tg, sel = win.doc.selection, cf = focus.curNode;

			if(win.global.getSelection){
				//W3C Range API for selections.
				sel = win.global.getSelection();
				if(sel){
					if(sel.isCollapsed){
						tg = cf? cf.tagName : "";
						if(tg){
							//Create a fake rangelike item to restore selections.
							tg = tg.toLowerCase();
							if(tg == "textarea" ||
									(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
								sel = {
									start: cf.selectionStart,
									end: cf.selectionEnd,
									node: cf,
									pRange: true
								};
								return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
							}
						}
						bm = {isCollapsed:true};
						if(sel.rangeCount){
							bm.mark = sel.getRangeAt(0).cloneRange();
						}
					}else{
						rg = sel.getRangeAt(0);
						bm = {isCollapsed: false, mark: rg.cloneRange()};
					}
				}
			}else if(sel){
				// If the current focus was a input of some sort and no selection, don't bother saving
				// a native bookmark.  This is because it causes issues with dialog/page selection restore.
				// So, we need to create psuedo bookmarks to work with.
				tg = cf ? cf.tagName : "";
				tg = tg.toLowerCase();
				if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
					if(sel.type && sel.type.toLowerCase() == "none"){
						return {
							isCollapsed: true,
							mark: null
						}
					}else{
						rg = sel.createRange();
						return {
							isCollapsed: rg.text && rg.text.length?false:true,
							mark: {
								range: rg,
								pRange: true
							}
						};
					}
				}
				bm = {};

				//'IE' way for selections.
				try{
					// createRange() throws exception when dojo in iframe
					//and nothing selected, see #9632
					rg = sel.createRange();
					bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
				}catch(e){
					bm.isCollapsed = true;
					return bm;
				}
				if(sel.type.toUpperCase() == 'CONTROL'){
					if(rg.length){
						bm.mark=[];
						var i=0,len=rg.length;
						while(i<len){
							bm.mark.push(rg.item(i++));
						}
					}else{
						bm.isCollapsed = true;
						bm.mark = null;
					}
				}else{
					bm.mark = rg.getBookmark();
				}
			}else{
				console.warn("No idea how to store the current selection for this browser!");
			}
			return bm; // Object
		},

		moveToBookmark: function(/*Object*/ bookmark){
			// summary:
			//		Moves current selection to a bookmark
			// bookmark:
			//		This should be a returned object from dijit.getBookmark()

			var _doc = win.doc,
				mark = bookmark.mark;
			if(mark){
				if(win.global.getSelection){
					//W3C Rangi API (FF, WebKit, Opera, etc)
					var sel = win.global.getSelection();
					if(sel && sel.removeAllRanges){
						if(mark.pRange){
							var n = mark.node;
							n.selectionStart = mark.start;
							n.selectionEnd = mark.end;
						}else{
							sel.removeAllRanges();
							sel.addRange(mark);
						}
					}else{
						console.warn("No idea how to restore selection for this browser!");
					}
				}else if(_doc.selection && mark){
					//'IE' way.
					var rg;
					if(mark.pRange){
						rg = mark.range;
					}else if(lang.isArray(mark)){
						rg = _doc.body.createControlRange();
						//rg.addElement does not have call/apply method, so can not call it directly
						//rg is not available in "range.addElement(item)", so can't use that either
						array.forEach(mark, function(n){
							rg.addElement(n);
						});
					}else{
						rg = _doc.body.createTextRange();
						rg.moveToBookmark(mark);
					}
					rg.select();
				}
			}
		},

		getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
			// summary:
			//		Called as getFocus(), this returns an Object showing the current focus
			//		and selected text.
			//
			//		Called as getFocus(widget), where widget is a (widget representing) a button
			//		that was just pressed, it returns where focus was before that button
			//		was pressed.   (Pressing the button may have either shifted focus to the button,
			//		or removed focus altogether.)   In this case the selected text is not returned,
			//		since it can't be accurately determined.
			//
			// menu: dijit._Widget or {domNode: DomNode} structure
			//		The button that was just pressed.  If focus has disappeared or moved
			//		to this button, returns the previous focus.  In this case the bookmark
			//		information is already lost, and null is returned.
			//
			// openedForWindow:
			//		iframe in which menu was opened
			//
			// returns:
			//		A handle to restore focus/selection, to be passed to `dijit.focus`
			var node = !focus.curNode || (menu && dom.isDescendant(focus.curNode, menu.domNode)) ? dijit._prevFocus : focus.curNode;
			return {
				node: node,
				bookmark: node && (node == focus.curNode) && win.withGlobal(openedForWindow || win.global, dijit.getBookmark),
				openedForWindow: openedForWindow
			}; // Object
		},

		// _activeStack: dijit._Widget[]
		//		List of currently active widgets (focused widget and it's ancestors)
		_activeStack: [],

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the <iframe> itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle to pass to unregisterIframe()
			return focus.registerIframe(iframe);
		},

		unregisterIframe: function(/*Object*/ handle){
			// summary:
			//		Unregisters listeners on the specified iframe created by registerIframe.
			//		After calling be sure to delete or null out the handle itself.
			// handle:
			//		Handle returned by registerIframe()

			handle && handle.remove();
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle to pass to unregisterWin()

			return focus.registerWin(targetWindow, effectiveNode);
		},

		unregisterWin: function(/*Handle*/ handle){
			// summary:
			//		Unregisters listeners on the specified window (either the main
			//		window or an iframe's window) according to handle returned from registerWin().
			//		After calling be sure to delete or null out the handle itself.

			handle && handle.remove();
		}
	});

	// Override focus singleton's focus function so that dijit.focus()
	// has backwards compatible behavior of restoring selection (although
	// probably no one is using that).
	focus.focus = function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			focus._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && win.withGlobal(openedForWindow || win.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				win.withGlobal(openedForWindow || win.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	};

	// For back compatibility, monitor changes to focused node and active widget stack,
	// publishing events and copying changes from focus manager variables into dijit (top level) variables
	focus.watch("curNode", function(name, oldVal, newVal){
		dijit._curFocus = newVal;
		dijit._prevFocus = oldVal;
		if(newVal){
			topic.publish("focusNode", newVal);	// publish
		}
	});
	focus.watch("activeStack", function(name, oldVal, newVal){
		dijit._activeStack = newVal;
	});

	focus.on("widget-blur", function(widget, by){
		topic.publish("widgetBlur", widget, by);	// publish
	});
	focus.on("widget-focus", function(widget, by){
		topic.publish("widgetFocus", widget, by);	// publish
	});

	return dijit;
});

},
'dijit/PopupMenuBarItem':function(){
define("dijit/PopupMenuBarItem", [
	"dojo/_base/declare", // declare
	"./PopupMenuItem",
	"./MenuBarItem"
], function(declare, PopupMenuItem, MenuBarItem){

	// module:
	//		dijit/PopupMenuBarItem
	// summary:
	//		Item in a MenuBar like "File" or "Edit", that spawns a submenu when pressed (or hovered)

	var _MenuBarItemMixin = MenuBarItem._MenuBarItemMixin;

/*=====
	var PopupMenuItem = dijit.PopupMenuItem;
	var _MenuBarItemMixin = dijit._MenuBarItemMixin;
=====*/

	return declare("dijit.PopupMenuBarItem", [PopupMenuItem, _MenuBarItemMixin], {
		// summary:
		//		Item in a MenuBar like "File" or "Edit", that spawns a submenu when pressed (or hovered)
	});
});

},
'dijit/form/_FormMixin':function(){
define("dijit/form/_FormMixin", [
	"dojo/_base/array", // array.every array.filter array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/window" // winUtils.scrollIntoView
], function(array, declare, kernel, lang, winUtils){

	// module:
	//		dijit/form/_FormMixin
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a <form> node or dijit.form.Form widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		//	TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
		//
		//

		_getDescendantFormWidgets: function(/*dijit._WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features.
			//		1 - it will highlight any sub-widgets that are not
			//			valid
			//		2 - it will call focus() on the first invalid
			//			sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!lang.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the setTimeout(..., 0) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Remove connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			array.forEach(this._childConnections || [], lang.hitch(this, "disconnect"));
			array.forEach(this._childWatches || [], function(w){ w.unwatch(); });
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		Setup connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			//
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			var _this = this;

			// Remove old connections, if any
			this.disconnectChildren();

			this._descendants = this._getDescendantFormWidgets();

			// (Re)set this.value and this.state.   Send watch() notifications but not on startup.
			var set = inStartup ? function(name, val){ _this[name] = val; } : lang.hitch(this, "_set");
			set("value", this.get("value"));
			set("state", this._getState());

			// Monitor changes to error state and disabled state in order to update
			// Form.state
			var conns = (this._childConnections = []),
				watches = (this._childWatches = []);
			array.forEach(array.filter(this._descendants,
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget changes validity state - or
				// whenever the disabled attribute on that widget is changed.
				array.forEach(["state", "disabled"], function(attr){
					watches.push(widget.watch(attr, function(){
						_this.set("state", _this._getState());
					}));
				});
			});

			// And monitor calls to child.onChange so we can update this.value
			var onChange = function(){
				// summary:
				//		Called when child's value or disabled state changes

				// Use setTimeout() to collapse value changes in multiple children into a single
				// update to my value.   Multiple updates will occur on:
				//	1. Form.set()
				//	2. Form.reset()
				//	3. user selecting a radio button (which will de-select another radio button,
				//		 causing two onChange events)
				if(_this._onChangeDelayTimer){
					clearTimeout(_this._onChangeDelayTimer);
				}
				_this._onChangeDelayTimer = setTimeout(function(){
					delete _this._onChangeDelayTimer;
					_this._set("value", _this.get("value"));
				}, 10);
			};
			array.forEach(
				array.filter(this._descendants, function(item){ return item.onChange; } ),
				function(widget){
					// When a child widget's value changes,
					// the efficient thing to do is to just update that one attribute in this.value,
					// but that gets a little complicated when a checkbox is checked/unchecked
					// since this.value["checkboxName"] contains an array of all the checkboxes w/the same name.
					// Doing simple thing for now.
					conns.push(_this.connect(widget, "onChange", onChange));

					// Disabling/enabling a child widget should remove it's value from this.value.
					// Again, this code could be more efficient, doing simple thing for now.
					watches.push(widget.watch("disabled", onChange));
				}
			);
		},

		startup: function(){
			this.inherited(arguments);

			// Initialize value and valid/invalid state tracking.  Needs to be done in startup()
			// so that children are initialized.
			this.connectChildren(true);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.disconnectChildren();
			this.inherited(arguments);
		}

	});
});

},
'dijit/BackgroundIframe':function(){
define("dijit/BackgroundIframe", [
	"require",			// require.toUrl
	".",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie"), has("mozilla"), has("quirks")
	"dojo/_base/window" // win.doc.createElement
], function(require, dijit, config, domConstruct, domStyle, lang, on, has, win){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("bgIframe", has("ie") || has("mozilla"));
	// summary:
	//		new dijit.BackgroundIframe(node)
	//		Makes a background iframe as a child of node, that fills
	//		area (and position) of node

	// TODO: remove _frames, it isn't being used much, since popups never release their
	// iframes (see [22236])
	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = win.doc.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index schenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node)
		//			Makes a background iframe as a child of node, that fills
		//			area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, function(){
					this.resize(node);
				}));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			// 		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'dijit/layout/TabController':function(){
require({cache:{
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode\" data-dojo-attach-event='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' data-dojo-attach-point='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' data-dojo-attach-point='tabContent'>\n        \t<div role=\"presentation\" data-dojo-attach-point='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" data-dojo-attach-point='iconNode' />\n\t\t        <span data-dojo-attach-point='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t        \t\tdata-dojo-attach-event='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n"}});
define("dijit/layout/TabController", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-class", // domClass.toggle
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch lang.trim
	"./StackController",
	"../Menu",
	"../MenuItem",
	"dojo/text!./templates/_TabButton.html",
	"dojo/i18n!../nls/common"
], function(declare, dom, domAttr, domClass, i18n, lang, StackController, Menu, MenuItem, template){

/*=====
	var StackController = dijit.layout.StackController;
	var Menu = dijit.Menu;
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/layout/TabController
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.

	var TabButton = declare("dijit.layout._TabButton", StackController.StackButton, {
		// summary:
		//		A tab (the thing you click to select a pane).
		// description:
		//		Contains the title of the pane, and optionally a close-button to destroy the pane.
		//		This is an internal widget and should not be instantiated directly.
		// tags:
		//		private

		// baseClass: String
		//		The CSS class applied to the domNode.
		baseClass: "dijitTab",

		// Apply dijitTabCloseButtonHover when close button is hovered
		cssStateNodes: {
			closeNode: "dijitTabCloseButton"
		},

		templateString: template,

		// Override _FormWidget.scrollOnFocus.
		// Don't scroll the whole tab container into view when the button is focused.
		scrollOnFocus: false,

		buildRendering: function(){
			this.inherited(arguments);

			dom.setSelectable(this.containerNode, false);
		},

		startup: function(){
			this.inherited(arguments);
			var n = this.domNode;

			// Required to give IE6 a kick, as it initially hides the
			// tabs until they are focused on.
			setTimeout(function(){
				n.className = n.className;
			}, 1);
		},

		_setCloseButtonAttr: function(/*Boolean*/ disp){
			// summary:
			//		Hide/show close button
			this._set("closeButton", disp);
			domClass.toggle(this.innerDiv, "dijitClosable", disp);
			this.closeNode.style.display = disp ? "" : "none";
			if(disp){
				var _nlsResources = i18n.getLocalization("dijit", "common");
				if(this.closeNode){
					domAttr.set(this.closeNode,"title", _nlsResources.itemClose);
				}
				// add context menu onto title button
				this._closeMenu = new Menu({
					id: this.id+"_Menu",
					dir: this.dir,
					lang: this.lang,
					textDir: this.textDir,
					targetNodeIds: [this.domNode]
				});

				this._closeMenu.addChild(new MenuItem({
					label: _nlsResources.itemClose,
					dir: this.dir,
					lang: this.lang,
					textDir: this.textDir,
					onClick: lang.hitch(this, "onClickCloseButton")
				}));
			}else{
				if(this._closeMenu){
					this._closeMenu.destroyRecursive();
					delete this._closeMenu;
				}
			}
		},
		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		takes an HTML string.
			//		Inherited ToggleButton implementation will Set the label (text) of the button;
			//		Need to set the alt attribute of icon on tab buttons if no label displayed
			this.inherited(arguments);
			if(!this.showLabel && !this.params.title){
				this.iconNode.alt = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		},

		destroy: function(){
			if(this._closeMenu){
				this._closeMenu.destroyRecursive();
				delete this._closeMenu;
			}
			this.inherited(arguments);
		}
	});

	var TabController = declare("dijit.layout.TabController", StackController, {
		// summary:
		// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
		//		Used internally by `dijit.layout.TabContainer`.
		// description:
		//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
		//		TabController also monitors the TabContainer, and whenever a pane is
		//		added or deleted updates itself accordingly.
		// tags:
		//		private

		baseClass: "dijitTabController",

		templateString: "<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'></div>",

		// tabPosition: String
		//		Defines where tabs go relative to the content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		// buttonWidget: Constructor
		//		The tab widget to create to correspond to each page
		buttonWidget: TabButton,

		_rectifyRtlTabList: function(){
			// summary:
			//		For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE

			if(0 >= this.tabPosition.indexOf('-h')){ return; }
			if(!this.pane2button){ return; }

			var maxWidth = 0;
			for(var pane in this.pane2button){
				var ow = this.pane2button[pane].innerDiv.scrollWidth;
				maxWidth = Math.max(maxWidth, ow);
			}
			//unify the length of all the tabs
			for(pane in this.pane2button){
				this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
			}
		}
	});

	TabController.TabButton = TabButton;	// for monkey patching

	return TabController;
});

},
'dijit/_MenuBase':function(){
define("dijit/_MenuBase", [
	"./popup",
	"dojo/window",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/array"	// array.indexOf
], function(pm, winUtils, _Widget, _KeyNavContainer, _TemplatedMixin,
	declare, dom, domAttr, domClass, lang, array){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _KeyNavContainer = dijit._KeyNavContainer;
=====*/

// module:
//		dijit/_MenuBase
// summary:
//		Base class for Menu and MenuBar

return declare("dijit._MenuBase",
	[_Widget, _TemplatedMixin, _KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.  In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ /*===== evt =====*/){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(lang.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				pm.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.disabled){ return false; }

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			pm.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		pm.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || ["after", "before"],
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: lang.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;

		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		if(this.popupHoverHandle){
			this.disconnect(this.popupHoverHandle);
		}
		this.popupHoverHandle = this.connect(popup.domNode, "onmouseenter", "_onPopupHover");

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.  Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(lang.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//		Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		domClass.replace(this.domNode, "dijitMenuActive", "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ /*===== e =====*/){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		domClass.replace(this.domNode, "dijitMenuPassive", "dijitMenuActive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();

		if(this.currentPopup){
			// If focus is on a descendant MenuItem then move focus to me,
			// because IE doesn't like it when you display:none a node with focus,
			// and also so keyboard users don't lose control.
			// Likely, immediately after a user defined onClick handler will move focus somewhere
			// else, like a Dialog.
			if(array.indexOf(this._focusManager.activeStack, this.id) >= 0){
				domAttr.set(this.focusedChild.focusNode, "tabIndex", this.tabIndex);
				this.focusedChild.focusNode.focus();
			}
			// Close all popups that are open and descendants of this menu
			pm.close(this.currentPopup);
			this.currentPopup = null;
		}

		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

});

},
'curam/widget/containers/TransitionContainer':function(){
define("curam/widget/containers/TransitionContainer", ["dojo/_base/declare",
        "dojo/parser",
        "dijit/_Widget",
        "dojo/dom-construct",
        "dojo/_base/window",
        "dijit/layout/ContentPane", 
        "dojo/dom-class",
        "dojo/_base/fx",
        "curam/util/cache/CacheLRU",
        "dojox/layout/ContentPane",
        "dojo/_base/array",
        "dojo/query"],
        function(declare,
                        parser,
        		_Widget,
        		domConstruct,
        		window,
        		ContentPane,
        		domClass,
        		fx,
        		CacheLRU,
        		ContentPaneX,
        		array,
        		query) {
	return declare("curam.widget.containers.TransitionContainer",[ContentPane], 
{
		transitionDuration: 200,
		_panelCache : null,
		_currentlyDisplayedPanelKey : -1,
		_panelToLoadKey : -1,
		_beenProcessed : false,
		
		constructor: function(args) {
			
	        var cacheMapArgs = 
	        	{
	        		maxSize : 5
	        	};
			this._panelCache = new CacheLRU(cacheMapArgs);			
	    },
	    
	    /**
	     * Function builds up the section of the the URL
	     * that contains the parameters
	     */
	    _buildPramUrl : function(jsonIn)
	    {
	    	var outPut = "";
	    	
	    	if(jsonIn.param != null)
	    	{	    		
	    		array.forEach(jsonIn.param, function(entry, i){
	    			if(i >0)
	    			{
	    				outPut +="&";
	    			}
	    			outPut += encodeURIComponent(entry.paramKey) + "=" + encodeURIComponent(entry.paramValue);
	    		});	    		
	    	}
	    	
	    	return outPut;
	    	
	    },
		
		_setDisplayPanelAttr : function(jsonIn)
		{
			
				jsonIn = this._doDataTranslation(jsonIn);
				
				
				var pramUrl = this._buildPramUrl(jsonIn);
				
				var compositeKey = jsonIn.key; // + pramUrl; fix from Martin to remove parameters as part of key.
				
				if(this._currentlyDisplayedPanelKey != compositeKey)
				{
					// touch the current displayed panel to keep it alive for 
					// transition out
					this._panelCache.getItem(this._currentlyDisplayedPanelKey);
					var panel = this._panelCache.getItem(compositeKey);
					
					if(panel == null)
					{
						// page does not exist  new one needs to be created
						
						var uri = this._doResourceLookUp(jsonIn, pramUrl, compositeKey);						

						uri = this._applyParamToUri(jsonIn, pramUrl, compositeKey, uri);
						
						var contentPane = new ContentPaneX({
							//content: jsonIn.key + " Hey I'm a panel "+new Date().getTime(),
							href : uri,
							preload : false, // set to false as the transition container decides when to load
							preventCache:true,
							executeScripts:true,  // runs embeded javascript
				                        scriptHasHooks:true,// merits further look but not stable in dojox layout
				                        refreshOnShow:false, // set to false as the transition container decides when to refresh
				                        open : false, // set so it does not fetch remote content when not visable
							style :{
								padding : 0,
								border : 0,
								opacity : 0
							}
						});//}).placeAt(window.body());
						
						contentPane = this._contentPaneCreated(jsonIn, pramUrl, compositeKey, contentPane);
	
						//style.set(contentPane.domNode, "opacity", "0");
						var fadeInArgs = {
						        node: contentPane.domNode,
						        duration: this.transitionDuration,
						        onEnd : dojo.hitch(this,this._panelFadeInComplete)
						      };
						
						var cbFadeOut = dojo.hitch(this,function(key)
						{
							this._panelFadedOut(key);
						});
						var fadeOutArgs = {
						        node: contentPane.domNode,
						        duration: this.transitionDuration,
						        onEnd : function(){		
						        	console.info('Fadding out onEnd Called for : '+ compositeKey);
						        	cbFadeOut(compositeKey);
						        }
						      };
						var fadeIn = fx.fadeIn(fadeInArgs);
						var fadeOut = fx.fadeOut(fadeOutArgs);
						
						
						panel = {
								panel : contentPane,
								fadeIn : fadeIn,
								fadeOut : fadeOut
						};
						
						var options = {
								callback : function(key, item)
								{
									try
									{
										item.panel.destroy();
										delete item;
									}	
							  		catch(err){
										console.error(err);
									}
								}
						};
						
						this._panelCache.addItem(compositeKey,panel,options);
						
						
					}
					else
					{
						//do nothing as panel all ready exists  
						console.info("Doning nothing as panel all ready exists");
                        // NOTE: temp workaround to ensure the content panes are always refreshed
                        // when this is called through the "displayContent" API.
                        // ExternalApplication.js sets "forceRefresh".
		                                  if (jsonIn.forceRefresh) {
		                                    // do nothing as all ready displayed
		                                    var panel = this._panelCache.getItem(compositeKey);
		                                    if (panel) {
		                                      var uri = this._doResourceLookUp(jsonIn, pramUrl, compositeKey);                                                
		                                      uri = this._applyParamToUri(jsonIn, pramUrl, compositeKey, uri);
		                                      // trigger refresh, applying new parameters.
		                                      panel.panel.open = false; // don't want a refresh when the href is set on the next line.
		                                      panel.panel.set("href", uri);
		                                    }
		                                  }
						
					}
					
					this._doSwapPanel(jsonIn, compositeKey);
					
					
				}
				else
				{
                      // NOTE: Same workaround as above, except this time we do the lookups with "_currentlyDisplayedPanelKey"
			          if (jsonIn.forceRefresh) {
        		            // do nothing as all ready displayed
    				    var panel = this._panelCache.getItem(this._currentlyDisplayedPanelKey);
    				    if (panel) {
  				      var uri = this._doResourceLookUp(jsonIn, pramUrl, this._currentlyDisplayedPanelKey);                                                
                                      uri = this._applyParamToUri(jsonIn, pramUrl, compositeKey, uri);
                                      // trigger refresh, applying new parameters.
                                      panel.panel.set("href", uri);
  				    }
				  }
				}
		},
		
		/**
		 * Function to be over writen that allows the 
		 * transalation of the data that of different format
		 * for loading resources 
		 */
		_doDataTranslation : function(jsonIn)
		{
			return jsonIn; 
		},
		
		/**
		 * Utility function to be over writen that allows custisation of the 
		 *  the contentPanes as they are created
		 */
		_contentPaneCreated : function(jsonIn, pramUrl, compositeKey, contentPane)
		{
			return contentPane;
		},
	    
	    /**
	     * Function to be over written to allow look up of
	     * reference identifer to URI
	     */
	    _doResourceLookUp : function(jsonIn, pramUrl, compositeKey)
	    {
	    	var uri = jsonIn.key;
	    	
	    	return uri;
	    },
	    
	    /**
	     * Function applys parameters to the requested URI
	     */
	    _applyParamToUri : function (jsonIn, pramUrl, compositeKey, uri)
	    {
	    	if(pramUrl.length >0)
	    	{
	    		if(uri.indexOf("?") != -1)
	    		{
	    			uri += "&";
	    		}
	    		else
	    		{
	    			uri += "?";
	    		}
	    		uri += pramUrl;
	    	}
	    	
	    	return uri;
	    },
	    
	    /**
	     * function called with the display panel has been faded
	     */
	    _panelFadedOut : function(panelFadedOutKey)
            {
                var container = this._panelCache.getItem(panelFadedOutKey);
                container.panel.cancel();

                if(container.panel.domNode != null)
                {
                        domClass.add(container.panel.domNode, "dijitHidden");
                }
                else 
                {
                        //im null on the fade out
                }
                container.panel.open = false;

                // if the ContentPane has an iframe within it, it will be
                // reloaded when the call to domConstruct.place is made below.
                // This is a quick fix to reset the iframe source to prevent
                // unnecessary reloads. In universal access, a reload can cause
                // harm because some of the pages do "auto" logons, clear the
                // user session etc. So, we don't want these pages to be
                // reloaded unintentionally.
                // TODO: this quick fix triggers a harmless "about:blank"
                // request. destroy the iframe "properly". 
                array.forEach(
                  query("iframe", container.panel.domNode), function(iframe) {
                    iframe.src="";
                });
                
                this._fadedOutPanelProcess(container);

                domConstruct.place(container.panel.domNode, window.body());
                this._panelFadeOutComplete();
                this._panelFadeIn();
            },

            /**
             * Utility function to be over written that allows
             * additional processing of a panel after it has been 
             * faded out 
             */
            _fadedOutPanelProcess : function(container)
            {

            },

            /**
             * Utility function to be over written 
             */
            _panelFadeOutComplete : function()
            {

            },
            
            /**
             * function fades in a panel to be displayed
             */
	    _panelFadeIn : function()
	    {
	    	if (this._panelToFadeInKey != -1)
	    	{
		    	var newPanel = this._panelCache.getItem(this._panelToFadeInKey);
		    	this.set('content', newPanel.panel);
		    	
		    	this._currentlyDisplayedPanelKey = this._panelToFadeInKey;
	        	//domConstruct.place(newPanel.panel.domNode, this.domNode);	
				
				
		    	if(newPanel.panel.domNode != null)
		    	{
		    		domClass.remove(newPanel.panel.domNode, "dijitHidden");
		    	}
		    	else 
		    	{
		    		//"im null on the fade IN
		    	}	    	
		    	
		    	newPanel.panel.onLoad = function()
				{	
					newPanel.fadeIn.play();			
				};
			newPanel.panel.open = true;
			newPanel.panel.refresh();
                        newPanel.panel.resize();
	    	}	    	
	    },
	    
	    /**
	     * Utility function to be over written 
	     */
	    _panelFadeInComplete : function()
	    {
	    	
	    },	
		
		/**
		 * Function swaps out the panel that is currently displayed
		 * for the new panel 
		 */
		_doSwapPanel : function(jsonIn, key)
		{

			var currentlyDisplayedPanel = this._panelCache.getItem(this._currentlyDisplayedPanelKey);
			
			if(currentlyDisplayedPanel != null)
			{
				this.fadeOutDisplay(key);			
			}
			else
			{
				this._panelToFadeInKey = key;
				this._panelFadeIn();
			}
			
		},
		
		fadeOutDisplay : function(key)
		{
			console.info("fadeOutDisplay");
			if(key == null)
			{
				key = -1;
			}			
			var currentlyDisplayedPanel = this._panelCache.getItem(this._currentlyDisplayedPanelKey);
			
			if(currentlyDisplayedPanel != null)
			{
				if(currentlyDisplayedPanel.fadeIn.status() == "playing"){
					console.info("fadeOutDisplay  - currentlyDisplayedPanel.fadeIn.status() == playing"  );
					currentlyDisplayedPanel.fadeIn.stop();
					currentlyDisplayedPanel.fadeOut.play();
				}
				else
				{
					if(currentlyDisplayedPanel.fadeOut.status() != "playing"){
						currentlyDisplayedPanel.fadeOut.play();
					}
				}

				this._panelToFadeInKey = key;
			}
			else
			{
				this._panelToFadeInKey = key;	
				this._panelFadeIn();
			}
			
		},
		
		/**
		 * Clean up functions
		 */
		destroy: function() {
			try
			{
				this._panelCache.destroy();			
			}	
	  		catch(err){
				console.error(err);
			}	  		
			this.inherited(arguments);
		}
		
	
	});
});

},
'dijit/layout/ScrollingTabController':function(){
require({cache:{
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\"\n\t\t\tdata-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t\tdata-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>",
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"onclick:_onClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" data-dojo-attach-point=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" data-dojo-attach-point=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>"}});
define("dijit/layout/ScrollingTabController", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/fx", // Animation
	"dojo/_base/lang", // lang.hitch
	"dojo/query", // query
	"dojo/_base/sniff", // has("ie"), has("webkit"), has("quirks")
	"../registry",	// registry.byId()
	"dojo/text!./templates/ScrollingTabController.html",
	"dojo/text!./templates/_ScrollingTabControllerButton.html",
	"./TabController",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_WidgetsInTemplateMixin",
	"../Menu",
	"../MenuItem",
	"../form/Button",
	"../_HasDropDown",
	"dojo/NodeList-dom" // NodeList.style
], function(array, declare, domClass, domGeometry, domStyle, fx, lang, query, has,
	registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin,
	Menu, MenuItem, Button, _HasDropDown){

/*=====
var _WidgetsInTemplateMixin = dijit._WidgetsInTemplateMixin;
var Menu = dijit.Menu;
var _HasDropDown = dijit._HasDropDown;
var TabController = dijit.layout.TabController;
=====*/


// module:
//		dijit/layout/ScrollingTabController
// summary:
//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
//		all fitting on a single row.


var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	baseClass: "dijitTabController dijitScrollingTabController",

	templateString: tabControllerTemplate,

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	widgetsInTemplate: true,

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	// Override default behavior mapping class to DOMNode
	_setClassAttr: { node: "containerNode", type: "class" },

	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
			domClass.add(n, "tabStrip-disabled")
		}

		domClass.add(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// TabController is hidden until it finishes drawing, to give
		// a less visually jumpy instantiation.   When it's finished, set visibility to ""
		// to that the tabs are hidden/shown depending on the container's visibility setting.
		domStyle.set(this.domNode, "visibility", "");
		this._postStartup = true;
	},

	onAddChild: function(page, insertIndex){
		this.inherited(arguments);

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
		array.forEach(["label", "iconClass"], function(attr){
			this.pane2watches[page.id].push(
				this.pane2button[page.id].watch(attr, lang.hitch(this, function(){
					if(this._postStartup && this._dim){
						this.resize(this._dim);
					}
				}))
			);
		}, this);

		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		domStyle.set(this.containerNode, "width",
			(domStyle.get(this.containerNode, "width") + 200) + "px");
	},

	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
		var button = this.pane2button[page.id];
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		this._btnWidth = 0;
		this._buttons = query("> .tabStripButton", this.domNode).filter(function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
				this._btnWidth += domGeometry.getMarginSize(btn).w;
				return true;
			}else{
				domStyle.set(btn, "display", "none");
				return false;
			}
		}, this);
	},

	_getTabsWidth: function(){
		var children = this.getChildren();
		if(children.length){
			var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			return rightTab.offsetLeft + domStyle.get(rightTab, "width") - leftTab.offsetLeft;
		}else{
			return 0;
		}
	},

	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || domStyle.get(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

		// Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		cb.h = this.scrollNode.offsetHeight;
		domGeometry.setContentSize(this.domNode, cb);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
		this._leftBtn.layoutAlign = "left";
		this._rightBtn.layoutAlign = "right";
		this._menuBtn.layoutAlign = this.isLeftToRight() ? "right" : "left";
		layoutUtils.layoutChildren(this.domNode, this._contentBox,
			[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());

		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},

	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
		return (this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")) ? this.scrollNode.scrollLeft :
				domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width")
					 + (has("ie") == 8 ? -1 : 1) * this.scrollNode.scrollLeft;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
		if(this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")){
			return val;
		}else{
			var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
			return (has("ie") == 8 ? -1 : 1) * (val - maxScroll);
		}
	},

	onSelectChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

		var tab = this.pane2button[page.id];
		if(!tab || !page){return;}

		var node = tab.domNode;

		// Save the selection
		if(node != this._selectedTab){
			this._selectedTab = node;

			// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
			if(this._postResize){
				var sl = this._getScroll();

				if(sl > node.offsetLeft ||
						sl + domStyle.get(this.scrollNode, "width") <
						node.offsetLeft + domStyle.get(node, "width")){
					this.createSmoothScroll().play();
				}
			}
		}

		this.inherited(arguments);
	},

	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),		// about 500px
			containerWidth = domStyle.get(this.containerNode, "width"),	// 50,000px
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,
				max: this.isLeftToRight() ?
					(children[children.length-1].domNode.offsetLeft + domStyle.get(children[children.length-1].domNode, "width")) - scrollNodeWidth :
					maxPossibleScroll
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},

	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
		var pos = (n.offsetLeft + domStyle.get(n, "width")/2) - scrollNodeWidth/2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new fx.Animation({
				beforeBegin: function(){
					if(this.curve){ delete this.curve; }
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new fx._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

		return anim; // dojo._Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !domClass.contains(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
		this.doSlide(-1,this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
		//		If the direction is 1, the widget scrolls to the right, if it is
		//		-1, it scrolls to the left.

		if(node && domClass.contains(node, "dijitTabDisabled")){return;}

		var sWidth = domStyle.get(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: buttonTemplate,

		// Override inherited tabIndex: 0 from dijit.form.Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
	isFocusable: function(){ return false; }
});
/*=====
ScrollingTabControllerButtonMixin = dijit.layout._ScrollingTabControllerButtonMixin;
=====*/

// Class used in template
declare("dijit.layout._ScrollingTabControllerButton",
	[Button, ScrollingTabControllerButtonMixin]);

// Class used in template
declare(
	"dijit.layout._ScrollingTabControllerMenuButton",
	[Button, _HasDropDown, ScrollingTabControllerButtonMixin],
{
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new Menu({
			id: this.containerId + "_menu",
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		});
		var container = registry.byId(this.containerId);
		array.forEach(container.getChildren(), function(page){
			var menuItem = new MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		callback();
	},

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

return ScrollingTabController;
});

},
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:cwtk/widget/templates/Rotator.html':"<div class=\"cw-rotator\">\n\t<div class=\"cw-rotator-nav cw-rotator-nav-prev\" \n\t\tdata-dojo-attach-point=\"prevNode\" \n\t\tdata-dojo-attach-event=\"ondijitclick: _prev\">\n\t\t<ul>\n\t\t\t<li class=\"dojoxRotatorPrev dojoxRotatorIcon dojoxRotatorFirst dojoxRotatorLast\">\n\t\t\t\t<a href=\"#\">\n\t\t\t\t\t<span>Prev</span>\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\t<div class=\"cw-rotator-nav cw-rotator-nav-next\" \n\t\tdata-dojo-attach-point=\"nextNode\" data-dojo-attach-event=\"ondijitclick: _next\">\n\t\t<ul>\n\t\t\t<li class=\"dojoxRotatorPrev dojoxRotatorIcon dojoxRotatorFirst dojoxRotatorLast\">\n\t\t\t\t<a href=\"#\">\n\t\t\t\t\t<span>Next</span>\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\t<div class=\"cw-rotator-container-wrapper\" data-dojo-attach-point=\"containerWrapper\">\n\t\t<div class=\"cw-rotator-container\" \n\t\t\tdata-dojo-attach-point=\"containerNode\">\n\t\t</div>\n\t</div>\n</div>\n",
'curam/util/Constants':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/Constants", ["curam/define"
        ], function() {
  
  /*
   * Modification History
   * --------------------
   * 05-Jul-2011  KW  [CR00275353] Initial version
   */

  /**
   * Maintains a list of parameter name constants. 
   */
  curam.define.singleton("curam.util.Constants", {
    RETURN_PAGE_PARAM: "__o3rpu"
  });
  
  return curam.util.Constants;
});

},
'dijit/_OnDijitClickMixin':function(){
define("dijit/_OnDijitClickMixin", [
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window" // win.doc.addEventListener win.doc.attachEvent win.doc.detachEvent
], function(on, array, keys, declare, has, unload, win){

	// module:
	//		dijit/_OnDijitClickMixin
	// summary:
	//		Mixin so you can pass "ondijitclick" to this.connect() method,
	//		as a way to handle clicks by mouse, or by keyboard (SPACE/ENTER key)


	// Keep track of where the last keydown event was, to help avoid generating
	// spurious ondijitclick events when:
	// 1. focus is on a <button> or <a>
	// 2. user presses then releases the ENTER key
	// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
	// 4. onkeyup event fires, causing the ondijitclick handler to fire
	var lastKeyDownNode = null;
	if(has("ie")){
		(function(){
			var keydownCallback = function(evt){
				lastKeyDownNode = evt.srcElement;
			};
			win.doc.attachEvent('onkeydown', keydownCallback);
			unload.addOnWindowUnload(function(){
				win.doc.detachEvent('onkeydown', keydownCallback);
			});
		})();
	}else{
		win.doc.addEventListener('keydown', function(evt){
			lastKeyDownNode = evt.target;
		}, true);
	}

	// Custom a11yclick (a.k.a. ondijitclick) event
	var a11yclick = function(node, listener){
		if(/input|button/i.test(node.nodeName)){
			// pass through, the browser already generates click event on SPACE/ENTER key
			return on(node, "click", listener);
		}else{
			// Don't fire the click event unless both the keydown and keyup occur on this node.
			// Avoids problems where focus shifted to this node or away from the node on keydown,
			// either causing this node to process a stray keyup event, or causing another node
			// to get a stray keyup event.

			function clickKey(/*Event*/ e){
				return (e.keyCode == keys.ENTER || e.keyCode == keys.SPACE) &&
						!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
			}
			var handles = [
				on(node, "keypress", function(e){
					//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
					if(clickKey(e)){
						// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
						lastKeyDownNode = e.target;

						// Prevent viewport scrolling on space key in IE<9.
						// (Reproducible on test_Button.html on any of the first dijit.form.Button examples)
						// Do this onkeypress rather than onkeydown because onkeydown.preventDefault() will
						// suppress the onkeypress event, breaking _HasDropDown
						e.preventDefault();
					}
				}),

				on(node, "keyup", function(e){
					//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
					if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
						//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
						lastKeyDownNode = null;
						listener.call(this, e);
					}
				}),

				on(node, "click", function(e){
					// and connect for mouse clicks too (or touch-clicks on mobile)
					listener.call(this, e);
				})
			];

			return {
				remove: function(){
					array.forEach(handles, function(h){ h.remove(); });
				}
			};
		}
	};

	return declare("dijit._OnDijitClickMixin", null, {
		connect: function(
				/*Object|null*/ obj,
				/*String|Function*/ event,
				/*String|Function*/ method){
			// summary:
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			// description:
			//		Provide widget-specific analog to connect.connect, except with the
			//		implicit use of this widget as the target object.
			//		This version of connect also provides a special "ondijitclick"
			//		event which triggers on a click or space or enter keyup.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new dijit.form.Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});
});

},
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n",
'dijit/layout/StackController':function(){
define("dijit/layout/StackController", [
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/sniff", // has("ie")
	"../focus",		// focus.focus()
	"../registry",	// registry.byId
	"../_Widget",
	"../_TemplatedMixin",
	"../_Container",
	"../form/ToggleButton",
	"dojo/i18n!../nls/common"
], function(array, declare, event, keys, lang, has,
			focus, registry, _Widget, _TemplatedMixin, _Container, ToggleButton){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _Container = dijit._Container;
	var ToggleButton = dijit.form.ToggleButton;
=====*/

	// module:
	//		dijit/layout/StackController
	// summary:
	//		Set of buttons to select a page in a `dijit.layout.StackContainer`

	var StackButton = declare("dijit.layout._StackButton", ToggleButton, {
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		// closeButton: Boolean
		//		When true, display close button for this tab
		closeButton: false,
		
		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this.inherited(arguments);
			this.focusNode.removeAttribute("aria-pressed");
		},

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			(this.focusNode || this.domNode).setAttribute("role", "tab");
		},

		onClick: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			focus.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});


	var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {
		// summary:
		//		Set of buttons to select a page in a `dijit.layout.StackContainer`
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

		baseClass: "dijitStackController",

		templateString: "<span role='tablist' data-dojo-attach-event='onkeypress'></span>",

		// containerId: [const] String
		//		The id of the page container that I point to
		containerId: "",

		// buttonWidget: [const] Constructor
		//		The button widget to create to correspond to each page
		buttonWidget: StackButton,

		constructor: function(){
			this.pane2button = {};		// mapping from pane id to buttons
			this.pane2connects = {};	// mapping from pane id to this.connect() handles
			this.pane2watches = {};		// mapping from pane id to watch() handles
		},

		postCreate: function(){
			this.inherited(arguments);

			// Listen to notifications from StackContainer
			this.subscribe(this.containerId+"-startup", "onStartup");
			this.subscribe(this.containerId+"-addChild", "onAddChild");
			this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
			this.subscribe(this.containerId+"-selectChild", "onSelectChild");
			this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
		},

		onStartup: function(/*Object*/ info){
			// summary:
			//		Called after StackContainer has finished initializing
			// tags:
			//		private
			array.forEach(info.children, this.onAddChild, this);
			if(info.selected){
				// Show button corresponding to selected pane (unless selected
				// is null because there are no panes)
				this.onSelectChild(info.selected);
			}
		},

		destroy: function(){
			for(var pane in this.pane2button){
				this.onRemoveChild(registry.byId(pane));
			}
			this.inherited(arguments);
		},

		onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
			// summary:
			//		Called whenever a page is added to the container.
			//		Create button corresponding to the page.
			// tags:
			//		private

			// create an instance of the button widget
			// (remove typeof buttonWidget == string support in 2.0)
			var cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
			var button = new cls({
				id: this.id + "_" + page.id,
				label: page.title,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir,
				showLabel: page.showTitle,
				iconClass: page.iconClass,
				closeButton: page.closable,
				title: page.tooltip
			});
			button.focusNode.setAttribute("aria-selected", "false");


			// map from page attribute to corresponding tab button attribute
			var pageAttrList = ["title", "showTitle", "iconClass", "closable", "tooltip"],
				buttonAttrList = ["label", "showLabel", "iconClass", "closeButton", "title"];

			// watch() so events like page title changes are reflected in tab button
			this.pane2watches[page.id] = array.map(pageAttrList, function(pageAttr, idx){
				return page.watch(pageAttr, function(name, oldVal, newVal){
					button.set(buttonAttrList[idx], newVal);
				});
			});

			// connections so that clicking a tab button selects the corresponding page
			this.pane2connects[page.id] = [
				this.connect(button, 'onClick', lang.hitch(this,"onButtonClick", page)),
				this.connect(button, 'onClickCloseButton', lang.hitch(this,"onCloseButtonClick", page))
			];

			this.addChild(button, insertIndex);
			this.pane2button[page.id] = button;
			page.controlButton = button;	// this value might be overwritten if two tabs point to same container
			if(!this._currentChild){ // put the first child into the tab order
				button.focusNode.setAttribute("tabIndex", "0");
				button.focusNode.setAttribute("aria-selected", "true");
				this._currentChild = page;
			}
			// make sure all tabs have the same length
			if(!this.isLeftToRight() && has("ie") && this._rectifyRtlTabList){
				this._rectifyRtlTabList();
			}
		},

		onRemoveChild: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever a page is removed from the container.
			//		Remove the button corresponding to the page.
			// tags:
			//		private

			if(this._currentChild === page){ this._currentChild = null; }

			// disconnect/unwatch connections/watches related to page being removed
			array.forEach(this.pane2connects[page.id], lang.hitch(this, "disconnect"));
			delete this.pane2connects[page.id];
			array.forEach(this.pane2watches[page.id], function(w){ w.unwatch(); });
			delete this.pane2watches[page.id];

			var button = this.pane2button[page.id];
			if(button){
				this.removeChild(button);
				delete this.pane2button[page.id];
				button.destroy();
			}
			delete page.controlButton;
		},

		onSelectChild: function(/*dijit._Widget*/ page){
			// summary:
			//		Called when a page has been selected in the StackContainer, either by me or by another StackController
			// tags:
			//		private

			if(!page){ return; }

			if(this._currentChild){
				var oldButton=this.pane2button[this._currentChild.id];
				oldButton.set('checked', false);
				oldButton.focusNode.setAttribute("aria-selected", "false");
				oldButton.focusNode.setAttribute("tabIndex", "-1");
			}

			var newButton=this.pane2button[page.id];
			newButton.set('checked', true);
			newButton.focusNode.setAttribute("aria-selected", "true");
			this._currentChild = page;
			newButton.focusNode.setAttribute("tabIndex", "0");
			var container = registry.byId(this.containerId);
			container.containerNode.setAttribute("aria-labelledby", newButton.id);
		},

		onButtonClick: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever one of my child buttons is pressed in an attempt to select a page
			// tags:
			//		private

			if(this._currentChild.id === page.id) {
				//In case the user clicked the checked button, keep it in the checked state because it remains to be the selected stack page.
				var button=this.pane2button[page.id];
				button.set('checked', true);
			}
			var container = registry.byId(this.containerId);
			container.selectChild(page);
		},

		onCloseButtonClick: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
			// tags:
			//		private

			var container = registry.byId(this.containerId);
			container.closeChild(page);
			if(this._currentChild){
				var b = this.pane2button[this._currentChild.id];
				if(b){
					focus.focus(b.focusNode || b.domNode);
				}
			}
		},

		// TODO: this is a bit redundant with forward, back api in StackContainer
		adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Helper for onkeypress to find next/previous button
			// tags:
			//		private

			if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
			// find currently focused button in children array
			var children = this.getChildren();
			var current = array.indexOf(children, this.pane2button[this._currentChild.id]);
			// pick next button to focus on
			var offset = forward ? 1 : children.length - 1;
			return children[ (current + offset) % children.length ]; // dijit._Widget
		},

		onkeypress: function(/*Event*/ e){
			// summary:
			//		Handle keystrokes on the page list, for advancing to next/previous button
			//		and closing the current page if the page is closable.
			// tags:
			//		private

			if(this.disabled || e.altKey ){ return; }
			var forward = null;
			if(e.ctrlKey || !e._djpage){
				switch(e.charOrCode){
					case keys.LEFT_ARROW:
					case keys.UP_ARROW:
						if(!e._djpage){ forward = false; }
						break;
					case keys.PAGE_UP:
						if(e.ctrlKey){ forward = false; }
						break;
					case keys.RIGHT_ARROW:
					case keys.DOWN_ARROW:
						if(!e._djpage){ forward = true; }
						break;
					case keys.PAGE_DOWN:
						if(e.ctrlKey){ forward = true; }
						break;
					case keys.HOME:
					case keys.END:
						var children = this.getChildren();
						if(children && children.length){
							children[e.charOrCode == keys.HOME ? 0 : children.length-1].onClick();
						}
						event.stop(e);
						break;
					case keys.DELETE:
						if(this._currentChild.closable){
							this.onCloseButtonClick(this._currentChild);
						}
						event.stop(e);
						break;
					default:
						if(e.ctrlKey){
							if(e.charOrCode === keys.TAB){
								this.adjacent(!e.shiftKey).onClick();
								event.stop(e);
							}else if(e.charOrCode == "w"){
								if(this._currentChild.closable){
									this.onCloseButtonClick(this._currentChild);
								}
								event.stop(e); // avoid browser tab closing.
							}
						}
				}
				// handle next/previous page navigation (left/right arrow, etc.)
				if(forward !== null){
					this.adjacent(forward).onClick();
					event.stop(e);
				}
			}
		},

		onContainerKeyPress: function(/*Object*/ info){
			// summary:
			//		Called when there was a keypress on the container
			// tags:
			//		private
			info.e._djpage = info.page;
			this.onkeypress(info.e);
		}
	});

	StackController.StackButton = StackButton;	// for monkey patching

	return StackController;
});

},
'dojox/layout/ExpandoPane':function(){
require({cache:{
'url:dojox/layout/resources/ExpandoPane.html':"<div class=\"dojoxExpandoPane\">\n\t<div dojoAttachPoint=\"titleWrapper\" class=\"dojoxExpandoTitle\">\n\t\t<div class=\"dojoxExpandoIcon\" dojoAttachPoint=\"iconNode\" dojoAttachEvent=\"onclick:toggle\"><span class=\"a11yNode\">X</span></div>\t\t\t\n\t\t<span class=\"dojoxExpandoTitleNode\" dojoAttachPoint=\"titleNode\">${title}</span>\n\t</div>\n\t<div class=\"dojoxExpandoWrapper\" dojoAttachPoint=\"cwrapper\" dojoAttachEvent=\"ondblclick:_trap\">\n\t\t<div class=\"dojoxExpandoContent\" dojoAttachPoint=\"containerNode\"></div>\n\t</div>\n</div>\n"}});
define("dojox/layout/ExpandoPane", ["dojo/_base/kernel","dojo/_base/lang","dojo/_base/declare","dojo/_base/array", 
	"dojo/_base/connect","dojo/_base/event","dojo/_base/fx","dojo/dom-style",
	"dojo/dom-class","dojo/dom-geometry","dojo/text!./resources/ExpandoPane.html",
	"dijit/layout/ContentPane","dijit/_TemplatedMixin","dijit/_Contained","dijit/_Container"], 
  function(kernel,lang,declare,arrayUtil,connectUtil,eventUtil,baseFx,domStyle,domClass,domGeom,
		template,ContentPane,TemplatedMixin,Contained,Container) {
/*=====
var ContentPane = dijit.layout.ContentPane;
var TemplatedMixin = dijit._TemplatedMixin;
var Contained = dijit._Contained;
var Container = dijit._Container;
  =====*/
kernel.experimental("dojox.layout.ExpandoPane"); // just to show it can be done?

return declare("dojox.layout.ExpandoPane", [ContentPane, TemplatedMixin, Contained, Container],{
	// summary: An experimental collapsing-pane for dijit.layout.BorderContainer
	//
	// description:
	//		Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	//		command, and supports having Layout Children as direct descendants
	//

	//maxHeight: "",
	//maxWidth: "",
	//splitter: false,
	attributeMap: lang.delegate(ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" }
	}),
	
	templateString: template,

	// easeOut: String|Function
	//		easing function used to hide pane
	easeOut: "dojo._DefaultEasing", // FIXME: This won't work with globalless AMD
	
	// easeIn: String|Function
	//		easing function use to show pane
	easeIn: "dojo._DefaultEasing", // FIXME: This won't work with globalless AMD
	
	// duration: Integer
	//		duration to run show/hide animations
	duration: 420,

	// startExpanded: Boolean
	//		Does this widget start in an open (true) or closed (false) state
	startExpanded: true,

	// previewOpacity: Float
	//		A value from 0 .. 1 indicating the opacity to use on the container
	//		when only showing a preview
	previewOpacity: 0.75,
	
	// previewOnDblClick: Boolean
	//		If true, will override the default behavior of a double-click calling a full toggle.
	//		If false, a double-click will cause the preview to popup
	previewOnDblClick: false,

	baseClass: "dijitExpandoPane",

	postCreate: function(){
		this.inherited(arguments);
		this._animConnects = [];

		this._isHorizontal = true;
		
		if(lang.isString(this.easeOut)){
			this.easeOut = lang.getObject(this.easeOut);
		}
		if(lang.isString(this.easeIn)){
			this.easeIn = lang.getObject(this.easeIn);
		}
	
		var thisClass = "", rtl = !this.isLeftToRight();
		if(this.region){
			switch(this.region){
				case "trailing" :
				case "right" :
					thisClass = rtl ? "Left" : "Right";
					break;
				case "leading" :
				case "left" :
					thisClass = rtl ? "Right" : "Left";
					break;
				case "top" :
					thisClass = "Top";
					break;
				case "bottom" :
					thisClass = "Bottom";
					break;
			}
			domClass.add(this.domNode, "dojoxExpando" + thisClass);
			domClass.add(this.iconNode, "dojoxExpandoIcon" + thisClass);
			this._isHorizontal = /top|bottom/.test(this.region);
		}
		domStyle.set(this.domNode, {
			overflow: "hidden",
			padding:0
		});
		
		this.connect(this.domNode, "ondblclick", this.previewOnDblClick ? "preview" : "toggle");
		
		if(this.previewOnDblClick){
			this.connect(this.getParent(), "_layoutChildren", lang.hitch(this, function(){
				this._isonlypreview = false;
			}));
		}
		
	},
	
	_startupSizes: function(){
		
		this._container = this.getParent();
		this._closedSize = this._titleHeight = domGeom.getMarginBox(this.titleWrapper).h;
		
		if(this.splitter){
			// find our splitter and tie into it's drag logic
			var myid = this.id;
			arrayUtil.forEach(dijit.registry.toArray(), function(w){
				if(w && w.child && w.child.id == myid){
					this.connect(w,"_stopDrag","_afterResize");
				}
			}, this);
		}
		
		this._currentSize = domGeom.getContentBox(this.domNode);	// TODO: can compute this from passed in value to resize(), see _LayoutWidget for example
		this._showSize = this._currentSize[(this._isHorizontal ? "h" : "w")];
		this._setupAnims();

		if(this.startExpanded){
			this._showing = true;
		}else{
			this._showing = false;
			this._hideWrapper();
			this._hideAnim.gotoPercent(99,true);
		}
		
		this._hasSizes = true;
	},
	
	_afterResize: function(e){
		var tmp = this._currentSize;						// the old size
		this._currentSize = domGeom.getMarginBox(this.domNode);	// the new size
		var n = this._currentSize[(this._isHorizontal ? "h" : "w")]
		if(n > this._titleHeight){
			if(!this._showing){
				this._showing = !this._showing;
				this._showEnd();
			}
			this._showSize = n;
			this._setupAnims();
		}else{
			this._showSize = tmp[(this._isHorizontal ? "h" : "w")];
			this._showing = false;
			this._hideWrapper();
			this._hideAnim.gotoPercent(89,true);
		}
		
	},
	
	_setupAnims: function(){
		// summary: Create the show and hide animations
		arrayUtil.forEach(this._animConnects, connectUtil.disconnect);
		
		var _common = {
				node:this.domNode,
				duration:this.duration
			},
			isHorizontal = this._isHorizontal,
			showProps = {},
			hideProps = {},
			dimension = isHorizontal ? "height" : "width"
		;

		showProps[dimension] = {
			end: this._showSize
		};
		hideProps[dimension] = {
			end: this._closedSize
		};
		
		this._showAnim = baseFx.animateProperty(lang.mixin(_common,{
			easing:this.easeIn,
			properties: showProps
		}));
		this._hideAnim = baseFx.animateProperty(lang.mixin(_common,{
			easing:this.easeOut,
			properties: hideProps
		}));

		this._animConnects = [
			connectUtil.connect(this._showAnim, "onEnd", this, "_showEnd"),
			connectUtil.connect(this._hideAnim, "onEnd", this, "_hideEnd")
		];
	},
	
	preview: function(){
		// summary: Expand this pane in preview mode (does not affect surrounding layout)

		if(!this._showing){
			this._isonlypreview = !this._isonlypreview;
		}
		this.toggle();
	},

	toggle: function(){
		// summary: Toggle this pane's visibility
		if(this._showing){
			this._hideWrapper();
			this._showAnim && this._showAnim.stop();
			this._hideAnim.play();
		}else{
			this._hideAnim && this._hideAnim.stop();
			this._showAnim.play();
		}
		this._showing = !this._showing;
	},
	
	_hideWrapper: function(){
		// summary: Set the Expando state to "closed"
		domClass.add(this.domNode, "dojoxExpandoClosed");
		
		domStyle.set(this.cwrapper,{
			visibility: "hidden",
			opacity: "0",
			overflow: "hidden"
		});
	},
	
	_showEnd: function(){
		// summary: Common animation onEnd code - "unclose"
		domStyle.set(this.cwrapper, {
			opacity: 0,
			visibility:"visible"
		});
		baseFx.anim(this.cwrapper, {
			opacity: this._isonlypreview ? this.previewOpacity : 1
		}, 227);
		domClass.remove(this.domNode, "dojoxExpandoClosed");
		if(!this._isonlypreview){
			setTimeout(lang.hitch(this._container, "layout"), 15);
		}else{
			this._previewShowing = true;
			this.resize();
		}
	},
	
	_hideEnd: function(){
		// summary: Callback for the hide animation - "close"

		// every time we hide, reset the "only preview" state
		if(!this._isonlypreview){
			setTimeout(lang.hitch(this._container, "layout"), 25);
		}else{
			this._previewShowing = false;
		}
		this._isonlypreview = false;
		
	},
	
	resize: function(/* Object? */newSize){
		// summary:
		//		we aren't a layout widget, but need to act like one:
		// newSize: Object
		//		The size object to resize to

		if(!this._hasSizes){ this._startupSizes(newSize); }
		
		// compute size of container (ie, size left over after title bar)
		var currentSize = domGeom.getMarginBox(this.domNode);
		this._contentBox = {
			w: newSize && "w" in newSize ? newSize.w : currentSize.w,
			h: (newSize && "h" in newSize ? newSize.h : currentSize.h) - this._titleHeight
		};
		domStyle.set(this.containerNode, "height", this._contentBox.h + "px");

		if(newSize){
			domGeom.setMarginBox(this.domNode, newSize);
		}

		this._layoutChildren();
	},
	
	_trap: function(e){
		// summary: Trap stray events
		eventUtil.stop(e);
	}
});
});

},
'url:idx/oneui/templates/MenuDialog.html':"<div role=\"presentation\">\r\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\r\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" data-dojo-attach-point=\"containerNode\" role=\"dialog\" tabIndex=\"-1\"></div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\r\n</div>\r\n",
'dijit/form/_FormValueMixin':function(){
define("dijit/form/_FormValueMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/sniff", // has("ie"), has("quirks")
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, has, _FormWidgetMixin){

/*=====
	var _FormWidgetMixin = dijit.form._FormWidgetMixin;
=====*/

	// module:
	//		dijit/form/_FormValueMixin
	// summary:
	//		Mixin for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) <input> element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			domAttr.set(this.focusNode, 'readOnly', value);
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie")){ // IE won't stop the event with keypress
				this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
			}
			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		},

		_onKeyDown: function(e){
			if(e.keyCode == keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
				var te;
				if(has("ie") < 9 || (has("ie") && has("quirks"))){
					e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
					te = document.createEventObject();
					te.keyCode = keys.ESCAPE;
					te.shiftKey = e.shiftKey;
					e.srcElement.fireEvent('onkeypress', te);
				}
			}
		}
	});
});

},
'dojo/date/stamp':function(){
define("dojo/date/stamp", ["../_base/kernel", "../_base/lang", "../_base/array"], function(dojo, lang, array) {
	// module:
	//		dojo/date/stamp
	// summary:
	//		TODOC

lang.getObject("date.stamp", true, dojo);

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return dojo.date.stamp;
});

},
'cwtk/util/Commons':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/util/Commons", [
    "dojo", 
    "dojo/_base/declare",
    "dojo/io/script"
], function(dojo, declare, script){

		return declare("cwtk.util.Commons", null, {

		  addJavascript : function(jsname) {
		  
			var path = 'CDEJ/jscript/';
			
			script.get({url : path + jsname});
			
		  }
		});

});
},
'dijit/place':function(){
define("dijit/place", [
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"."	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, winUtils, dijit){

	// module:
	//		dijit/place
	// summary:
	//		Code to place a popup relative to another node


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = winUtils.getBox();

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to win.doc.body.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body().appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				   }[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				   }[corner.charAt(0)]
			};

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var mb = domGeometry. getMarginBox(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - mb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (mb.w >> 1)) - mb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - mb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (mb.h >> 1)) - mb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + mb.w),
				endY = Math.min(view.t + view.h, startYpos + mb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (mb.w - width) + (mb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).
		//
		// In RTL mode, set style.right rather than style.left so in the common case,
		// window resizes move the popup along with the aroundNode.
		var l = domGeometry.isBodyLtr(),
			s = node.style;
		s.top = best.y + "px";
		s[l ? "left" : "right"] = (l ? best.x : view.w - best.x - best.w) + "px";
		s[l ? "right" : "left"] = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	/*=====
	dijit.place.__Position = function(){
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body

		this.x = x;
		this.y = y;
	};
	=====*/

	/*=====
	dijit.place.__Rectangle = function(){
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" from backwards-compatibility.

		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	};
	=====*/

	return (dijit.place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding){
			// summary:
			//		Positions one of the node's corners at specified position
			//		such that node is fully visible in viewport.
			// description:
			//		NOTE: node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit.place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners in, like ["TR", "BL"].
			//		Possible values are:
			//			* "BL" - bottom left
			//			* "BR" - bottom right
			//			* "TL" - top left
			//			* "TR" - top right
			// padding: dijit.place.__Position?
			//		optional param to set padding, to put some buffer around the element you want to position.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode || dijit.place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			//
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			//
			// anchor:
			//		Either a DOMNode or a __Rectangle (object with x, y, width, height).
			//
			// positions:
			//		Ordered list of positions to try matching up.
			//			* before: places drop down to the left of the anchor node/widget, or to the right in the case
			//				of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//				with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//			* after: places drop down to the right of the anchor node/widget, or to the left in the case
			//				of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//				with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//			* before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//				 in the case of RTL scripts like Hebrew and Arabic
			//			* after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//				 in the case of RTL scripts like Hebrew and Arabic
			//			* above-centered: drop down is centered above anchor node
			//			* above: drop down goes above anchor node, left sides aligned
			//			* above-alt: drop down goes above anchor node, right sides aligned
			//			* below-centered: drop down is centered above anchor node
			//			* below: drop down goes below anchor node
			//			* below-alt: drop down goes below anchor node, right sides aligned
			//
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			//
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			//
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			// 		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// if around is a DOMNode (or DOMNode id), convert to coordinates
			var aroundNodePos = (typeof anchor == "string" || "offsetWidth" in anchor)
				? domGeometry.position(anchor, true)
				: anchor;

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}


			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit.place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						   }[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						   }[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	});
});

},
'dijit/layout/_LayoutWidget':function(){
define("dijit/layout/_LayoutWidget", [
	"dojo/_base/lang", // lang.mixin
	"../_Widget",
	"../_Container",
	"../_Contained",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window" // win.global
], function(lang, _Widget, _Container, _Contained,
	declare, domClass, domGeometry, domStyle, has, win){

/*=====
	var _Widget = dijit._Widget;
	var _Container = dijit._Container;
	var _Contained = dijit._Contained;
=====*/

	// module:
	//		dijit/layout/_LayoutWidget
	// summary:
	//		_LayoutWidget Base class for a _Container widget which is responsible for laying out its children.
	//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.


	return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under win.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent();
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				this.connect(win.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments passed to resize().
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				domGeometry.setMarginBox(node, changeSize);
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = lang.mixin(domGeometry.getMarginBox(node), mb);	// just use domGeometry.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling domGeometry.getContentBox() since that may fail if size was recently set)
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var be = domGeometry.getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = domGeometry.getPadExtents(node, cs);
			this._contentBox = {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			domClass.add(child.domNode, cls);
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			domClass.remove(child.domNode, cls);

			this.inherited(arguments);
		}
	});
});

},
'curam/widget/menu/BannerMenuItem':function(){
define("curam/widget/menu/BannerMenuItem", ['dojo', 'dijit/dijit', "dojo/_base/declare", "dijit/MenuItem"],
       function(dojo, dijit, declare, MenuItem) {

  return declare("curam.widget.menu.BannerMenuItem", [MenuItem], {
      iconSrc: "unknown",
      _setIconSrcAttr: {node: "iconNode",
                        type: "attribute",
                        attribute: "src" },
      iconStyle: "unknown",
      _setIconStyleAttr: {node: "iconNode",
                          type: "attribute",
                          attribute: "style" }
  });
})

},
'dojo/cldr/supplemental':function(){
define("dojo/cldr/supplemental", ["../_base/kernel", "../_base/lang", "../i18n"], function(dojo, lang) {
	// module:
	//		dojo/cldr/supplemental
	// summary:
	//		TODOC

lang.getObject("cldr.supplemental", true, dojo);

dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,sy:6,tn:6,ye:6,
		ar:0,as:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,
		il:0,'in':0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mn:0,mo:0,mp:0,
		mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,
		vi:0,zw:0
// variant. do not use?		gb:0,
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		'in':0,
		af:4,dz:4,ir:4,om:4,sa:4,ye:4,
		ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
	};

	var weekendEnd = {/*default is 0=Sunday*/
		af:5,dz:5,ir:5,om:5,sa:5,ye:5,
		ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

return dojo.cldr.supplemental;
});

},
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-point=\"valueNode\" role=\"presentation\"\n/></span>\n",
'idx/oneui/Header':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/Header", ["dojo/_base/array",
        "dojo/_base/declare",
		"dojo/_base/lang",
		"dojo/_base/window",
		"dojo/aspect",
		"dojo/dom-attr",
		"dojo/dom-class",
		"dojo/dom-construct",
		"dojo/dom-style",
		"dojo/i18n",
		"dojo/keys",
		"dojo/string",
		"dijit/_base/popup",
		"dijit/place",
		"dijit/registry",
		"dijit/_Widget",
		"dijit/_TemplatedMixin",
		"dojo/i18n!./nls/Header" ],
        function(_array,
		         declare,
				 _lang,
				 _window,
				 aspect,
				 domattr,
				 domclass,
				 domconstruct,
				 domstyle,
				 i18n,
				 keys,
				 string,
				 popup,
				 place,
				 registry,
				 _Widget,
				 _TemplatedMixin){
		
	// ensure we're not relying on the old globals, ready for 2.0
	var dojo = {}, dijit = {};
	
	// these widgets will be loaded later if needed
	var Button = function(){ log.error("dijit/form/Button has been used without being loaded"); }
	var TextBox = function(){ log.error("dijit/form/TextBox has been used without being loaded"); }
	var MenuTabController = function(){ log.error("idx/oneui/layout/MenuTabController has been used without being loaded"); }

	var prepareMenu = function(menu, cssclasses, trigger, around, trailing){
		// prepare a menu or menu bar to be presented from the One UI header widget.
		//
		// if cssclasses (array of strings) is specified, the open logic of the
		// menu is overridden to ensure that if it is used as a popup then there
		// is an outer wrapper DIV element always in place carrying the specified
		// CSS class and containing the popup DOM elements. The menu is recursively
		// processed to ensure this is true of all cascaded/popup menu items
		// within the menu. Successive elements of the array are applied to each
		// successive level of cascaded menu, and the last element is applied to 
		// all subsequent cascade levels.
		//
		// if trigger (DOM Node) is specified, the menu is assumed to be a popup
		// or cascaded menu, and is bound to the trigger.
		//
		// if around (DOM Node) is specified, the open logic of the popup is
		// overridden to position the popup to that node.
		
		if(cssclasses){
			if(cssclasses[0]){
				aspect.after(menu, "onOpen", function(){
					if(menu._popupWrapper){
						if(!menu._oneuiWrapper){
							// Create another wrapper <div> for our outermost oneui marker class.
							menu._oneuiWrapper = domconstruct.create("div", { "class": "idxHeaderContainer " + cssclasses[0] }, _window.body());

							aspect.after(menu, "destroy", function(){
								domconstruct.destroy(menu._oneuiWrapper);
								delete menu._oneuiWrapper;
							});
						}
						
						menu._oneuiWrapper.appendChild(menu._popupWrapper);
					}
				});
			}
			
			var nextcssclasses = (cssclasses.length > 1) ? cssclasses.slice(1) : cssclasses;
			_array.forEach(menu.getChildren(), function(child){
				if(child.popup){				
					prepareMenu(child.popup, nextcssclasses);
				}
				if(child.currentPage){
					domclass.add(child.domNode, "idxHeaderNavCurrentPage");
				}
			});
		}
		
		if(around){
			var _around = around;
			menu._scheduleOpen = function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
				if(!this._openTimer){
					var ltr = menu.isLeftToRight(),
						where = place.around(//placeOnScreenAroundElement(
							popup._createWrapper(menu),
							_around,
							/*(menu.isLeftToRight() == (trailing ? false : true)) ? 
								{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
								{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'},*/
							trailing ?
								[ "below-alt", "below", "above-alt", "above" ] : 
								[ "below", "below-alt", "above", "above-alt" ],
							ltr,
							menu.orient ? _lang.hitch(menu, "orient") : null);
						
					if(!ltr){
						where.x = where.x + where.w;
					}
					
					this._openTimer = setTimeout(_lang.hitch(this, function(){
						delete this._openTimer;
						this._openMyself({
							target: target,
							iframe: iframe,
							coords: where
						});
					}), 1);
				}
			}

			menu.leftClickToOpen = true;
		
			if(trigger){
				menu.bindDomNode(trigger);
			}
		}
	}
	
	/**
	 * Creates a new idx.oneui.Header
	 * @name idx.oneui.Header
	 * @class The Header widget generates the HTML and CSS to provide an
	 * IBM One UI header according to the design specification and templates.
	 * <p>
	 * To construct a header, initialise the widget with the required
	 * properties. The appropriate HTML and CSS is created immediately, and
	 * subsidiary dijit components may be created and marshalled. No dynamic
	 * layout is performed: once the HTML has been injected into the DOM,
	 * all layout is delegated to the renderer and associated CSS rules.
	 * </p>
	 * @augments dijit._Widget
	 * @augments dijit._TemplatedMixin
	 * @example
	 * var hdr = new idx.oneui.Header({ primaryTitle: "Hello" }, "myHeader");
	 */
	declare("idx.oneui.Header", [_Widget, _TemplatedMixin], 
	/** @lends idx.oneui.Header.prototype */
	{
		/**
		 * The IBM Brand/product name.
		 * @type string
		 */
		primaryTitle: "",
		
		/**
		 * The desired style of primary (black) banner: "thick" or "thin".
		 * @type string
		 * @default "thin"
		 */
		primaryBannerType: "thin",
		
		/**
		 * A menu bar, which can contain items and popup menu items, which
		 * will be displayed as navigation actions/menus in the header. The
		 * menu bar may be supplied as an instance or by id or as a DOM node.
		 * @type string | dijit.MenuBar | DOMNode
		 */
		navigation: undefined,
		
		/**
		 * True (the default) if navigation menu items that have a popup
		 * menu associated with them are to show a drop-down arrow affordance.
		 * If false, drop-down arrows are not shown on navigation items.
		 * @type boolean
		 */
		showNavigationDropDownArrows: true,

		/**
		 * Specifies that a primary search box should be included in the
		 * header, and supplies the parameters for it. All the properties are
		 * optional:
		 * <ul>
		 * <li>
		 * entryPrompt: {string | function} A string containing the prompt
		 * text for entering the search terms, or a function (which will be
		 * called with no arguments) which returns the prompt text.
		 * </li>
		 * <li>
		 * submitPrompt: {string | function} A string containing the prompt
		 * text for submitting the search, or a function (which will be called
		 * with no arguments) which returns the prompt text.
		 * </li>
		 * <li>onChange: {function} A function which will be called whenever
		 * the text in the search box changes. The function will receive one
		 * argument, which is the text currently in the search box.
		 * </li>
		 * <li>
		 * onSubmit: {function} A function which will be called whenever
		 * the user submits a search (eg, by pressing enter, or activating a
		 * search affordance). The function will receive one argument, which
		 * is the text currently in the search box.
		 * </li>
		 * </ul>
		 * @type Object
		 */
		primarySearch: undefined,
		
		/**
		 * The identity of the user to be included in the header. All
		 * properties are optional.
		 * <ul>
		 * <li>
		 * displayName: {string | function} A string containing the displayable
		 * name of the current user, or a function (which will be called with
		 * no arguments) which returns the displayable name of the current
		 * user. The displayable name may include mark-up (for example,
		 * entities for accented characters, etc). A displayName should always
		 * be supplied whenever feedback of the user's identity is required.
		 * The displayName can be modified after construction by setting the
		 * "userDisplayName" property of the header.
		 * Examples: "Clark, D. J. (Dave)"
		 * </li>
		 * <li>
		 * displayImage: {string | Object | function} A string containing the
		 * URI of an image to be displayed alongside the user name or welcome
		 * message, or an HTML image object (or other suitable mark-up object)
		 * to be used as the image alongside the user name or welcome message,
		 * or a function (which will be called with no arguments) which returns
		 * either a string or an object to specify the image to use. If omitted,
		 * null or undefined, no image is shown. The displayImage can be
		 * modified after construction by setting the "userDisplayName" property
		 * of the header.
		 * </li>
		 * <li>
		 * messageName: {string | function} A string containing the displayable
		 * name of the current user as it should appear in the message shown
		 * in the header to confirm the user's identity, if that is different
		 * from the displayName (for example, a shortened or simplified form
		 * of the user's name might be used as the messageName). If messageName
		 * is not supplied, the displayName is used. Note that displayName
		 * should still be supplied as well as messageName, because although it
		 * is the messageName that is substituted into the message for display,
		 * the displayName is also added as alternative text/title to add clarity
		 * for the user. The messageName can be set or modified after construction
		 * by setting the "userMessageName" property of the header.
		 * Examples: "Dave", "No&euml;l"
		 * </li>
		 * <li>
		 * message: {string | function} A string containing the message to be
		 * shown in the header to confirm the current user's identity, or a
		 * function (which will be called with no arguments) which returns
		 * the message to be shown. The string pattern will have the following
		 * substitutions applied:
		 * 	<ul>
		 * 	<li>
		 * 	${messageName} - the message name of the current user, if supplied,
		 * 	othewise the display name is used, if supplied
		 * 	</li>
		 * 	<li>
		 * 	$(displayName} - the display name of the current user
		 * 	</li>
		 * 	</ul>
		 * The message may include mark-up (for example, entities for accented
		 * characters, etc). If message is not supplied, the message that is
		 * used is "${messageName}". The message can be set or modified after
		 * construction by setting the "userMessage" property of the header.
		 * Examples: "Welcome back, ${messageName}",
		 * "Welcome, new user"
		 * </li>
		 * <li>
		 * actions: {string | dijit.Menu | dijit.MenuItem} A dijit.Menu to be
		 * used as the popup of available actions for the current user. If a
		 * single dijit.MenuItem is supplied, the current user name will be
		 * presented as a simple action and onClick will be triggered on the
		 * menu item when that action is selected. The menu or item may be
		 * supplied as an instance or by id.
		 * </li>
		 * </ul>
		 * @type Object
		 */
		user: undefined,
		
		/**
		 * True (the default) if a drop-down arrow affordance is to be shown
		 * on the user identification when a popup menu of user actions is supplied.
		 * If false, a drop-down arrow is not shown on the user identification.
		 * @type boolean
		 */
		showUserDropDownArrow: true,

		/**
		 * A dijit.Menu to be used as the popup of available site settings
		 * actions. If a single dijit.MenuItem is supplied, a simple site
		 * settings action will be presented and onClick will be triggered on
		 * the menu item when that action is selected.
		 * @type dijit.Menu | dijit.MenuItem
		 */
		settings: undefined,
	
		/**
		 * True (the default) if a drop-down arrow affordance is to be shown on the
		 * site settings icon when a popup menu of site settings items is supplied.
		 * If false, a drop-down arrow is not shown on the site settings icon.
		 * @type boolean
		 */
		showSettingsDropDownArrow: true,

		/**
		 * A dijit.Menu to be used as the popup of available site help actions. 
		 * If a single dijit.MenuItem is supplied, a simple site help action
		 * will be presented and onClick will be triggered on the menu item when
		 * that action is selected.
		 * @type dijit.MenuBarItem | dijit.MenuBarPopupItem
		 */
		help: undefined,
	
		/**
		 * True (the default) if a drop-down arrow affordance is to be shown on the
		 * site help icon when a popup menu of site help items is supplied.
		 * If false, a drop-down arrow is not shown on the site help icon.
		 * @type boolean
		 */
		showHelpDropDownArrow: true,

		/**
		 * The context title which shows users where they are, for example
		 * if they have arrived here by selecting a menu item.
		 * @type string
		 */
		secondaryTitle: "",
		
		/**
		 * The desired style of secondary (context) banner: "blue" or "lightgrey".
		 * @default "blue"
		 * @type string
		 */
		secondaryBannerType: "blue",
		
		/**
		 * A subtitle which gives additional context information.
		 * @type string
		 */
		secondarySubtitle: "",
		
		/**
		 * Text containing additional context information, such as when page
		 * content was last updated and by whom.
		 * @type string
		 */
		additionalContext: "",

		/**
		 * An array of objects defining actions which will be displayed as
		 * action buttons in the context part of the header. Each object
		 * must contain the following properties:
		 * <ul>
		 * <li>
		 * label: text label for the action
		 * </li>
		 * <li>
		 * onClick: click handler for the action button
		 * </li>
		 * </ul>
		 * @type Object[]
		 */
		actions: undefined,
		
		/**
		 * The id of a content container which is to be controlled by tabs
		 * included in the header, or the widget itself. Each ContentPane in
		 * the StackContainer may additionally include the following properties
		 * (all optional):
		 * <ul>
		 * <li>
		 * closable: {boolean} If true, a close affordance will be displayed on
		 * the corresponding tab and will close the content pane when activated.
		 * If false, or if this property is not set, no close affordance is shown.
		 * </li>
		 * <li>
		 * actions: {dijit.Menu} A menu of items to be presented when the
		 * drop-down affordance on the tab is activated. The drop-down
		 * affordance will be displayed on the tab if this property is set and
		 * either the tab is selected or alwaysShowMenu is true.
		 * </li>
		 * <li>
		 * alwaysShowMenu: {boolean} If true, a drop-down affordance will be
		 * displayed on the tab if the actions property has been set,
		 * regardless of whether the tab is currently selected. If false, a
		 * drop-down affordance will only be displayed on the tab if the
		 * actions property has been set AND the tab is currently selected.
		 * </li>
		 * </ul>
		 * @type string | dijit.StackContainer
		 */
		contentContainer: "",
		
		/**
		 * If true, content tabs will be placed on the same line as a context
		 * title and/or other secondary banner content. If false, the tabs will
		 * occupy their own row within the secondary banner. The default value is false.
		 * @type boolean
		 */
		contentTabsInline: false,
		
		/**
		 * Specifies that a secondary search box should be included in the
		 * header, and supplies the parameters for it. All the properties are
		 * optional:
		 * <ul>
		 * <li>
		 * entryPrompt: {string | function} A string containing the prompt text
		 * for entering the search terms, or a function (which will be called
		 * with no arguments) which returns the prompt text.
		 * </li>
		 * <li>
		 * submitPrompt: {string | function} A string containing the prompt
		 * text for submitting the search, or a function (which will be called
		 * with no arguments) which returns the prompt text.
		 * </li>
		 * <li>
		 * onChange: {function} A function which will be called whenever the
		 * text in the search box changes. The function will receive one
		 * argument, which is the text currently in the search box.
		 * </li>
		 * <li>
		 * onSubmit: {function} A function which will be called whenever user
		 * submits a search (eg, by pressing enter, or activating a 
		 * search affordance). The function will receive one argument, which
		 * is the text currently in the search box.
		 * </li>
		 * </ul>
		 * @type Object
		 */
		secondarySearch: undefined,
		
		/**
		 * Specifies the desired layout mode, which can be "fixed" for a
		 * fixed-width layout independent of the browser width (extra space
		 * will be left at the side margins, and a scroll bar will appear if
		 * the browser window is too narrow) or "variable" for a variable-width
		 * layout that exploits the full browser window width (extra space will
		 * be left within the layout, which will change as the browser window
		 * is resized). 
		 * @default "variable".
		 * @type string
		 */
		layoutType: "variable",
		
		// The following properties (read-only) can be used to obtain the DOM
		// nodes of key elements of the constructed UI. These properties will
		// not be defined unless the corresponding UI element is used/required.
		//
		// Container nodes:
		//  domNode: outer containing DOM node
		//  primaryBannerNode: container (div) for all primary banner content
		//  navigationNode: contains a menu bar of navigation action items
		//  userNode: contains the user identity and actions display
		//  secondaryBannerNode: container (div) for all secondary banner content
		//
		// Widget and content nodes:
		//  primaryTitleTextNode: contains primary title text/markup
		//  userTextNode: contains user identity text/markup
		//  primarySearchTextNode: the text field for primary search
		//  primarySearchButtonNode: the submit button for primary search
		//  secondaryTitleTextNode: contains secondary title text/markup
		//  secondarySubtitleTextNode: contains secondary subtitle text/markup
		//  contextActionNodes: array of action button nodes
		//  contentControllerNode: the content controller (tab bar)
		//  secondarySearchTextNode: the text field for secondary search
		//  secondarySearchButtonNode: the submit button for secondary search
		//  
		// Other nodes used internally:
		//  _mainContainerNode: container for the primary and secondary banners
		//  _globalActionsNode: container for all global actions
		//  _secondaryTitleSeparatorNode: text separating secondary title and subtitle
		//  _contextActionsNode: container for all context actions
		//
		/**
	 	 * The template HTML for the widget.
		 * @constant
		 * @type string
		 * @private
		 */
		templateString: '<div>' +
		                '<div dojoAttachPoint="_mainContainerNode">' +
						'</div>' +
						'</div>',

		/**
		 * Return the user identity display name, calling supplied functions
		 * where applicable.
		 * @private
		 */		
		_getComputedUserName: function(){
			return (this.user && (typeof this.user.displayName == "function")) ? this.user.displayName() : (this.user.displayName || "");
		},
		
		/**
		 * Return the user identity display image, calling supplied functions
		 * where applicable.
		 * @private
		 */		
		_getComputedUserImage: function(){
			return (this.user && (typeof this.user.displayImage == "function")) ? this.user.displayImage() : this.user.displayImage;
		},
		
		/**
		 * Return the user identity message, taking into account any custom
		 * message template and calling supplied functions where applicable.
		 * @private
		 */		
		_getComputedUserMessage: function(){
			// name to use in message: if no message name, use display name
			var displayname = this._getComputedUserName(),
				messagename = ((typeof this.user.messageName == "function") ? this.user.messageName() : this.user.messageName) || displayname,
				result = messagename;
			
			if(this.user && this.user.message){
				var message = (typeof this.user.message == "function") ? this.user.message() : this.user.message;
				
				result = string.substitute(message, this.user, function(value, key){
					switch(key){
						case "messageName": return messagename;
						case "displayName": return displayname;
						default: return value || "";
					}
				});
			}
			
			return result;
		},
		
		_setUserDisplayNameAttr: function(value){
			this.user = this.user || {};
			this.user.displayName = value;
			this._refreshUser();
		},
		
		_setUserDisplayImageAttr: function(value){
			this.user = this.user || {};
			this.user.displayImage = value;
			this._refreshUser();
		},
		
		_setUserMessageNameAttr: function(value){
			this.user = this.user || {};
			this.user.messageName = value;
			this._refreshUser();
		},
		
		_setUserMessageAttr: function(value){
			this.user = this.user || {};
			this.user.message = value;
			this._refreshUser();
		},
		
		_refreshUser: function(){
			var name = this._getComputedUserName(),
				imgsrc = this._getComputedUserImage(),
				msg = this._getComputedUserMessage();
				
			domattr.set(this.userNode, "title", name);
			domattr.set(this.userImageNode, "alt", name);
			
			domattr.set(this.userImageNode, "src", imgsrc || "");
			domstyle.set(this.userImageNode, "display", imgsrc ? "block" : "none");
			
			this.userTextNode.innerHTML = msg;
			domclass.replace(this.userNode, msg ? "idxHeaderUserName" : "idxHeaderUserNameNoText", "idxHeaderUserName idxHeaderUserNameNoText");
		},
		
		/**
		 * Construct UI from a template, injecting the resulting DOM items
		 * as children on of the supplied container node.
		 * @param {Object} containerNode
		 * @param {Object} templateString
		 */
		_injectTemplate: function(containerNode, templateString){
			
			// this code is generalised from _Templated.buildRendering

			// Look up cached version of template, or download to cache.
			var cached = _TemplatedMixin.getCachedTemplate(templateString, true);

			var node;
			if(_lang.isString(cached)){
				// if the cache returned a string, it contains replacement parameters,
				// so replace them and create DOM
				node = domconstruct.toDom(this._stringRepl(cached));
			}else{
				// if the cache returned a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node, function(n,p){ return n.getAttribute(p); });
			
			// append resolved template as child of container
			containerNode.appendChild(node);
		},

		/**
		 * Standard widget lifecycle postMixInProperties() method.
		 * @private
		 */
		postMixInProperties: function(){
			this._nls = i18n.getLocalization("idx.oneui", "Header");
		
			if(this.primarySearch){
				this.primarySearch = _lang.mixin({
					entryPrompt: this._nls.searchEntry,
					submitPrompt: this._nls.searchSubmit
				}, this.primarySearch);
			}

			if(this.secondarySearch){
				this.secondarySearch = _lang.mixin({
					entryPrompt: this._nls.searchEntry,
					submitPrompt: this._nls.searchSubmit
				}, this.secondarySearch);
			}
		},
		
		/**
		 * Standard widget lifecycle buildRendering() method.
		 * @private
		 */
		buildRendering: function(){
			// summary:
			//     Generate the HTML and CSS for the header.

			// call down to apply the template and base widget handling
			this.inherited(arguments);
			
			// The following logic allocates all header items into either a
			// primary or a secondary banner, both of which are optional.
			//
			// The primary banner will accommodate:
			//  - primary title (if any)
			//  - navigation links/menus (if any)
			//  - search (if any, and if there's room)
			//  - user identity (if any)
			// The search will only be accommodated if at least one of the
			// other items is omitted; if a primary title, navigation
			// links/menus and user identity are all provided then the search
			// (if required) will be placed into the secondary banner.
			//
			// The primary banner will place the primary title at the top left
			// and the user identity at the top right. The navigation
			// links/menus and search will be placed between them, flowing onto
			// a second line if necessary.
			//
			// The secondary banner will accommodate:
			//  - secondary title (if any)
			//  - action links/menus (if any)
			//  - content controller (if any)
			//  - search (if any, and if not accommodated in primary banner)
			//
			// The secondary banner will place the secondary title at the top
			// left and the search at the top right. The action links/menus and
			// content controller will be placed between them, flowing onto a
			// second line if necessary.
			// 
			// Other layout schemes (eg for mobile) will require separate logic
			// not yet provided here.
			
			// First issue warnings for situations that may not be intended.
			if(this.contentContainer && this.secondaryBannerType && this.secondaryBannerType.toLowerCase() == "white"){
				// content tabs in "white" style are not supported
				require.log('*** Warning: Header will not display content tabs when secondaryBannerType is "white". Specify a different type to see content tabs.');
			}
			
			var show_primary_title = this.primaryTitle,
				show_primary_logo = true,
				show_primary_help = this.help,
				show_primary_settings = this.settings,
				show_primary_user = this.user,
				show_primary_navigation = this.navigation,
				show_primary_search = this.primarySearch,
			    show_secondary_title = this.secondaryTitle || this.secondarySubtitle,
			    show_secondary_actions = this.contextActions,
			    show_secondary_search = this.secondarySearch,
			    show_content = this.contentContainer && (!this.secondaryBannerType || (this.secondaryBannerType.toLowerCase() != "white")),  // never show content tabs in "white" style (not supported)
				show_secondary_content = show_content && (this.contentTabsInline || !show_secondary_title),
				show_secondary_border = this.secondaryBannerType && (this.secondaryBannerType.toLowerCase() == "white"),
				show_tertiary_content = show_content && !show_secondary_content,
			    show_primary_items = show_primary_title || show_primary_logo || show_primary_help || show_primary_settings || show_primary_user || show_primary_navigation || show_primary_search,  
			    show_secondary_items = show_secondary_title || show_secondary_actions || show_secondary_search || show_secondary_content,
				show_tertiary_items = show_tertiary_content,
				show_lip;
			
			if(show_primary_items || show_secondary_items || show_tertiary_items){
				domclass.add(this.domNode, "idxHeaderContainer");
				
				if(this.primaryBannerType && (this.primaryBannerType.toLowerCase() == "thick")){
					domclass.add(this._mainContainerNode, "idxHeaderPrimaryThick");
				}else{
					domclass.add(this._mainContainerNode, "idxHeaderPrimaryThin");
				}
				
				if(this.secondaryBannerType && ((this.secondaryBannerType.toLowerCase() == "lightgrey") || (this.secondaryBannerType.toLowerCase() == "lightgray"))){
					domclass.add(this._mainContainerNode, "idxHeaderSecondaryGray");
					domclass.add(this._mainContainerNode, show_tertiary_items ? "idxHeaderSecondaryGrayDoubleRow" : "idxHeaderSecondaryGraySingleRow");
					show_lip = show_primary_items;
				}else if(this.secondaryBannerType && (this.secondaryBannerType.toLowerCase() == "white")){
					domclass.add(this._mainContainerNode, "idxHeaderSecondaryWhite");
					domclass.add(this._mainContainerNode, show_tertiary_items ? "idxHeaderSecondaryWhiteDoubleRow" : "idxHeaderSecondaryWhiteSingleRow");
					show_lip = show_primary_items;
				}else{
					domclass.add(this._mainContainerNode, "idxHeaderSecondaryBlue");
					domclass.add(this._mainContainerNode, (show_tertiary_items) ? "idxHeaderSecondaryBlueDoubleRow" : "idxHeaderSecondaryBlueSingleRow");
					show_lip = show_primary_items && !show_secondary_items && !show_tertiary_items;
				}
				domclass.add(this._mainContainerNode, show_tertiary_items ? "idxHeaderSecondaryDoubleRow" : "idxHeaderSecondarySingleRow");
				
				if(this.layoutType && (this.layoutType.toLowerCase() == "fixed")){
					domclass.add(this._mainContainerNode, "idxHeaderWidthFixed");
				}else{
					domclass.add(this._mainContainerNode, "idxHeaderWidthLiquid");
				}				
			}
			
			// now load any additional modules we know we need
			var modules = [],
			    assigns = [],
				me = this;
			
			if(show_primary_search || show_secondary_search || show_secondary_actions){
				modules.push("dijit/form/Button");
				assigns.push(function(obj){ Button = obj; });
			}
			
			if(show_primary_search || show_secondary_search){
				modules.push("dijit/form/TextBox");
				assigns.push(function(obj){ TextBox = obj; });
			}
			
			if(show_content){
				modules.push("idx/oneui/layout/MenuTabController");
				assigns.push(function(obj){ MenuTabController = obj; });
			}
			
			require(modules, function(){
			
				for(var i=0; i<assigns.length; i++){
					assigns[i](arguments[i]);
				}
			
				// create the primary bar
				
				if(show_primary_items){
					me._injectTemplate(me._mainContainerNode,
										 '<div class="idxHeaderPrimary">' +
										 '<div class="idxHeaderPrimaryInner" dojoAttachPoint="primaryBannerNode">' +
										 '<ul dojoAttachPoint="_globalActionsNode">' +
										 '</ul>' +
										 '</div>' +
										 '</div>');
				}
				
				if(show_primary_title){
					me._renderPrimaryTitle(me._globalActionsNode);
				}
				
				if(show_primary_logo){
					me._renderLogo(me._globalActionsNode);
				}
				
				if(show_primary_help){
					me._renderHelp(me._globalActionsNode, show_primary_settings || show_primary_user);
				}
				
				if(show_primary_settings){
					me._renderSettings(me._globalActionsNode, show_primary_user);
				}
				
				if(show_primary_user){
					me._renderUser(me._globalActionsNode);
				}
				
				if(show_primary_search){
					me._renderPrimarySearch(me._globalActionsNode);
				}			
				
				if(show_primary_navigation){
					me._renderNavigation(me.primaryBannerNode);
				}
				
				// create the blue lip
				
				if(show_lip){
					me._injectTemplate(me._mainContainerNode,
										 '<div class="idxHeaderBlueLip">' + 
										 '</div>');
				}
				
				// create the secondary bar
				
				if(show_secondary_items){
					me._injectTemplate(me._mainContainerNode,
										 '<div class="idxHeaderSecondary"> ' +
										 '<div class="idxHeaderSecondaryInner" dojoAttachPoint="secondaryBannerNode">' + 
										 '</div>' + 
										 '</div>');
				}
				
				if(show_secondary_search){
					me._renderSecondarySearch(me.secondaryBannerNode);
				}			

				if(show_secondary_title){
					me._renderSecondaryTitle(me.secondaryBannerNode);
				}
				
				if(show_secondary_content){
					me._renderContent(me.secondaryBannerNode, false);
				}

				if(show_secondary_actions){
					me._renderContextActions(me.secondaryBannerNode);
				}
				
				if(show_secondary_border){
					me._renderSecondaryInnerBorder(me.secondaryBannerNode);
				}
				
				// create the tertiary bar
				
				if(show_tertiary_content){
					me._renderContent(me._mainContainerNode, true);
				}
			});
		},
		
		_renderPrimaryTitle: function(domNode){
			this._injectTemplate(domNode,
			         			 '<li>' +
			         			 '<span>' +
			         			 '<div class="idxHeaderPrimaryTitle">' +
			         			 '${primaryTitle}' +
			         			 '</div>' +
			         			 '</span>' +
			         			 '</li>'); 
		},
		
		_renderLogo: function(domNode){
			this._injectTemplate(domNode,
			         			 '<li class="idxHeaderPrimaryAction end">' +
			         			 '<span>' +
			         			 '<div class="idxHeaderLogoBox">' +
			         			 '<div class="idxHeaderLogo" alt="${_nls.ibmlogo}">' +
			         			 '</div>' +
			         			 '</div>' +
			         			 '</span>' +
			         			 '</li>'); 
		},
		
		_renderHelp: function(domNode, addSeparator){
			this._injectTemplate(domNode,
			         			 '<li class="idxHeaderPrimaryAction idxHeaderHelp">' +
			         			 '<span dojoAttachPoint="_helpNode" alt="${_nls.actionHelp}" title="${_nls.actionHelp}">' +
									 '<span class="idxHeaderHelpIcon">' +
									 '</span>' +
							         '<span class="idxHeaderDropDownArrow">' +
							         '</span>' +
			         			 '</span>' +
			         			 '</li>');
			
			if(addSeparator){
				this._injectTemplate(domNode,
				                     '<li class="idxHeaderPrimaryAction idxHeaderSeparator"><span></span></li>');
			}

			if(this.help){
				this.help = registry.byId(this.help);
				prepareMenu(this.help, [ "oneuiHeaderGlobalActionsMenu", "oneuiHeaderGlobalActionsSubmenu" ], this._helpNode, this._helpNode, true);
				domclass.toggle(this._helpNode, "idxHeaderDropDown", this.showHelpDropDownArrow);
			}
		},
		
		_renderSettings: function(domNode, addSeparator){
			this._injectTemplate(domNode,
			         			 '<li class="idxHeaderPrimaryAction idxHeaderTools">' +
			         			 '<span dojoAttachPoint="_settingsNode" alt="${_nls.actionShare}" title="${_nls.actionShare}">' +
									 '<span class="idxHeaderShareIcon">' +
									 '</span>' +
							         '<span class="idxHeaderDropDownArrow">' +
							         '</span>' +
			         			 '</span>' +
			         			 '</li>'); 
			
			if(addSeparator){
				this._injectTemplate(domNode,
				                     '<li class="idxHeaderPrimaryAction idxHeaderSeparator"><span></span></li>');
			}

			if(this.settings){
				this.settings = registry.byId(this.settings);
				prepareMenu(this.settings, [ "oneuiHeaderGlobalActionsMenu", "oneuiHeaderGlobalActionsSubmenu" ], this._settingsNode, this._settingsNode, true);
				domclass.toggle(this._settingsNode, "idxHeaderDropDown", this.showSettingsDropDownArrow);
			}
		},
		
		_renderUser: function(domNode){
			this._injectTemplate(domNode,
			                     '<li class="idxHeaderPrimaryAction">' + 
									'<span dojoAttachPoint="userNode" class="idxHeaderUserNameNoText">' +
										'<span class="idxHeaderUserIcon">' +
											'<img dojoAttachPoint="userImageNode" class="idxHeaderUserIcon" />' +
										'</span>' +
										'<span class="idxHeaderUserText" dojoAttachPoint="userTextNode">' +
										'</span>' +
								        '<span class="idxHeaderDropDownArrow">' +
								        '</span>' +
									'</span>' +
			                     '</li>');			                     
			
			this._refreshUser();

			if(this.user.actions){
				this.user.actions = registry.byId(this.user.actions);
				prepareMenu(this.user.actions, [ "oneuiHeaderGlobalActionsMenu", "oneuiHeaderGlobalActionsSubmenu" ], this.userNode, this.userNode, true);
				domclass.toggle(this.userNode, "idxHeaderDropDown", this.showUserDropDownArrow);
			}
		},
		
		_renderNavigation: function(domNode){
			this.navigation = ((typeof this.navigation == "object") && ('nodeType' in this.navigation)) ? registry.byNode(this.navigation) : registry.byId(this.navigation);
			
			if(!this.navigation){
				require.log("WARNING: navigation widget not found");
			}else{
				this.navigation.placeAt(domNode);
				this.navigation.startup();
				
				var children = this.navigation.getChildren();
				if((children.length == 1) && (children[0].label == "")){
					// if there is just a single menu bar item with no text, make it a "home" icon
					domclass.toggle(children[0].containerNode, "idxHeaderNavigationHome", true);
				}else if(this.showNavigationDropDownArrows){
					for(var i = 0; i < children.length; i++){
						if(children[i].popup){
							this._injectTemplate(children[i].focusNode, '<span class="idxHeaderDropDownArrow"></span>'); 
							domclass.toggle(children[i].domNode, "idxHeaderDropDown", true);
						}
					}
				}
				
				// remove whitespace-only text nodes in the menu-bar, as these
				// can disrupt precise layout of the menu items
				var node = this.navigation.domNode.firstChild, del;
				while(node){
					del = node;
					node = node.nextSibling;
					if((del.nodeType == 3) && (!del.nodeValue.match(/\S/))){
						this.navigation.domNode.removeChild(del);
					}
				}
				
				prepareMenu(this.navigation, [null, "oneuiHeaderNavigationMenu", "oneuiHeaderNavigationSubmenu"]);
			}
		},
		
		_renderPrimarySearch: function(domNode){
			this._injectTemplate(domNode,
			                     '<li role="search" class="idxHeaderSearchContainer">' +
			                     '<input type="text" dojoAttachPoint="primarySearchTextNode" />' + 
			                     '<input type="image" dojoAttachPoint="primarySearchButtonNode" />' +
			                     '</li>');
								 
			this.primarySearch.onChange = _lang.isFunction(this.primarySearch.onChange) ? this.primarySearch.onChange : new Function("value", this.primarySearch.onChange);
			this.primarySearch.onSubmit = _lang.isFunction(this.primarySearch.onSubmit) ? this.primarySearch.onSubmit : new Function("value", this.primarySearch.onSubmit);
			
			var me = this;
			
			var text = new TextBox({
				trim: true,
				placeHolder: this.primarySearch.entryPrompt,
				intermediateChanges: true,
				title: this.primarySearch.entryPrompt,
				onChange: function(){ me._onPrimarySearchChange(text.attr("value")); },
				onKeyUp: function(event){ if(event.keyCode == keys.ENTER){ me._onPrimarySearchSubmit(text.attr("value")); } }
			},
			this.primarySearchTextNode);
			
			new Button({
				label: this.primarySearch.submitPrompt,
				showLabel: false,
				iconClass: "idxHeaderSearchButton",
				onClick: function(){ me._onPrimarySearchSubmit(text.attr("value")); }				
			},
			this.primarySearchButtonNode);
		},
		
		_renderSecondaryTitle: function(domNode){
			this._injectTemplate(domNode,
			                     '<span class="idxHeaderSecondaryTitleContainer">' +
								 '<span class="idxHeaderSecondaryTitle" dojoAttachPoint="secondaryTitleTextNode">' +
			                     '${secondaryTitle}' +
			                     '</span>' +
			                     '<span class="idxHeaderSecondarySubtitle" dojoAttachPoint="_secondaryTitleSeparatorNode">' +
			                     '&nbsp;&ndash;&nbsp;' +
			                     '</span>' +
			                     '<span class="idxHeaderSecondarySubtitle" dojoAttachPoint="secondarySubtitleTextNode">' +
			                     '${secondarySubtitle}' +
			                     '</span>' +
								 '&nbsp;&nbsp;' +
			                     '<span class="idxHeaderSecondaryAdditionalContext" dojoAttachPoint="additionalContextTextNode">' +
			                     '${additionalContext}' +
			                     '</span>' +
								 '</span>');
								 
			domstyle.set(this._secondaryTitleSeparatorNode, "display", (this.secondaryTitle && this.secondarySubtitle) ? "" : "none");
		},
		
		_renderContextActions: function(domNode){
			this._injectTemplate(domNode,
			                     '<div class="idxHeaderSecondaryActions" dojoAttachPoint="_contextActionsNode"></div>');
			this.contextActionNodes = [];
			
			for(var i=0; i<this.contextActions.length; i++){
				this._injectTemplate(this._contextActionsNode,
									 '<button type="button" dojoAttachPoint="_nextActionNode"></button>');
				new Button(this.contextActions[i], this._nextActionNode);
				this.contextActionNodes.push(this._nextActionNode);
				delete this._nextActionNode;
			}
		},
		
		_renderSecondarySearch: function(domNode){
			this._injectTemplate(domNode,
			                     '<div role="search" class="idxHeaderSearchContainer">' +
			                     '<input type="text" dojoAttachPoint="secondarySearchTextNode" />' + 
			                     '<input type="image" dojoAttachPoint="secondarySearchButtonNode" />' +
			                     '</div>');
			
			this.secondarySearch.onChange = _lang.isFunction(this.secondarySearch.onChange) ? this.secondarySearch.onChange : new Function("value", this.secondarySearch.onChange);
			this.secondarySearch.onSubmit = _lang.isFunction(this.secondarySearch.onSubmit) ? this.secondarySearch.onSubmit : new Function("value", this.secondarySearch.onSubmit);
			
			var me = this;
			
			var text = new TextBox({
				trim: true,
				placeHolder: this.secondarySearch.entryPrompt,
				intermediateChanges: true,
				title: this.secondarySearch.entryPrompt,
				onChange: function(){ me._onSecondarySearchChange(text.attr("value")); },
				onKeyUp: function(event){ if(event.keyCode == keys.ENTER){ me._onSecondarySearchSubmit(text.attr("value")); } }
			},
			this.secondarySearchTextNode);
			
			new Button({
				label: this.secondarySearch.submitPrompt,
				showLabel: false,
				iconClass: "idxHeaderSearchButton",
				onClick: function(){ me._onSecondarySearchSubmit(text.attr("value")); }				
			},
			this.secondarySearchButtonNode)
		},
		
		_renderSecondaryInnerBorder: function(domNode){
			this._injectTemplate(domNode,
			                     '<div role="presentation" class="idxHeaderSecondaryInnerBorder">' +
			                     '</div>');
		},
		
		_renderContent: function(domNode, includeInnerDiv){
			this._injectTemplate(domNode,
			                     '<div class="oneuiContentContainer">' +
								 (includeInnerDiv ? '<div class="oneuiContentContainerInner">' : '') +
			                     '<div dojoAttachPoint="contentControllerNode"></div>' +
								 (includeInnerDiv ? '</div>' : '') +
			                     '</div>');	
			
			var controller = new MenuTabController({
				containerId: (typeof this.contentContainer === "string") ? this.contentContainer : this.contentContainer.id,
				"class": "dijitTabContainerTop-tabs",
				useMenu: this._tabMenu,
				useSlider: this._tabSlider,
				buttonWidget: _lang.extend(idx.oneui.layout._PopupTabButton, { tabDropDownText: "", tabSeparatorText: "|" })
			},
			this.contentControllerNode);
			
			prepareMenu(controller._menuBtn, [ "oneuiHeader2ndLevMenu", "oneuiHeader2ndLevSubmenu" ]);
			aspect.after(controller, "_bindPopup", function(page, tabNode, popupNode, popup){
				prepareMenu(popup, [ "oneuiHeader2ndLevMenu", "oneuiHeader2ndLevSubmenu" ], popupNode, tabNode);
			}, true);
			
			controller.startup();
				
			// if the content container is already started, ensure the controller initialises correctly
			var container = registry.byId(this.contentContainer);
			if(container && container._started){
				controller.onStartup({ children: container.getChildren(), selected: container.selectedChildWidget });
			}
		},
		
		_onPrimarySearchChange: function(value){
			this.primarySearch.onChange(value);
		},
		
		_onPrimarySearchSubmit: function(value){
			this.primarySearch.onSubmit(value);
		},
		
		_onSecondarySearchChange: function(value){
			this.secondarySearch.onChange(value);
		},
		
		_onSecondarySearchSubmit: function(value){
			this.secondarySearch.onSubmit(value);
		}
		
	});
	
	return idx.oneui.Header;
		
});

},
'dijit/layout/_ContentPaneResizeMixin':function(){
define("dijit/layout/_ContentPaneResizeMixin", [
	"dojo/_base/array", // array.filter array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr",	// domAttr.has
	"dojo/dom-class",	// domClass.contains domClass.toggle
	"dojo/dom-geometry",// domGeometry.contentBox domGeometry.marginBox
	"dojo/_base/lang", // lang.mixin
	"dojo/query", // query
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window", // win.global
	"../registry",	// registry.byId
	"./utils",	// marginBox2contextBox
	"../_Contained"
], function(array, declare, domAttr, domClass, domGeometry, lang, query, has, win,
			registry, layoutUtils, _Contained){

/*=====
var _Contained = dijit._Contained;
=====*/

// module:
//		dijit/layout/_ContentPaneResizeMixin
// summary:
//		Resize() functionality of ContentPane.   If there's a single layout widget
//		child then it will call resize() with the same dimensions as the ContentPane.
//		Otherwise just calls resize on each child.


return declare("dijit.layout._ContentPaneResizeMixin", null, {
	// summary:
	//		Resize() functionality of ContentPane.   If there's a single layout widget
	//		child then it will call resize() with the same dimensions as the ContentPane.
	//		Otherwise just calls resize on each child.
	//
	//		Also implements basic startup() functionality, where starting the parent
	//		will start the children

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		if(this._started){ return; }

		var parent = this.getParent();
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		this.inherited(arguments);

		if(this._isShown()){
			this._onShow();
		}

		if(!this._childOfLayoutWidget){
			// If my parent isn't a layout container, since my style *may be* width=height=100%
			// or something similar (either set directly or via a CSS class),
			// monitor when my size changes so that I can re-layout.
			// For browsers where I can't directly monitor when my size changes,
			// monitor when the viewport changes size, which *may* indicate a size change for me.
			this.connect(has("ie") ? this.domNode : win.global, 'onresize', function(){
				// Using function(){} closure to ensure no arguments to resize.
				this._needLayout = !this._childOfLayoutWidget;
				this.resize();
			});
		}
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propagate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return domAttr.has(node, "data-dojo-type") || domAttr.has(node, "dojoType") || domAttr.has(node, "widgetId");
			}),
			candidateWidgets = array.filter(childWidgetNodes.map(registry.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download (see [20099]).
		// However, don't load href for closed TitlePanes.
		if(!this._wasShown && this.open !== false){
			this._onShow();
		}

		this._resizeCalled = true;

		this._scheduleLayout(changeSize, resultSize);
	},

	_scheduleLayout: function(changeSize, resultSize){
		// summary:
		//		Resize myself, and call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layout(changeSize, resultSize);
		}else{
			this._needLayout = true;
			this._changeSize = changeSize;
			this._resultSize = resultSize;
		}
	},

	_layout: function(changeSize, resultSize){
		// summary:
		//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
		//		Also, since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		//
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from set('content', ...))... but deferred until
		//		the ContentPane is visible

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			domGeometry.setMarginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
			}
			this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = domGeometry.getContentBox(cn);
		}

		this._layoutChildren();

		delete this._needLayout;
	},

	_layoutChildren: function(){
		// Call _checkIfSingleChild() again in case app has manually mucked w/the content
		// of the ContentPane (rather than changing it through the set("content", ...) API.
		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			array.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode, parent = this.domNode.parentNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does layout/resize of child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layout(this._changeSize, this._resultSize);
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	}
});

});

},
'dijit/form/_ButtonMixin':function(){
define("dijit/form/_ButtonMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/_base/event", // event.stop
	"../registry"		// registry.byNode
], function(declare, dom, event, registry){

// module:
//		dijit/form/_ButtonMixin
// summary:
//		A mixin to add a thin standard API wrapper to a normal HTML button

return declare("dijit.form._ButtonMixin", null, {
	// summary:
	//		A mixin to add a thin standard API wrapper to a normal HTML button
	// description:
	//		A label should always be specified (through innerHTML) or the label attribute.
	//		Attach points:
	//			focusNode (required): this node receives focus
	//			valueNode (optional): this node's value gets submitted with FORM elements
	//			containerNode (optional): this node gets the innerHTML assignment for label
	// example:
	// |	<button data-dojo-type="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Content to display in button.
	label: "",

	// type: [const] String
	//		Type of button (submit, reset, button, checkbox, radio)
	type: "button",

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			event.stop(e);
			return false;
		}
		var preventDefault = this.onClick(e) === false; // user click actions
		if(!preventDefault && this.type == "submit" && !(this.valueNode||this.focusNode).form){ // see if a non-form widget needs to be signalled
			for(var node=this.domNode; node.parentNode; node=node.parentNode){
				var widget=registry.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					preventDefault = true;
					break;
				}
			}
		}
		if(preventDefault){
			e.preventDefault();
		}
		return !preventDefault;
	},

	postCreate: function(){
		this.inherited(arguments);
		dom.setSelectable(this.focusNode, false);
	},

	onClick: function(/*Event*/ /*===== e =====*/){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this._set("label", content);
		(this.containerNode||this.focusNode).innerHTML = content;
	}
});

});

},
'dojox/storage/LocalStorageProvider':function(){
// wrapped by build app
define("dojox/storage/LocalStorageProvider", ["dijit","dojo","dojox","dojo/require!dojox/storage/Provider,dojox/storage/manager"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.LocalStorageProvider");

dojo.require("dojox.storage.Provider");
dojo.require("dojox.storage.manager");

dojo.declare(
	"dojox.storage.LocalStorageProvider",
	[dojox.storage.Provider],
	{
		store: null,

		initialize: function(){

			this.store = localStorage;

			this.initialized = true;
			dojox.storage.manager.loaded();
		},

		isAvailable: function(){ /*Boolean*/
			return typeof localStorage != 'undefined';
		},

		put: function(	/*string*/ key,
						/*object*/ value,
						/*function*/ resultsHandler,
						/*string?*/ namespace){

			// TODO: Use the events as specified in http://dev.w3.org/html5/webstorage/#the-storage-event ?
			//	Currently, the storage event is not reliable around browsers.

			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			var fullKey = this.getFullKey(key,namespace);

			// prepending a prefix to a string value
			// will result in that prefix not being
			// usable as a value, so we better use
			// toJson() always.
			value = dojo.toJson(value);

			try { // ua may raise an QUOTA_EXCEEDED_ERR exception
				this.store.setItem(fullKey,value);

				if(resultsHandler){
					resultsHandler(this.SUCCESS, key, null, namespace);
				}
			} catch(e) {
				if(resultsHandler){
					resultsHandler(this.FAILED, key, e.toString(), namespace);
				}
			}
		},

		get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			// get our full key name, which is namespace + key
			key = this.getFullKey(key, namespace);

			return dojo.fromJson(this.store.getItem(key));
		},

		getKeys: function(/*string?*/ namespace){ /*Array*/
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_'

			var keys = [];
			for(var i = 0; i < this.store.length; i++){
				var currentKey = this.store.key(i);
				if(this._beginsWith(currentKey,namespace)){
					currentKey = currentKey.substring(namespace.length);
					keys.push(currentKey);
				}
			}

			return keys;
		},

		clear: function(/*string?*/ namespace){
			// Um, well, the 'specs' in Provider.js say that if
			// no namespace is given, this method should nuke
			// the *complete* storage. As other components might
			// be using localStorage too, this might not be a
			// good idea, so this method won't do it.

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			var keys = [];
			for(var i = 0; i < this.store.length; i++){
				if(this._beginsWith(this.store.key(i),namespace)){
					keys.push(this.store.key(i));
				}
			}

			dojo.forEach(keys, dojo.hitch(this.store, "removeItem"));
		},

		remove: function(/*string*/ key, /*string?*/ namespace){
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			this.store.removeItem(this.getFullKey(key, namespace));
		},

		getNamespaces: function(){ /*string[]*/
			// There must be a better way than
			// to execute a regex on *every*
			// item in the store.

			var results = [ this.DEFAULT_NAMESPACE];

			var found = {};
			found[this.DEFAULT_NAMESPACE] = true;
			var tester = /^__([^_]*)_/;

			for(var i = 0; i < this.store.length; i++){
				var currentKey = this.store.key(i);
				if(tester.test(currentKey) == true){
					var currentNS = currentKey.match(tester)[1];
					if(typeof found[currentNS] == "undefined"){
						found[currentNS] = true;
						results.push(currentNS);
					}
				}
			}

			return results;
		},

		isPermanent: function(){ /*Boolean*/
			return true;
		},

		getMaximumSize: function(){ /* mixed */
			return dojox.storage.SIZE_NO_LIMIT;
		},

		hasSettingsUI: function(){ /*Boolean*/
			return false;
		},

		isValidKey: function(/*string*/ keyName){ /*Boolean*/
			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z_-]*$/.test(keyName);
		},

		isValidNamespace: function(/*string*/ keyName){ /*Boolean*/
			// we *must* prevent namespaces from having
			// underscores - else lookup of namespaces
			// via RegEx (e.g. in getNamespaces ) would
			// return wrong results.
			//
			// The only way around this would be to
			// disallow underscores in keys.

			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z-]*$/.test(keyName);
		},

		getFullKey: function(key, namespace){
			// checks for valid namespace and
			// key are already performed.
			return "__" + namespace + "_" + key;
		},

		_beginsWith: function(/* string */ haystack, /* string */ needle) {
			if(needle.length > haystack.length) {
				return false;
			}
			return haystack.substring(0,needle.length) === needle;
		},

		_assertIsValidNamespace: function(/* string */ namespace){
			if(this.isValidNamespace(namespace) === false){
				throw new Error("Invalid namespace given: " + namespace);
			}
		},

		_assertIsValidKey: function(/* string */ key){
			if(this.isValidKey(key) === false){
				throw new Error("Invalid key given: " + key);
			}
		}
	}
);

dojox.storage.manager.register("dojox.storage.LocalStorageProvider", new dojox.storage.LocalStorageProvider());
});

},
'cwtk/eligibilityresults/Transitions':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("cwtk/eligibilityresults/Transitions", [
    "dojo", 
    "dojo/_base/declare", 
	"dojo/_base/connect",
    "dojo/NodeList-traverse",
    "dijit/a11y", 
    "dijit/focus", 
    "dojo/fx", 
	"dojo/fx/easing"
], function(dojo, declare, connect, traverse, a11y, focus, coreFx, easing){

		return declare("cwtk.eligibilityresults.Transitions", null, {
		
		    isOpen : false,
		    
		    _tempEventHandle : null,
		
		    constructor: function() {
			    connect.subscribe("cw_dismiss", dojo.hitch(this, this.onDismiss));
			},
		    
		    invokeEnrollment: function(node) {
				
				if (dojo.hasClass('eligibility-main-layout', 'cw-open-enrollment')) {
					this.closeEnrollment(node);
				} else {
					this.openEnrollment(node);
				}
				
				
			},
			
			openEnrollment: function(node) {
				var step1Duration = 1000;
				var step2Duration = 1000;
				var step3Duration = 1000;
				
				var layout = dojo.byId('eligibility-main-layout');
				var triage = dojo.byId('triage');		
				var content = dojo.byId('eligibility-content');
				var centralPanel = dojo.byId('background-panel');
				var category = dojo.query(node).parents(".cw-category")[0];
				var program = dojo.query(node).parents(".cw-program")[0];
		        var description = dojo.query('.cw-program-description', program)[0];		

				dojo.addClass(layout, 'cw-open-enrollment');
		        dojo.addClass(program, 'cw-open');
		        dojo.addClass(category, 'cw-open');	
		        dojo.addClass(centralPanel, "cw-open");
		        dojo.style(centralPanel, {'top': '0', 'bottom' : '0'});
				
				var contentShift = this.getShiftWidth(content);  
		        
				/*
				 * Step 1: move panes
				 */
				
				try {
    				//stretch content pane
    				dojo.animateProperty({node: content, 
    		                	    	properties: {right: 0}, 
		                    	    	duration: step1Duration}).play();
                } catch(e){
                    console.log(e);
                }	       
                
                try {         	    	
    		        //move program pane to right (to keep same position)        	    	
    				dojo.animateProperty({node: program, 
		                	    	    properties: {left: contentShift}, 
		                	    	    duration: step1Duration}).play();
                } catch(e) {
                    console.log(e);
                }
		             
                try {   	    	
    		        //move category panes to left        	    	
    		        dojo.query('.cw-category').forEach(function(cat){
    		    		dojo.animateProperty({node: cat, 
    		                	    	properties: {left: (-1 * contentShift)}, 
    		                	    	duration: step1Duration}).play();
    		        });
		        } catch(e) {
		            console.log(e);
	            }
	            
	            try {
    		        //move triage to right 
    		        var triageShift = this.getShiftWidth(triage);
    		        if (triage) {       	    	
    		    		dojo.animateProperty({node: triage, 
    		                	    	properties: {right: (-1 * triageShift)}, 
    		                	    	duration: step1Duration}).play();
    		        }
		        } catch(e) {
		            console.log(e);
	            }
	                    	    	
		        //fade others out
		        dojo.query(
		            '.cw-program-title-show-hide, ' + 
		            '.cw-title-pane-title, ' + 
		            '.cw-program:not(.cw-open), ' + 
		            '.cw-triage, ' + 
		            '.cw-program.cw-open .cw-action-button, ' + 
		            '.cw-program.cw-open .cw-program-description').forEach(function(n){
		        		dojo.animateProperty({node: n, 
		                    properties: {opacity: 0}, 
		                    duration: step1Duration / 2, onEnd: function(){
		                        dojo.style(n, 'visibility', 'hidden');
		                    }}).play();
		        });        	   
		        
				
				/*
				 * Step 2: move program pane up
				 */
				 
				var posCon = dojo.position(content, true);
			
			    //wait panes to move
				dojo.animateProperty({node: program, delay: step1Duration, 
		    		onEnd: function() {
		    			var posPro = dojo.position(program, true);
		    			var posBack = dojo.position(centralPanel, true);
		    			
		    			var offsetProgram = (posPro.y - posCon.y) * -1;
		    			
                        console.log("[Transitions] Offset program panel: " + offsetProgram);
		    			//move program pane up
		    			var animProgram = dojo.animateProperty({node: program, 
		                	    	properties: {top: offsetProgram}, 
		                	    	duration: step2Duration});
		                	    	
		                //contract program description pane    
		    	        var animDesc = dojo.animateProperty({node: description, 
		        	    	properties: {height: 0}, 
		        	    	duration: step2Duration});
		        	    	
		        	    //wait both animations to complete
		        	    var combAnim = coreFx.combine([animProgram, animDesc]);
		        	    combAnim.onEnd = function(){
                    	    var posPro = dojo.position(program, true);
                    	    var posLayout = dojo.position(layout, true);
                    	    var offsetBackground = (posPro.y - posLayout.y) + posPro.h;
                            console.log("[Transitions] Offset background panel: " + offsetBackground);
                    	    dojo.style(centralPanel, {'top': offsetBackground + 'px'});
                    	};
                    	combAnim.play();
		    		}}).play();
				
			    	
			    /*
				 * Step 3: fade central pane in
				 */	
			    	
		        //move program pane up
		    	dojo.animateProperty({node: centralPanel, 
		            delay: step1Duration + step2Duration, 
		            onEnd: function() {
 
		                //fade background pane in
		                dojo.style(centralPanel, {'opacity' : '0'});
		                dojo.style(centralPanel, {'display': 'block'});
		                dojo.style(centralPanel, {'width': '97%'});//TODO
		                dojo.animateProperty({node: centralPanel, 
		                    properties: {opacity: 1}, 
		                    duration: step3Duration}).play();
		                //assure layout size (BorderContainer.resize() gets called sometimes)    
		                dojo.addClass(layout, 'cw-enrollment-expanded');
		                var focusables = a11y._getTabNavigable(centralPanel);
		                focus.focus(focusables.lowest || focusables.first || centralPanel.domNode);    
		            }}).play();    	
					
				this.isOpen = true;
				
				this._tempEventHandle = dojo.connect(
				    dijit.byId('eligibility-main-layout'), 
				    "resize", 
				    dojo.hitch(this, function(ev){ 
                       this.onResize(ev);
                    }));
			},
			
			closeEnrollment: function(node) {
		
				var step1Duration = 1000;
				var step2Duration = 1000;
				var step3Duration = 1000;
				
				var layout = dojo.byId('eligibility-main-layout');		
				var triage = dojo.byId('triage');		
				var content = dojo.byId('eligibility-content');
				var centralPanel = dojo.byId('background-panel');
				var category = dojo.query(node).parents(".cw-category")[0];
				var program = dojo.query(node).parents(".cw-program")[0];
				var description = dojo.query('.cw-program-description', program)[0];
				
				//close
		        //EligibilityResultTransitions.briefClass(layout, 'cw-close-enrollment-event', overallDuration);	
				
				//re-determine layout size (if BorderContainer.resize() has been called)
				dojo.style(content, 'right', '0');
				dojo.removeClass(layout, 'cw-enrollment-expanded');
				if (triage) {
				    var triageShift = this.getShiftWidth(triage);
				    dojo.style(triage, 'right', (-1 * triageShift) +'px');
				}
				
				/*
				 * Step 1: fade central pane out
				 */		
				dojo.animateProperty({node: centralPanel, properties: {opacity: 0}, duration: step1Duration, onEnd: function() {
				    dojo.style(centralPanel, {'display': 'none'});
				    
				    //dojo.style(content, 'right', '0');
		            //dojo.removeClass(content, 'cw-open');
				}}).play();
				
				/*
				 * Step 2: move program pane down
				 */	
		    	dojo.fx.wipeIn({node: description, 
		    	    delay: step1Duration, 
			        duration: step2Duration}).play();
		    	
				dojo.animateProperty({node: program, 
			        properties: {top: 0}, 
			        delay: step1Duration, 
			        duration: step2Duration}).play();
		        
		        /*
				 * Step 3: move others back on
				 */
		        dojo.animateProperty({node: program, 
		    	    delay: step1Duration + step2Duration, 
			        onEnd: function(){
			        
		            		//move program pane to right (to keep same position)        	    	
		            		dojo.animateProperty({node: program, 
		                            	    	properties: {left: 0}, 
		                            	    	duration: step3Duration}).play();
		                            	    	
		                    //move category panes to left        	    	
		                    dojo.query('.cw-category').forEach(function(cat){
		                		dojo.animateProperty({node: cat, 
		                            	    	properties: {left: 0}, 
		                            	    	duration: step3Duration}).play();
		                    });
		                    
		                    //stretch content pane
		                    if (triage) {
		                        var posTriage = dojo.position(triage, true);
		                    
		                    	dojo.animateProperty({node: content, 
		                                        	properties: {right: posTriage.w}, 
		                                        	duration: step3Duration}).play();
		                        
		                        //move triage to right        	    	
		                    	dojo.animateProperty({node: triage, 
		                                        	properties: {right: 0}, 
		                                        	duration: step3Duration}).play();
		                    }
		                            	    	
		                    //fade others in
		                    dojo.query(
		                        '.cw-program-title-show-hide, ' + 
		                        '.cw-program:not(.cw-open), ' + 
		                        '.cw-program.cw-open .cw-action-button, ' +
		                        '.cw-program.cw-open .cw-program-description, ' + 
		                        '.cw-title-pane-title, ' + 
		                        '.cw-triage').forEach(function(n){
		                            dojo.style(n, 'visibility', 'visible');
		                            dojo.animateProperty({node: n, 
		                                properties: {opacity: 1},
		                                duration: step3Duration}).play();
		                    }); 
		            		
			        
			        }}).play();        	
				
		            dojo.animateProperty({node:layout, 
		                delay: step1Duration + step2Duration + step3Duration, 
		                onEnd: function(){
		                    dojo.removeClass(layout, 'cw-open-enrollment');
		                    dojo.removeClass(program, 'cw-open');
		                    dojo.removeClass(centralPanel, "cw-open");
		                    dojo.removeClass(category, 'cw-open');
		            }}).play();
		            
		            this.isOpen = false;
		            
		            dojo.disconnect(this._tempEventHandle);
		            this._tempEventHandle = null;
			},
			
			briefClass : function(node, styleClass, duration) {
			    
			    dojo.addClass(node, styleClass);
			    
			    dojo.animateProperty({node: node, duration: duration, onEnd: function() {
		    		dojo.removeClass(node, styleClass);
				}}).play();
			},
			
			invokeExpandedMap: function() {
			    var layout = dojo.byId('eligibility-main-layout');
			    
		        this.briefClass(layout, 'cw-map-event', 1000);
			    if (dojo.hasClass(layout, 'cw-extended-map')) {
		    	    //EligibilityResultTransitions.briefClass(layout, 'cw-standard-map-event', 1000);
			    } else {
		    	    //EligibilityResultTransitions.briefClass(layout, 'cw-extended-map-event', 1000);
			    }
			    
				dojo.removeClass(layout, 'cw-collapsed-map');
		        dojo.toggleClass(layout, 'cw-extended-map');
			},
			
			invokeCollapsedMap: function() {
			    var layout = dojo.byId('eligibility-main-layout');
			    
		        this.briefClass(layout, 'cw-map-event', 1000);
			    if (dojo.hasClass(layout, 'cw-collapsed-map')) {
		    	    //EligibilityResultTransitions.briefClass(layout, 'cw-standard-map-event', 1000);
			    } else {
		    	    //EligibilityResultTransitions.briefClass(layout, 'cw-collapsed-map-event', 1000);
			    }
			    
			    dojo.removeClass(layout, 'cw-extended-map');
		        dojo.toggleClass(layout, 'cw-collapsed-map');
			},
			
			getShiftWidth: function(node) {
			    var shift = dojo.position(node, true).w;
    			if (screen) {
			        shift = Math.max(screen.width, shift);
    			} 
    			return shift + 100;
			},
			
			onDismiss: function(event) {
			    var bgQuery = dojo.query(event.node).parents(".cw-background-panel");
                if (bgQuery.length > 0 || dojo.hasClass(event.node, "cw-background-panel")) {
                    var bgpanel = bgQuery[0];
                    var actionButton = dojo.query(".cw-program.cw-open .cw-action-button")[0];
                    this.closeEnrollment(actionButton);
                }
			},
			
			onResize: function(event) {
			    if (this.isOpen) {
    			    var layout = dojo.byId('eligibility-main-layout');
    			    var program = dojo.query('.cw-program.cw-open')[0];
    			    var posPro = dojo.position(program, true);
                    var posLayout = dojo.position(layout, true);
                    var offsetBackground = (posPro.y - posLayout.y) + posPro.h;
                    console.log("[Transitions] Resized screen, offset background panel: " + offsetBackground);
                    var centralPanel = dojo.byId('background-panel');
                    dojo.style(centralPanel, {'top': offsetBackground + 'px', 'bottom' : '0'});
			    }
			}
		          
		});

});
},
'url:dijit/templates/TooltipDialog.html':"<div role=\"presentation\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" data-dojo-attach-point=\"containerNode\" role=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\"></div>\n</div>\n",
'dojox/xml/parser':function(){
define("dojox/xml/parser", ['dojo/_base/kernel', 'dojo/_base/lang', 'dojo/_base/array', 'dojo/_base/window', 'dojo/_base/sniff'], function(dojo){

dojo.getObject("xml.parser", true, dojox);

//DOM type to int value for reference.
//Ints make for more compact code than full constant names.
//ELEMENT_NODE                  = 1;
//ATTRIBUTE_NODE                = 2;
//TEXT_NODE                     = 3;
//CDATA_SECTION_NODE            = 4;
//ENTITY_REFERENCE_NODE         = 5;
//ENTITY_NODE                   = 6;
//PROCESSING_INSTRUCTION_NODE   = 7;
//COMMENT_NODE                  = 8;
//DOCUMENT_NODE                 = 9;
//DOCUMENT_TYPE_NODE            = 10;
//DOCUMENT_FRAGMENT_NODE        = 11;
//NOTATION_NODE                 = 12;

dojox.xml.parser.parse = function(/*String?*/ str, /*String?*/ mimetype){
	//	summary:
	//		cross-browser implementation of creating an XML document object from null, empty string, and XML text..
	//
	//	str:
	//		Optional text to create the document from.  If not provided, an empty XML document will be created.
	//		If str is empty string "", then a new empty document will be created.
	//	mimetype:
	//		Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.
	var _document = dojo.doc;
	var doc;

	mimetype = mimetype || "text/xml";
	if(str && dojo.trim(str) && "DOMParser" in dojo.global){
		//Handle parsing the text on Mozilla based browsers etc..
		var parser = new DOMParser();
		doc = parser.parseFromString(str, mimetype);
		var de = doc.documentElement;
		var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
		if(de.nodeName == "parsererror" && de.namespaceURI == errorNS){
			var sourceText = de.getElementsByTagNameNS(errorNS, 'sourcetext')[0];
			if(sourceText){
				sourceText = sourceText.firstChild.data;
			}
        	throw new Error("Error parsing text " + de.firstChild.data + " \n" + sourceText);
		}
		return doc;

	}else if("ActiveXObject" in dojo.global){
		//Handle IE.
		var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
		var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
		dojo.some(dp, function(p){
			try{
				doc = new ActiveXObject(p);
			}catch(e){ return false; }
			return true;
		});
		if(str && doc){
			doc.async = false;
			doc.loadXML(str);
			var pe = doc.parseError;
			if(pe.errorCode !== 0){
				throw new Error("Line: " + pe.line + "\n" +
					"Col: " + pe.linepos + "\n" +
					"Reason: " + pe.reason + "\n" +
					"Error Code: " + pe.errorCode + "\n" +
					"Source: " + pe.srcText);
			}
		}
		if(doc){
			return doc; //DOMDocument
		}
	}else if(_document.implementation && _document.implementation.createDocument){
		if(str && dojo.trim(str) && _document.createElement){
			//Everyone else that we couldn't get to work.  Fallback case.
			// FIXME: this may change all tags to uppercase!
			var tmp = _document.createElement("xml");
			tmp.innerHTML = str;
			var xmlDoc = _document.implementation.createDocument("foo", "", null);
			dojo.forEach(tmp.childNodes, function(child){
				xmlDoc.importNode(child, true);
			});
			return xmlDoc;	//	DOMDocument
		}else{
			return _document.implementation.createDocument("", "", null); // DOMDocument
		}
	}
	return null;	//	null
};

dojox.xml.parser.textContent = function(/*Node*/node, /*String?*/text){
	//	summary:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//	description:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//		This function can also update the text of a node by replacing all child
	//		content of the node.
	//	node:
	//		The node to get the text off of or set the text on.
	//	text:
	//		Optional argument of the text to apply to the node.
	if(arguments.length>1){
		var _document = node.ownerDocument || dojo.doc;  //Preference is to get the node owning doc first or it may fail
		dojox.xml.parser.replaceChildren(node, _document.createTextNode(text));
		return text;	//	String
	}else{
		if(node.textContent !== undefined){ //FF 1.5 -- remove?
			return node.textContent;	//	String
		}
		var _result = "";
		if(node){
			dojo.forEach(node.childNodes, function(child){
				switch(child.nodeType){
					case 1: // ELEMENT_NODE
					case 5: // ENTITY_REFERENCE_NODE
						_result += dojox.xml.parser.textContent(child);
						break;
					case 3: // TEXT_NODE
					case 2: // ATTRIBUTE_NODE
					case 4: // CDATA_SECTION_NODE
						_result += child.nodeValue;
				}
			});
		}
		return _result;	//	String
	}
};

dojox.xml.parser.replaceChildren = function(/*Element*/node, /*Node || Array*/ newChildren){
	//	summary:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	//	description:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// 	node:
	//		The node to modify the children on
	//	newChildren:
	//		The children to add to the node.  It can either be a single Node or an
	//		array of Nodes.
	var nodes = [];

	if(dojo.isIE){
		dojo.forEach(node.childNodes, function(child){
			nodes.push(child);
		});
	}

	dojox.xml.parser.removeChildren(node);
	dojo.forEach(nodes, dojo.destroy);

	if(!dojo.isArray(newChildren)){
		node.appendChild(newChildren);
	}else{
		dojo.forEach(newChildren, function(child){
			node.appendChild(child);
		});
	}
};

dojox.xml.parser.removeChildren = function(/*Element*/node){
	//	summary:
	//		removes all children from node and returns the count of children removed.
	//		The children nodes are not destroyed. Be sure to call dojo.destroy on them
	//		after they are not used anymore.
	//	node:
	//		The node to remove all the children from.
	var count = node.childNodes.length;
	while(node.hasChildNodes()){
		node.removeChild(node.firstChild);
	}
	return count; // int
};


dojox.xml.parser.innerXML = function(/*Node*/node){
	//	summary:
	//		Implementation of MS's innerXML function.
	//	node:
	//		The node from which to generate the XML text representation.
	if(node.innerXML){
		return node.innerXML;	//	String
	}else if(node.xml){
		return node.xml;		//	String
	}else if(typeof XMLSerializer != "undefined"){
		return (new XMLSerializer()).serializeToString(node);	//	String
	}
	return null;
};

return dojox.xml.parser;

});

},
'dojo/dnd/TimedMoveable':function(){
define("dojo/dnd/TimedMoveable", ["../main", "./Moveable"], function(dojo) {
	// module:
	//		dojo/dnd/TimedMoveable
	// summary:
	//		TODOC

	/*=====
	dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
		// timeout: Number
		//		delay move by this number of ms,
		//		accumulating position changes during the timeout
		timeout: 0
	});
	=====*/

	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;

	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.

		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps

		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.

			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},

		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer);
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});

	return dojo.dnd.TimedMoveable;
	
});

},
'idx/oneui/MenuDialog':function(){
require({cache:{
'url:idx/oneui/templates/MenuDialog.html':"<div role=\"presentation\">\r\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\r\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" data-dojo-attach-point=\"containerNode\" role=\"dialog\" tabIndex=\"-1\"></div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\r\n</div>\r\n"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/MenuDialog", ["dojo/_base/declare",
		"dojo/_base/array",
		"dojo/_base/connect",
		"dojo/_base/event",
		"dojo/_base/lang",
		"dojo/_base/sniff",
		"dojo/_base/window",
		"dojo/aspect",
		"dojo/dom",
		"dojo/dom-class",
		"dojo/dom-geometry",
		"dojo/dom-style",
		"dojo/io/iframe",
		"dojo/keys",
		"dojo/window",
		"dijit/popup",
		"dijit/TooltipDialog",
		"idx/oneui/_EventTriggerMixin",
		"dojo/text!../oneui/templates/MenuDialog.html"],
		function(declare, array, connect, event, lang, has, win, aspect, dom, domClass, domGeometry, domStyle, iframe, keys, window, popup, TooltipDialog, _EventTriggerMixin, template){
		
	function nodeUsesArrowKeys(/*DOMNode*/ node){
		// return true if the DOM node is one that uses arrow keys (like
		// a text entry field) but doesn't stop them propagating -- we
		// will ignore arrow keypresses that were originally targetted
		// at such nodes so as not to double-act when the arrow keys are
		// pressed.
		
		return (node.nodeName === "TEXTAREA")
		    || ((node.nodeName === "INPUT") && (node.type === "text"));
	}

	/**
	 * Creates a new idx.oneui.MenuDialog
	 * @name idx.oneui.MenuDialog
	 * @class The MenuDialog widget is the main container for rich mega-menu
	 * content.
	 * <p>Instances can be supplied as the "popup" parameter for 
	 * dijit.PopupMenuItem and dijit.PopupMenuBarItem, and will work
	 * "as expected". Instances can also operate as popup menus on arbitrary
	 * DOM nodes, or for the whole window.
	 * </p>
	 * <p>Instances can display with a "shark fin" connector to identify
	 * the initiating element or with a thinner border, no shark
	 * fin and abutting the initiating element.
	 * </p>
	 * <p>Instances behave as content panes, and HTML and dijits may be
	 * laid out within them. If a menu with "menuForDialog" set to true is
	 * included within the layout, the menu dialog will operate as a
	 * drop-down menu in combination with the contained	menu.
	 * </p>
	 * @augments dijit.TooltipDialog
	 * @augments idx.oneui._EventTriggerMixin
	 * @example
	 * &lt;div data-dojo-type="idx.oneui.MenuBar"&gt;
  &lt;div data-dojo-type="dijit.PopupMenuBarItem"&gt;
    &lt;span&gt;Menu #1&lt;/span&gt;
    &lt;div data-dojo-type="idx.oneui.MenuDialog"&gt;</span>
      &lt;!-- Arbitrary mega menu content --&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
	 */
	return declare("idx.oneui.MenuDialog", [TooltipDialog, _EventTriggerMixin],
	/** @lends idx.oneui.MenuDialog.prototype */
	{
		/**
		 * CSS class applied to DOM node. Part of standard templated widget 
		 * behavior.
		 * @type string
		 * @constant
		 * @private
		 */
		baseClass: "oneuiMenuDialog",
		
		/**
		 * Flag to indicate whether we need to close ourselves in onBlur. This
		 * flag is only true while we are popped up from a manual open or
		 * bindDomNode trigger.
		 * @type boolean
		 * @private
		 */
		_closeOnBlur: false,
		
		/**
		 * If true, hover will trigger popup whenever the menu dialog is
		 * bound to a DOM node (via bindToDomNode). Otherwise, a mouse
		 * click (or tap on a touch interface) will be required. This setting
		 * does not affect keyboard alternative triggers, which will be
		 * active in the same way in all cases. This value can be overridden
		 * for individual calls to bindToDomNode by including a "hoverToOpen"
		 * property in the (optional) parameters object.
		 * @type boolean
		 */
		hoverToOpen: true,
		
		/**
		 * True if the menu dialog is currently showing, false otherwise. Part
		 * of the standard dijit menu logic.
		 * @type boolean
		 * @private
		 */
		isShowingNow: false,
		
		/**
		 * If true, a left mouse click (or tap on a touch interface) will
		 * trigger popup whenever the menu dialog is bound to a DOM node
		 * (via bindDomNode). Otherwise, a right mouse click will be
		 * required. Furthermore, when leftClickToOpen is true the keyboard
		 * alternative triggers become space-bar and enter key and the popup
		 * is automatically positioned relative to the triggering DOM node,
		 * whilst when leftClickToOpen is false the keyboard alternative
		 * trigger is Shift+F10 and the popup is positioned relative to the
		 * mouse position (when triggered by a mouse event, and relative to
		 * the triggering DOM node otherwise). This value can be overridden
		 * for individual calls to bindDomNode by including a
		 * "leftClickToOpen" property in the (optional) parameters object.
		 * @type boolean
		 */
		leftClickToOpen: false,
		
		/**
		 * Pointer to menu that displayed the MenuDialog. Part
		 * of the standard dijit menu logic.
		 * @type dijit.Widget
		 * @private
		 */
		parentMenu: null,

		/**
		 * Ordered list of positions to try placing the popup at whenever the
		 * menu dialog is bound to a DOM node (via bindToDomNode). The first
		 * position which allows the popup to be fully visible within the
		 * viewport will be used. Possible values are:
		 * <ul>
		 * <li>
		 * before: places drop down to the left of the anchor node/widget, or
		 * to the right in RTL mode
		 * </li>
		 * <li>
		 * after: places drop down to the right of the anchor node/widget, or
		 * to the right in RTL mode
		 * </li>
		 * <li>
		 * above: drop down goes above anchor node/widget
		 * </li>
		 * <li>
		 * above-alt: same as above except right sides aligned instead of left
		 * </li>
		 * <li>
		 * below: drop down goes below anchor node/widget
		 * </li>
		 * <li>
		 * below-alt: same as below except right sides aligned instead of left
		 * </li>
		 * </ul>
		 * This value can be overridden for individual calls to bindToDomNode
		 * by including a "popupPosition" property in the (optional)
		 * parameters object. If no value is provided (or null) a default
		 * sequence of positions (below, below-alt, above, above-alt) is used.
		 * @name popupPosition
		 * @memberOf idx.oneui.MenuDialog.prototype
		 * @type string[]
		 */
		
		/**
		 * If true, when this menu dialog closes re-focus the element
		 * which had focus before it was opened.
		 * @type boolean
		 * @private
		 */
		refocus: true,
	
		/**
		 * An array of DOM node ids to which the menu dialog should be
		 * bound during widget initialisation. Note that this array is
		 * processed only once, during creation, and later changes that
		 * may be made will be ignored; also, the array is not updated
		 * if/when further explicit calls to bindDomNode/unbindDomNode are made.
		 * @name targetNodeIds
		 * @memberOf idx.oneui.MenuDialog.prototype
		 * @type DOMNode[]
		 */
		
		/**
	 	 * The template HTML for the widget.
		 * @constant
		 * @type string
		 * @private
		 * @default Loaded from idx/oneui/templates/MenuDialog.html.
		 */
		templateString: template,
		
		/**
		 * If true, the menu will show a "shark-fin" connector linking the
		 * opened popup dialog to the initiating DOM element or menu item.
		 * This value can be overridden for individual calls to bindDomNode
		 * by including a "useConnector" property in the (optional)
		 * parameters object.
		 * @type boolean
		 */
		useConnector: false,

		/**
		 * Standard Widget lifecycle method.
		 * @private
		 */		
		postCreate: function(){
			this.inherited(arguments);
			
			// intercept and process certain navigational keystrokes
			var l = this.isLeftToRight();
			this._nextMenuKey = l ? keys.RIGHT_ARROW : keys.LEFT_ARROW;
			this._prevMenuKey = l ? keys.LEFT_ARROW : keys.RIGHT_ARROW;
			this.connect(this.domNode, "onkeypress", "_onDomNodeKeypress");
			
			// do any initial bindings to DOM nodes requested
			if(this.contextMenuForWindow){
				this.bindDomNode(win.body());
			}else{
				array.forEach(this.targetNodeIds, function(nodeid){
					this.bindDomNode(nodeid);
				}, this);
			}
		},
		
		/**
		 * Handle keypress events at the outer containing DOM node to process
		 * arrow-key navigation.
		 * @param {Event} evt
		 */
		_onDomNodeKeypress: function(evt){
			var target = evt.target || evt.srcElement,
				handled = false;

			if(this.parentMenu && !evt.ctrlKey && !evt.altKey && (!target || !nodeUsesArrowKeys(target))){
				switch(evt.charOrCode){
					case this._nextMenuKey:
						this.parentMenu._getTopMenu().focusNext();
						handled = true;
						break;
						
					case this._prevMenuKey:
						if(this.parentMenu._isMenuBar){
							this.parentMenu.focusPrev();
						}else{
							this.onCancel(false);
						}
						handled = true;
						break;
				}
			}
			
			if(handled){
				event.stop(evt);
			}else{
				this.inherited(arguments);
			}
		},		
		
		/**
		 * Return the menu for the dialog, or undefined if no menu for the
		 * dialog can be found.
		 */
		_getMenuForDialog: function(){
			var children = this.getChildren(),
				result;
				
			for(var i = 0; !result && (i < children.length); i++){
				if(children[i] && children[i].menuForDialog){
					result = children[i];
				}
			}

			return result;
		},
		
		/**
		 * Finds focusable items in dialog,	and sets this._firstFocusItem and
		 * this._lastFocusItem.
		 */		
		_getFocusItems: function(){
			this.inherited(arguments);
			
			// if _firstFocusItem or _lastFocusItem have been set to our DOM node,
			// set them to the containerNode instead, which is a better focus target
			if(this._firstFocusItem == this.domNode){
				this._firstFocusItem = this.containerNode;
			}
			if(this._lastFocusItem == this.domNode){
				this._lastFocusItem = this.containerNode;
			}
		},
		
		/**
		 * Called when an event occurs that should result in the MenuDialog
		 * being shown.
		 * <p>
		 * Set timer to display myself. Using a timer rather than displaying
		 * immediately solves two problems:
		 * <ol>
		 * <li>
		 * IE: without the delay, focus work in "open" causes the system
		 * context menu to appear in spite of stopEvent.
		 * </li>
		 * <li>
		 * Avoid double-shows on linux, where shift-F10 generates an 
		 * oncontextmenu event even after a event.stop(e). (Shift-F10 on
		 * windows doesn't generate the oncontextmenu event.)
		 * </p>
		 * @private
		 * @param {Object} params An object containing data about the event. See
		 * {@link idx.oneui._EventTriggerMixin#_onTrigger}
		 */
		_onTrigger: function(params){
			var coords = null;
			if(!params.additionalData.leftClickToOpen && ("pageX" in params.event)){
				coords = { x: params.event.pageX, y: params.event.pageY }; 			
				if (params.triggerNode.tagName === "IFRAME") {
					// Specified coordinates are on <body> node of an <iframe>, convert to match main document
					var ifc = domGeometry.position(params.triggerNode, true), scroll = win.withGlobal(window.get(iframe.doc(params.triggerNode)), "docScroll", domGeometry);
					
					var cs = domStyle.getComputedStyle(params.triggerNode), tp = domStyle.toPixelValue, left = (has("ie") && has("quirks") ? 0 : tp(params.triggerNode, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(params.triggerNode, cs.borderLeftWidth) : 0), top = (has("ie") && has("quirks") ? 0 : tp(params.triggerNode, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(params.triggerNode, cs.borderTopWidth) : 0);
					
					coords.x += ifc.x + left - scroll.x;
					coords.y += ifc.y + top - scroll.y;
				}
			}
	
			if(!this._openTimer){
				this._openTimer = setTimeout(lang.hitch(this, function(){
					delete this._openTimer;

					this.open({
						around: params.triggerNode,
						coords: coords,
						position: params.additionalData.popupPosition,
						useConnector: params.additionalData.useConnector
					});
				}), 1);
			}
			
			if(params.event.type != "hover")
				event.stop(params.event);
		},
	
		/**
		 * An attach point that is called when the MenuDialog loses focus. 
		 */
		onBlur: function(){
			this.inherited(arguments);

			if(this._closeOnBlur){
				this.close();
			}
		},

		/**
		 * Opens the MenuDialog at the specified position.
		 * @param {Object} args An object containing some the following fields,
		 * which are all optional but at least one of 'around' and 'coords'
		 * should be supplied:
		 * <ul>
		 * <li>
		 * 	around: A DOM node that the popup should be placed around.
		 * </li>
		 * <li>
		 * 	coords: A position (with fields x and y) containing coordinates
		 * 	that the popup should be placed at.
		 * </li>
		 * <li>
		 * 	position: Ordered list of positions to try placing the popup at.
		 * 	The first position which allows the popup to be fully visible
		 * 	within the viewport will be used, or the best available option.
		 * 	Possible values are:
		 * 	<ul>
		 * 		<li>
		 * 			before: places drop down to the left of the around
		 * 			node/coords, or to the right in RTL mode
		 * 		</li>
		 * 		<li>
		 *			after: places drop down to the right of the around
		 *			node/coords, or to the right in RTL mode
		 * 		</li>
		 * 		<li>
		 *			above: drop down goes above around node/coords
		 * 		</li>
		 * 		<li>
		 *			above-alt: same as above except right sides aligned
		 *			instead of left
		 * 		</li>
		 * 		<li>
		 *			below: drop down goes below around node/coords
		 * 		</li>
		 * 		<li>
		 *			below-alt: same as below except right sides aligned instead
		 *			of left
		 * 		</li>
		 * 		</ul>
		 *		If this field is omitted the current value of the widget
		 *		popupPosition property is used.
		 * </li>
		 * <li>
		 *		useConnector: If true, a shark-fin connector is shown linking
		 *		the popup to the around node/coords. If this field is omitted
		 *		the current value of the widget useConnector property is used.
		 * </li>
		 * </ul>
		 */		
		open: function(args){
			// store the node which focus should return to, if necessary, and if possible
			var refocusNode = null;
			if(this.refocus){
				refocusNode = this._focusManager.get("curNode");
				if(!refocusNode || dom.isDescendant(refocusNode, this.domNode)){
					refocusNode = this._focusManager.get("prevNode");
				}
				if(dom.isDescendant(refocusNode, this.domNode)){
					refocusNode = null;
				}
			}
			
			// use coords if supplied, otherwise use the around node if supplied,
			// or use current focus node, or (0,0) as a last resort
			var around = (args && (args.coords ? { x: args.coords.x, y: args.coords.y, w: 0, h: 0 } : args.around)) || refocusNode || this._focusManager.get("curNode") || { x: 0, y: 0, w: 0, h: 0 };
				
			var closeFunction = lang.hitch(this, function(){
				if(refocusNode){
					refocusNode.focus();
				}
				
				this.close();
			});
						
			this._useConnectorForPopup = (args && ("useConnector" in args)) ? args.useConnector : this.useConnector;
				
			popup.open({
				popup: this,
				around: around,
				onExecute: closeFunction,
				onCancel: closeFunction,
				orient: (args && ("position" in args)) ? args.position : this.popupPosition
			});
				
			delete this._useConnectorForPopup;
						
			this.focus();
			this._closeOnBlur = true;
		},
		
		/**
		 * Closes the MenuDialog. 
		 */
		close: function(){
			popup.close(this);
		},
		
		/**
		 * Attach the MenuDialog to the specified trigger node.
		 * @param {string|DOMNode} node The node to be used to trigger the
		 * MenuDialog to pop-up. 
		 * @param {Object} params An object that can contain properties that 
		 * override the popupPosition, useConnector, leftClickToOpen,
		 * and hoverToOpen properties of the 
		 * MenuDialog on a per node attachment basis.
		 */
		bindDomNode: function(/*String|DomNode*/ node, /*Object*/ params){
			var settings = lang.delegate(this);
			for(var name in params){
				settings[name] = params[name];
			}
			
			this._addEventTrigger(node, "click", function(fparams){
				return settings.leftClickToOpen;
			}, settings);
			
			this._addEventTrigger(node, "contextmenu", function(fparams){
				return !settings.leftClickToOpen;
			}, settings);
			
			this._addEventTrigger(node, "keydown", function(fparams){
				// if right-click is the trigger, accept Shift+F10 as an equivalent
				// in case the browser doesn't send us the contextmenu event
				return !settings.leftClickToOpen && fparams.event.shiftKey && (fparams.event.keyCode == keys.F10);
			}, settings);
			
			this._addEventTrigger(node, "hover", function(fparams){
				return settings.hoverToOpen;
			}, settings);
		},
	
		/**
		 * Detach menu dialog from given DOM node. If no node is specified,
		 * detach menu dialog from all bound DOM nodes.
		 * @param {string|DOMNode} nodeName The DOM node to dissociate the 
		 * MenuDialog from.
		 */
		unBindDomNode: function(/*String|DomNode*/ nodeName){
			this._removeEventTriggers(nodeName);
		},
		
		/**
		 * Configure the widget to display in a given position. This may be
		 * called several times during popup in order to "try out" different
		 * configurations and then select the best. It will always be called
		 * one final time with the actual configuration to be used.
		 * @param {Object} aroundNodeSize
		 * @param {string} aroundCorner
		 * @param {string} corner
		 * @param {boolean} useConnector
		 */
		_layoutNodes: function(/*Object*/ aroundNodeSize, /*String*/ aroundCorner, /*String*/ corner, /*Boolean*/ useConnector){
			var newcss = useConnector ? "oneuiMenuDialogConnected" : "",
				newparentcss = "",
				cornerv = corner && (corner.length >= 1) && corner.charAt(0),
				cornerh = corner && (corner.length >= 2) && corner.charAt(1),
				mybox = domGeometry.getContentBox(this.domNode),
				displacementProperty, displacementValue,
				getContentBox = function(node){
					var style = node.style,
						oldDisplay = style.display,
						oldVis = style.visibility;
					if(style.display == "none"){
						style.visibility = "hidden";
						style.display = "";
					}
					var result = domGeometry.getContentBox(node);
					style.display = oldDisplay;
					style.visibility = oldVis;
					return result;
				}
			
			// we use a combination of two classes to enable the CSS markup to be applied
			// to position our connector correctly.
			//
			// dijitTooltipAbove, dijitTooltipBelow, dijitTooltipLeft, dijitTooltipRight,
			// indicating which way the popup goes from the position or around node
			//
			// When dijitTooltipAbove or dijitTooltipBelow are used, one of the classes
			// dijitTooltipABLeft, dijitTooltipABRight, dijitTooltipABMiddle is also
			// applied to indicate where on the top/bottom edge the connector should appear.    
			//
			// When dijitTooltipLeft or dijitTooltipRight are used, one of the classes
			// dijitTooltipLRTop, dijitTooltipLRBottom, dijitTooltipLRMiddle is also
			// applied to indicate where on the left/right edge the connector should appear.			
			 
			if( (cornerv === 'M')  // 'ML' or 'MR'
			 || ((cornerh !== 'M') && (cornerh !== aroundCorner.charAt(1)))){  // '?L' against '?R' means a left/right abuttal
				// the popup is going left or right
				newcss += " dijitTooltip" + (cornerh === 'L' ? "Right" : "Left");
				
				switch(cornerv){
					case 'M':
						newcss += " dijitTooltipLRMiddle";
						break;
					case 'T':
						newcss += " dijitTooltipLRTop";
						useConnector && (newparentcss = "connectorNearTopEdge");
						if(aroundNodeSize.h > 0){
							displacementProperty = "top";
							displacementValue = Math.max(4, 4 + Math.min(getContentBox(this.domNode.parentNode).h - 24, aroundNodeSize.h / 2)) + "px"; 
						}
						break;
					case 'B':
						newcss += " dijitTooltipLRBottom";
						useConnector && (newparentcss = "connectorNearBottomEdge");
						if(aroundNodeSize.h > 0){
							displacementProperty = "bottom";
							displacementValue = (4 + Math.min(getContentBox(this.domNode.parentNode).h - 24, aroundNodeSize.h / 2)) + "px"; 
						}
						break;
				}
			}else{  // 'TM' or 'BM', or '?L' against '?L' or '?R' against '?R' which both mean an above/below abuttal
				// the popup is going above or below
				newcss += " dijitTooltip" + (cornerv === 'T' ? "Below" : "Above");
				
				switch(cornerh){
					case 'M':
						newcss += " dijitTooltipABMiddle";
						break;
					case 'L':
						newcss += " dijitTooltipABLeft";
						useConnector && (newparentcss = "connectorNearLeftEdge");
						if(aroundNodeSize.w > 0){
							displacementProperty = "left";
							displacementValue = Math.max(4, 4 + Math.min(getContentBox(this.domNode.parentNode).w - 16, aroundNodeSize.w / 2)) + "px"; 
						}
						break;
					case 'R':
						newcss += " dijitTooltipABRight";
						useConnector && (newparentcss = "connectorNearRightEdge");
						if(aroundNodeSize.h > 0){
							displacementProperty = "right";
							displacementValue = (4 + Math.min(getContentBox(this.domNode.parentNode).w - 24, aroundNodeSize.w / 2)) + "px"; 
						}
						break;
				}
			}
			
			domClass.replace(this.domNode, newcss, this._currentOrientClass || "");
			this._currentOrientClass = newcss;
			
			domClass.replace(this.domNode.parentNode, newparentcss, this._currentConnectorClass || "");
			this._currentConnectorClass = newparentcss;
			
			// remove any previous displacement values that might have been applied
			this.connectorNode.style.top = "";
			this.connectorNode.style.bottom = "";
			this.connectorNode.style.left = "";
			this.connectorNode.style.right = "";
			
			if(displacementProperty){
				this.connectorNode.style[displacementProperty] = displacementValue;
			}
		},
		
		/**
		 * Configure widget to be displayed in given position relative to the
		 * trigger node. This is called from the dijit.popup code, and should
		 * not be called directly.
		 * @private
		 * @param {DOMNode} node
		 * @param {string} aroundCorner
		 * @param {string} corner
		 * @param {Object} spaceAvailable
		 * @param {Object} aroundNodeCoords
		 */
		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner, spaceAvailable, aroundNodeCoords){
			this._layoutNodes(aroundNodeCoords, aroundCorner, corner, ("_useConnectorForPopup" in this) ? this._useConnectorForPopup : this.useConnector);
		},

		/**
		 * An attach point that is called when the MenuDialog is opened. 
		 */
		onOpen: function(pos){
			this.isShowingNow = true;
			
			// set up our initial display
			this._layoutNodes(pos.aroundNodePos, pos.aroundCorner, pos.corner, ("_useConnectorForPopup" in this) ? this._useConnectorForPopup : this.useConnector);
			this.reset();
			
			// if there is a menu we are to work with, connect to it now
			var menu = this._getMenuForDialog();
			if(menu){
				// ensure that our menu has parentMenu set to our parent
				// so that focus chains connect up correctly
				if(this._menuparented){
					// this shouldn't happen, but handle it cleanly if it does
					this._menuparented.parentMenu = null;
				}
				menu.parentMenu = this.parentMenu;
				this._menuparented = menu;
				
				// ensure that "execute" events on our menu trigger "execute"
				// events on us, so that the notification passes up the menu
				// cascade chain correctly
				if(this._handleexecute){
					// this shouldn't happen, but handle it cleanly if it does
					this._handleexecute.remove();
				}
				var fireexecute = lang.hitch(this, this.onExecute);
				this._handleexecute = menu.on("execute", fireexecute);
				
				// ensure that "execute" events returning from popup/cascade
				// menus opened in turn by our menu also trigger "execute"
				// events on us. The "execute" events will otherwise terminate
				// there, because our menu will not be in the popup stack; all
				// the child menus cascading from it will be correctly folded
				// away, but we need to pass the notification upwards so that
				// the next segment of the popup stack can also be folded away.
				if(this._handleopen){
					// this shouldn't happen, but handle it cleanly if it does
					this._handleopen.remove();
				}
				this._handleopen = aspect.after(menu, "_openPopup", function(){
					// after _openPopup is called, retrieve the popup stack item just
					// added and hook into its onExecute() method, which will be called
					// when an execute is triggered on a descendant menu item
					var stackitem = popup._stack[popup._stack.length - 1];
					if(!stackitem._menuregistered){
						stackitem._menuregistered = true;
						stackitem.handlers.push(aspect.around(stackitem, "onExecute", function(originalOnExecute){
							return function(){
								// during the default onExecute handling, all the handlers
								// will be removed, so we can't use an 'after'. Instead,
								// we use 'around', call the original, then fire our own
								// 'execute' event. 
								originalOnExecute.apply(this, arguments);
								fireexecute();							
							}
						}));
					}
				}, true);
			}
			
			this._onShow(); // lazy load trigger
		},

		/**
		 * An attach point that is called when the MenuDialog is closed. 
		 */
		onClose: function(){
			this.isShowingNow = false;
			this._closeOnBlur = false;
			
			// if we connected to a menu, disconnect it now
			if(this._handleexecute){
				this._handleexecute.remove();
				this._handleexecute = null;
			}
			if(this._handleopen){
				this._handleopen.remove();
				this._handleopen= null;
			}
			
			// if we set the parent of a menu, reset it now
			if(this._menuparented){
				this._menuparented.parentMenu = null;
				this._menuparented = null;
			}
			
			this.onHide();
		},

		/**
		 * An attach point for the parent menu to listen for the MenuDialog being
		 * cancelled. Calling it will cause this MenuDialog to be closed, 
		 * but not any menus it may have cascaded from.
		 * @name idx.oneui.MenuDialog.prototype.onCancel
		 * @function
		 * @public
		 */		

		/**
		 * An attach point for the parent menu to listen for menu items being
		 * executed. Calling it will cause this MenuDialog and any menus it
		 * may have cascaded from to be closed.
		 */		
		onExecute: function(){
		}

	});
});

},
'dojox/storage/BehaviorStorageProvider':function(){
// wrapped by build app
define("dojox/storage/BehaviorStorageProvider", ["dijit","dojo","dojox","dojo/require!dojox/storage/Provider,dojox/storage/manager"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage.BehaviorStorageProvider");

dojo.require("dojox.storage.Provider");
dojo.require("dojox.storage.manager");

dojo.declare(
	"dojox.storage.BehaviorStorageProvider",
	[dojox.storage.Provider],
	{
		store: null,

		storeName: '__dojox_BehaviorStorage',

		keys: [],

		initialize: function(){
			try{
				this.store = this._createStore();
				this.store.load(this.storeName);
			}catch(e){
				throw new Error("Store is not available: " + e);
			}

			var keys = this.get('keys','dojoxSystemNS');
			this.keys = keys || [];

			this.initialized = true;
			dojox.storage.manager.loaded();

		},

		isAvailable: function(){ /*Boolean*/
			// This is not completely true. UserData may
			// be disabled in security settings. To *really*
			// check if this is available, one needs to wait
			// until the store is successfully initialized...
			return dojo.isIE && dojo.isIE >= 5;
		},

		_createStore: function() {
			var storeNode = dojo.create(
				'link',
				{id: this.storeName + 'Node', style: {'display':'none'}},
				dojo.query('head')[0]
			);
			storeNode.addBehavior('#default#userdata');

			return storeNode;
		},

		put: function(	/*string*/ key,
						/*object*/ value,
						/*function*/ resultsHandler,
						/*string?*/ namespace){

			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			var fullKey = this.getFullKey(key,namespace);
			value = dojo.toJson(value);

			this.store.setAttribute(fullKey, value);
			this.store.save(this.storeName);

			var success = this.store.getAttribute(fullKey) === value;
			if(success){
				this._addKey(fullKey);
				this.store.setAttribute('__dojoxSystemNS_keys', dojo.toJson(this.keys));
				this.store.save(this.storeName);
			}

			if(resultsHandler){
				resultsHandler(success ? this.SUCCESS : this.FAILED, key, null, namespace);
			}
		},

		get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			key = this.getFullKey(key, namespace);

			return dojo.fromJson(this.store.getAttribute(key));
		},

		getKeys: function(/*string?*/ namespace){ /*Array*/
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			var keys = [];
			for(var i = 0; i < this.keys.length; i++){
				var currentKey = this.keys[i];
				if(this._beginsWith(currentKey,namespace)){
					currentKey = currentKey.substring(namespace.length);
					keys.push(currentKey);
				}
			}

			return keys;
		},

		clear: function(/*string?*/ namespace){
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			var keys = [];
			for(var i = 0; i < this.keys.length; i++){
				var currentKey = this.keys[i];
				if(this._beginsWith(currentKey,namespace)){
					keys.push(currentKey);
				}
			}

			dojo.forEach(keys, function(key){
				this.store.removeAttribute(key);
				this._removeKey(key);
			}, this);

			this.put('keys', this.keys, null, 'dojoxSystemNS');
			this.store.save(this.storeName);
		},

		remove: function(/*string*/ key, /*string?*/ namespace){
			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			key = this.getFullKey(key, namespace);
			this.store.removeAttribute(key);

			this._removeKey(key);
			this.put('keys', this.keys, null, 'dojoxSystemNS');
			this.store.save(this.storeName);

		},

		getNamespaces: function(){ /*string[]*/


			var results = [ this.DEFAULT_NAMESPACE];

			var found = {};
			found[this.DEFAULT_NAMESPACE] = true;
			var tester = /^__([^_]*)_/;

			for(var i = 0; i < this.keys.length; i++){
				var currentKey = this.keys[i];
				if(tester.test(currentKey) == true){
					var currentNS = currentKey.match(tester)[1];
					if(typeof found[currentNS] == "undefined"){
						found[currentNS] = true;
						results.push(currentNS);
					}
				}
			}

			return results;

		},

		isPermanent: function(){ /*Boolean*/
			return true;
		},

		getMaximumSize: function(){ /* mixed */
			// this *might* be more, depending on the zone
			// of the current site. But 64k is guaranteed.
			return 64;
		},

		hasSettingsUI: function(){ /*Boolean*/
			return false;
		},

		isValidKey: function(/*string*/ keyName){ /*Boolean*/
			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z_-]*$/.test(keyName);
		},

		isValidNamespace: function(/*string*/ keyName){ /*Boolean*/

			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z-]*$/.test(keyName);
		},

		getFullKey: function(key, namespace){
			// checks for valid namespace and
			// key are already performed.
			return "__" + namespace + "_" + key;
		},

		_beginsWith: function(/* string */ haystack, /* string */ needle) {
			if(needle.length > haystack.length) {
				return false;
			}
			return haystack.substring(0,needle.length) === needle;
		},

		_assertIsValidNamespace: function(/* string */ namespace){
			if(this.isValidNamespace(namespace) === false){
				throw new Error("Invalid namespace given: " + namespace);
			}
		},

		_assertIsValidKey: function(/* string */ key){
			if(this.isValidKey(key) === false){
				throw new Error("Invalid key given: " + key);
			}
		},

		_addKey: function(key){
			this._removeKey(key);
			this.keys.push(key);
		},

		_removeKey: function(key){
			this.keys = dojo.filter(this.keys,function(item){ return item !== key;},this);
		}
	}
);

dojox.storage.manager.register("dojox.storage.BehaviorStorageProvider", new dojox.storage.BehaviorStorageProvider());
});

},
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'dijit/hccss':function(){
define("dijit/hccss", [
	"require",			// require.toUrl
	"dojo/_base/config", // config.blankGif
	"dojo/dom-class", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/dom-construct", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/dom-style", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/ready", // ready
	"dojo/_base/sniff", // has("ie") has("mozilla")
	"dojo/_base/window" // win.body
], function(require, config, domClass, domConstruct, domStyle, ready, has, win){

	// module:
	//		dijit/hccss
	// summary:
	//		Test if computer is in high contrast mode, and sets dijit_a11y flag on <body> if it is.

	if(has("ie") || has("mozilla")){	// NOTE: checking in Safari messes things up
		// priority is 90 to run ahead of parser priority of 100
		ready(90, function(){
			// summary:
			//		Detects if we are in high-contrast mode or not

			// create div for testing if high contrast mode is on or images are turned off
			var div = domConstruct.create("div",{
				id: "a11yTestNode",
				style:{
					cssText:'border: 1px solid;'
						+ 'border-color:red green;'
						+ 'position: absolute;'
						+ 'height: 5px;'
						+ 'top: -999px;'
						+ 'background-image: url("' + (config.blankGif || require.toUrl("dojo/resources/blank.gif")) + '");'
				}
			}, win.body());

			// test it
			var cs = domStyle.getComputedStyle(div);
			if(cs){
				var bkImg = cs.backgroundImage;
				var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
				if(needsA11y){
					domClass.add(win.body(), "dijit_a11y");
				}
				if(has("ie")){
					div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
				}else{
					win.body().removeChild(div);
				}
			}
		});
	}
});

},
'cwtk/util/PopupManager':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/util/PopupManager", [
    "dojo", 
    "dojo/_base/declare",
    "dijit/focus",
    "dojo/_base/connect",
    "dijit/Dialog"
], function(dojo, declare, focus, connect, localDialog){

		return declare("cwtk.util.PopupManager", null, {

			_dialog : null,
			
			_title : '',
			
			_content : '<br/>',
			
			constructor: function() {
			    connect.subscribe("cw_dismiss", dojo.hitch(this, this.onDismiss));
			},
			
			dialog : function () {
			    if (!this._dialog) {
			        this._dialog = dijit.byId('cw-dialog');
			        if (!this._dialog) {
    			        this._dialog = this.createDialog();
			        }
			    }
			    return this._dialog;
			},
			
			createDialog : function () {
			    var dialog = new localDialog({
			        id: 'cw-dialog',
			        toggle: 'fade'
                });
                dojo.connect(dialog, 'onDownloadEnd', function(){
                    dialog.layout();
                    dialog._getFocusItems(dialog.domNode);
					focus.focus(dialog._firstFocusItem);
                });
                return dialog;  
			},
			
			setArgs : function (args) {
			    if (args) {
    		        args.title = args.title || this._title;                     
                    	dojo.attr(this.dialog(), args);
			    }
			},
			
			show : function (args) {
			    this.setArgs(args);
			    this.dialog().show();  
			},
			
			showNew : function (args) {
			    if (this._dialog) {
			        this._dialog.destroy();
			        delete this._dialog;
			    }
			    this._dialog = this.createDialog();
			    this.show(args);  
			},
			
			hide : function () {
			    this.dialog().hide();
			},
			
			onDismiss : function(event) {
			    var dialogQuery = dojo.query(event.node).parents(".dijitDialog");
                if (dialogQuery.length > 0) {
                    var dialog = dijit.byId(dialogQuery[0].id);
                    dialog.hide();
                }
			}
			
		});

});
},
'dijit/popup':function(){
define("dijit/popup", [
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/connect",	// connect._keypress
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/_base/event", // event.stop
	"dojo/has",
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/_base/window", // win.body
	"./place",
	"./BackgroundIframe",
	"."	// dijit (defining dijit.popup to match API doc)
], function(array, aspect, connect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, event, has, keys, lang, on, win,
			place, BackgroundIframe, dijit){

	// module:
	//		dijit/popup
	// summary:
	//		Used to show drop downs (ex: the select list of a ComboBox)
	//		or popups (ex: right-click context menus)


	/*=====
	dijit.popup.__OpenArgs = function(){
		// popup: Widget
		//		widget to display
		// parent: Widget
		//		the button etc. that is displaying this popup
		// around: DomNode
		//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		// x: Integer
		//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		// y: Integer
		//		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		// orient: Object|String
		//		When the around parameter is specified, orient should be a list of positions to try, ex:
		//	|	[ "below", "above" ]
		//		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		//		(around-node-corner, popup-node-corner), ex:
		//	|	{ "BL": "TL", "TL": "BL" }
		//		where BL means "bottom left" and "TL" means "top left", etc.
		//
		//		dijit.popup.open() tries to position the popup according to each specified position, in order,
		//		until the popup appears fully within the viewport.
		//
		//		The default value is ["below", "above"]
		//
		//		When an (x,y) position is specified rather than an around node, orient is either
		//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		//		and the top-right corner.
		// onCancel: Function
		//		callback when user has canceled the popup by
		//			1. hitting ESC or
		//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		// onClose: Function
		//		callback whenever this popup is closed
		// onExecute: Function
		//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		// padding: dijit.__Position
		//		adding a buffer around the opening position. This is only useful when around is not set.
		this.popup = popup;
		this.parent = parent;
		this.around = around;
		this.x = x;
		this.y = y;
		this.orient = orient;
		this.onCancel = onCancel;
		this.onClose = onClose;
		this.onExecute = onExecute;
		this.padding = padding;
	}
	=====*/

	/*=====
	dijit.popup = {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).
		//
		//		Access via require(["dijit/popup"], function(popup){ ... }).

		moveOffScreen: function(widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.
			// widget: dijit._WidgetBase
			//		The widget
		},

		hide: function(widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			// 		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.
			// widget: dijit._WidgetBase
			//		The widget
		},

		open: function(args){
			// summary:
			//		Popup the widget at the specified position
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
			// args: dijit.popup.__OpenArgs
			//		Parameters
			return {};	// Object specifying which position was chosen
		},

		close: function(popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.
			// widget: dijit._WidgetBase?
			//		The widget, optional
		}
	};
	=====*/

	function destroyWrapper(){
		// summary:
		//		Function to destroy wrapper when popup widget is destroyed.
		//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
		if(this._popupWrapper){
			domConstruct.destroy(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	var PopupManager = declare(null, {
		// _stack: dijit._Widget[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div", {
					"class":"dijitPopup",
					style:{ display: "none"},
					role: "presentation"
				}, win.body());
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", destroyWrapper, true);
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, {
				visibility: "hidden",
				top: "-9999px",		// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
				display: ""
			});
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			// 		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, "display", "none");
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*dijit.popup.__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length-1].widget.domNode))){
				this.close(stack[stack.length-1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist
			var wrapper = this._createWrapper(widget);


			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});

			if(has("bgIframe") && !widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _Widget.destroy()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			// position the wrapper node and make it visible
			var best = around ?
				place.around(wrapper, around, orient, ltr, widget.orient ? lang.hitch(widget, "orient") : null) :
				place.at(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

			wrapper.style.display = "";
			wrapper.style.visibility = "visible";
			widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, connect._keypress, lang.hitch(this, function(evt){
				if(evt.charOrCode == keys.ESCAPE && args.onCancel){
					event.stop(evt);
					args.onCancel();
				}else if(evt.charOrCode === keys.TAB){
					event.stop(evt);
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						topPopup.onCancel();
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){return elem.widget == popup;})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){ h.remove(); }

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/layout/TabContainer':function(){
define("dijit/layout/TabContainer", [
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/declare", // declare
	"./_TabContainerBase",
	"./TabController",
	"./ScrollingTabController"
], function(lang, declare, _TabContainerBase, TabController, ScrollingTabController){

/*=====
	var _TabContainerBase = dijit.layout._TabContainerBase;
	var TabController = dijit.layout.TabController;
	var ScrollingTabController = dijit.layout.ScrollingTabController;
=====*/

	// module:
	//		dijit/layout/TabContainer
	// summary:
	//		A Container with tabs to select each child (only one of which is displayed at a time).


	return declare("dijit.layout.TabContainer", _TabContainerBase, {
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: String
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = lang.getObject(this.controllerWidget);

			return new TabController({
				id: this.id + "_tablist",
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							"dijit.layout.ScrollingTabController" : "dijit.layout.TabController";
			}
		}
	});
});

},
'dijit/_base':function(){
define("dijit/_base", [
	".",
	"./a11y",	// used to be in dijit/_base/manager
	"./WidgetSet",	// used to be in dijit/_base/manager
	"./_base/focus",
	"./_base/manager",
	"./_base/place",
	"./_base/popup",
	"./_base/scroll",
	"./_base/sniff",
	"./_base/typematic",
	"./_base/wai",
	"./_base/window"
], function(dijit){

	// module:
	//		dijit/_base
	// summary:
	//		Includes all the modules in dijit/_base

	return dijit._base;
});

},
'dijit/form/_FormValueWidget':function(){
define("dijit/form/_FormValueWidget", [
	"dojo/_base/declare", // declare
	"dojo/_base/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

/*=====
var _FormWidget = dijit.form._FormWidget;
var _FormValueMixin = dijit.form._FormValueMixin;
=====*/

// module:
//		dijit/form/_FormValueWidget
// summary:
//		FormValueWidget


return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin],
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.  See #8484, #8660.

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			var _this = this;
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				(function ping(){
					var disconnectHandle = _this.connect(parent, "onscroll",
						function(){
							_this.disconnect(disconnectHandle); // only call once
							pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
							setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
						}
					);
				})();
				parent = parent.parentNode;
			}
		}
	}
});

});

},
'dijit/_BidiSupport':function(){
define("dijit/_BidiSupport", ["./_WidgetBase"], function(_WidgetBase){

/*=====
	var _WidgetBase = dijit._WidgetBase;
====*/

	// module:
	//		dijit/_BidiSupport
	// summary:
	//		Module that deals with BIDI, special with the auto
	//		direction if needed without changing the GUI direction.
	//		Including this module will extend _WidgetBase with BIDI related methods.
	// description:
	//		There's a special need for displaying BIDI text in rtl direction
	//		in ltr GUI, sometimes needed auto support.
	//		In creation of widget, if it's want to activate this class,
	//		the widget should define the "textDir".

	_WidgetBase.extend({

		getTextDir: function(/*String*/ text){
			// summary:
			//		Gets the right direction of text.
			// description:
			// 		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			//	tags:
			//		protected.
			return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
		},

		_checkContextual: function(text){
			// summary:
			//		Finds the first strong (directional) character, return ltr if isLatin
			//		or rtl if isBidiChar.
			//	tags:
			//		private.

			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as defult.
			return fdc ? ( fdc[0] <= 'z' ? "ltr" : "rtl" ) : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
		},

		applyTextDir: function(/*Object*/ element, /*String*/ text){
			// summary:
			//		Set element.dir according to this.textDir
			// element:
			//		The text element to be set. Should have dir property.
			// text:
			//		Used in case this.textDir is "auto", for calculating the right transformation
			// description:
			// 		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			//	tags:
			//		protected.

			var textDir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
			// update only when there's a difference
			if(element.dir != textDir){
				element.dir = textDir;
			}
		}
	});

	return _WidgetBase;
});

},
'curam/util/UimDialog':function(){
/*
 * Copyright 2010-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.   
 * 06-Jul-2011  KW  [CR00275353] Correctly set the o3rpu value in openUrl()
 *                                function.
 * 01-Feb-2011  MV  [CR00250399] Fix the call to openModalDialog() function.
 * 21-Jan-2011  MV  [CR00243263] Fix the new openUrl function to return
 *    the dialog object. 
 * 14-Jan-2011  MK  [CR00240138] Added the openUrl() function. 
 * 13-Jan-2011  MV  [CR00241667] Added ready() function, updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the get() function.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */

define("curam/util/UimDialog", ["curam/util/RuntimeContext",
        "curam/util/external",
        "curam/util",
        "curam/define",
        "curam/dialog",
        "curam/util/DialogObject"
        ], function(RuntimeContext, external) {
  
  /**
   * @name curam.util.UimDialog
   * @namespace Provides the ability to open UIM content in a Curam dialog
   * and interact with the dialog window.<p/>
   * 
   * The API provides support for both opening a UIM page in a new dialog
   * and for accessing a dialog which is already open. See the <code>open()</code>
   * and <code>get()</code> functions.<p/>
   *  
   * It is required that the UIM page you are opening in the dialog resides
   * on the same Internet domain as the page the API is used from.<p/>
   * 
   * Example:<p/>
   * <pre>
   * dojo.require('curam.util.UimDialog');
   * 
   * var dialogObject = curam.util.UimDialog.open(
   *   'MyPage.do', { myParam:'1' }, {width:500,height:300});
   * 
   * dialogObject.registerBeforeCloseHandler(function() { alert("test"); });
   * dialogObject.registerOnDisplayHandler(function() {
   *   setTimeout(1000, function() { dialogObject.close() });
   * });
   * </pre><p/>
   *
   * It is possible to execute custom code on dialog open and/or close.<p/>
   * 
   * To add a customised handler function to a supported event:<ul>
   * <li>Make the UimDialog API call to open or get the dialog, which will
   *  return a {@link curam.util.DialogObject} object.
   * <li>This object will let you register handlers for the supported
   * <code>OnDisplay</code> and <code>BeforeClose</code> events.</li></ul>
   * <p/>
   * 
   * Lastly you can close the dialog by calling the <code>close()</code>
   * function.<p/>
   */





















  curam.define.singleton("curam.util.UimDialog",
  /**
   * @lends curam.util.UimDialog.prototype
   */
  {
    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, without
     *              the query string.
     * @param {Object} pageParameters An object containing the required page
     *      parameters, or null if no page parameters are required.
     *      The following format is expected:
     *                        <code>{ param1Name:"value", param2Name:248 }</code>
     *      The infrastructure handles URL-encoding the values so do NOT encode
     *      them yourself.
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *      
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    open: function(path, pageParameters, dialogSize) {    
      var url = path + curam.util.makeQueryString(pageParameters);    
      return this.openUrl(url, dialogSize);
    },

    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, including
     *              the query string.
     *              
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    openUrl: function(url, dialogSize) {












      // generate a unique token, this is to be used to retrieve the
      // correct dialogID
      var uimToken = curam.util.getCacheBusterParameter();

      // create dialog object to be returned to the user
      var myDialogObject = new curam.util.DialogObject(uimToken);

      var windowOptions = null;
      if (dialogSize) {
        windowOptions = "width=" + dialogSize.width
        + ",height=" + dialogSize.height;
      }

      // call into modal logic with unique token
      curam.util.openModalDialog({ href: this._addRpu(url) },
          windowOptions, null, null, uimToken);

      return myDialogObject;
    },
    
    _addRpu: function(url) {
      var newUrl = url;
      
      if (curam.tab.inTabbedUI()) {
        // we are in tabbed UI, set RPU to the active tab content iframe
        var iframe = curam.tab.getContentPanelIframe();
        if (iframe) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(iframe.contentWindow));
        }

      } else if (external.inExternalApp()) {
        // we are in the external application, try to get parent UIM iframe
        var parent = external.getUimParentWindow();
        if (parent) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(parent));
        }
      }
      // else - unable to set RPU, this is valid for example in ext app fragment
      // scenarios

      return newUrl;
    },
    
    /**
     * Returns a dialog object corresponding to the runtime context
     * of the calling page.
     * 
     * If the calling page is not loaded in a dialog or the dialog infrastructure
     * is not yet initialized then exception will be thrown. In this case use the
     * ready() function to execute your code at the right point in time. 
     * 
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    get: function() {
      if (curam.dialog._id == null) {
        throw "Dialog infrastructure not ready.";
      }
      return new curam.util.DialogObject(null, curam.dialog._id);
    },

    /**
     * Executes the callback function when the dialog infrastructure
     * in the current runtime context becomes ready. If the infrastructure
     * is ready by the time this function is called, then the callback function
     * is executed immediately.
     * 
     * @param {Function} callback
     *    The function to run.
     */
    ready: function(callback) {
      if (curam.dialog._id == null) {
        // Dialog infrastructure not ready.
        dojo.subscribe("/curam/dialog/ready", callback);

      } else {
        // infrastructure ready - call the code now
        callback();
      }
    },

    /**
     * @private
     */
    _getDialogFrameWindow: function(dialogId) {
      var dialogWidget = window.top.dijit.byId(dialogId);
      return dialogWidget.uimController.getIFrame().contentWindow;
    }
  });
  
  return curam.util.UimDialog;
});

},
'dijit/focus':function(){
define("dijit/focus", [
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/_base/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"."		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domConstruct, Evented, lang, on, ready, has, Stateful, unload, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus
	// summary:
	//		Returns a singleton that tracks the currently focused node, and which widgets are currently "active".

/*=====
	dijit.focus = {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit._Widget[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		registerIframe: function(iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the <iframe> itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
		},

		registerWin: function(targetWindow, effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow: Window?
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode: DOMNode?
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.
		}
	};
=====*/

	var FocusManager = declare([Stateful, Evented], {
		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit._Widget[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the <iframe> itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			var _this = this;
			var mousedownListener = function(evt){
				_this._justMouseDowned = true;
				setTimeout(function(){ _this._justMouseDowned = false; }, 0);

				// workaround weird IE bug where the click is on an orphaned node
				// (first time clicking a Select/DropDownButton inside a TooltipDialog)
				if(has("ie") && evt && evt.srcElement && evt.srcElement.parentNode == null){
					return;
				}

				_this._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
			};

			// Listen for blur and focus events on targetWindow's document.
			// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
			// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
			// fire.
			// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
			// (at least for FF) the focus event doesn't fire on <html> or <body>.
			var doc = has("ie") ? targetWindow.document.documentElement : targetWindow.document;
			if(doc){
				if(has("ie")){
					targetWindow.document.body.attachEvent('onmousedown', mousedownListener);
					var activateListener = function(evt){
						// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
						// ignore those events
						var tag = evt.srcElement.tagName.toLowerCase();
						if(tag == "#document" || tag == "body"){ return; }

						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						if(a11y.isTabNavigable(evt.srcElement)){
							_this._onFocusNode(effectiveNode || evt.srcElement);
						}else{
							_this._onTouchNode(effectiveNode || evt.srcElement);
						}
					};
					doc.attachEvent('onactivate', activateListener);
					var deactivateListener =  function(evt){
						_this._onBlurNode(effectiveNode || evt.srcElement);
					};
					doc.attachEvent('ondeactivate', deactivateListener);

					return {
						remove: function(){
							targetWindow.document.detachEvent('onmousedown', mousedownListener);
							doc.detachEvent('onactivate', activateListener);
							doc.detachEvent('ondeactivate', deactivateListener);
							doc = null;	// prevent memory leak (apparent circular reference via closure)
						}
					};
				}else{
					doc.body.addEventListener('mousedown', mousedownListener, true);
					doc.body.addEventListener('touchstart', mousedownListener, true);
					var focusListener = function(evt){
						_this._onFocusNode(effectiveNode || evt.target);
					};
					doc.addEventListener('focus', focusListener, true);
					var blurListener = function(evt){
						_this._onBlurNode(effectiveNode || evt.target);
					};
					doc.addEventListener('blur', blurListener, true);

					return {
						remove: function(){
							doc.body.removeEventListener('mousedown', mousedownListener, true);
							doc.body.removeEventListener('touchstart', mousedownListener, true);
							doc.removeEventListener('focus', focusListener, true);
							doc.removeEventListener('blur', blurListener, true);
							doc = null;	// prevent memory leak (apparent circular reference via closure)
						}
					};
				}
			}
		},

		_onBlurNode: function(/*DomNode*/ /*===== node =====*/){
			// summary:
			// 		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive
			this.set("prevNode", this.curNode);
			this.set("curNode", null);

			if(this._justMouseDowned){
				// the mouse down caused a new widget to be marked as active; this blur event
				// is coming late, so ignore it.
				return;
			}

			// if the blur event isn't followed by a focus event then mark all widgets as inactive.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
				this.prevNode = null;
			}), 100);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or mouse-downed
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// ignore the recent blurNode event
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack;
			this.set("activeStack", newStack);

			// compare old stack to new stack to see how many elements they have in common
			for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
				if(oldStack[nCommon] != newStack[nCommon]){
					break;
				}
			}

			var widget;
			// for all elements that have gone out of focus, set focused=false
			for(var i=oldStack.length-1; i>=nCommon; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i=nCommon; i<newStack.length; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	ready(function(){
		var handle = singleton.registerWin(win.doc.parentWindow || win.doc.defaultView);
		if(has("ie")){
			unload.addOnWindowUnload(function(){
				handle.remove();
				handle = null;
			})
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'curam/tab':function(){
/*
 * Copyright 2009-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/tab", ["curam/define",
        "curam/util",
        "curam/util/ScreenContext"
        ], function() {
  
  /*
   * Modification History
   * --------------------
   * 25-Mar-2014  MV  [CR00423311] Add function to detect internal application.  
   * 28-Sep-2013  BOS [CR00396277] Modified getSelectedTab() and 
   *                    onSectionSelected() functions to ensure an undefined. 
   *                    tab container handled correctly.
   * 28-Sep-2011  MV  [CR00288956] Refactored code to get separate
   *      getCurrentSectionId function.
   * 29-Jul-2011  MV  [CR00269970] Added missing semicolons.
   * 14-Feb-2011  PK  [CR00251730] Added "refreshMainContentPanel" method.
   * 14-Jan-2011  DG  [CR00242400] Changed "getContainerTab" to do a bottom-up
   *                    search. This is much, much simpler.
   * 12-Jan-2011  DG  [CR00238642] Fixed "getContainerTab" to find the tab for an
   *                    node even if the tab is not in the currently selected
   *                    section. Added copyright notice.
   * 17-Nov-2010  DG  [CR00217921] Clean-up of selected tab retrieval.
   * 27-Oct-2010  SK  [CR00224193] the situation where the content panel frame
   *                    is not present is now allowed.
   * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
   *                    tab-app-controller.js.
   * 21-Jul-2010  PK  [CR00211095] Added methods for handling default pages in a
   *                    section.
   * 16-Jul-2010  MV  [CR00210541] Fixed the getTabContainer() function to also
   *                    work in contexts other than the main window.
   * 28-Jun-2010  SD  [CR00204622] Smart Panel additions.
   * 02-Jul-2010  PK  [CR00203531] Updated to support section tab container.
   * 04-Jun-2010  MV  [CR00202412] Generalize the code that executes functions
   *                    on tab close.
   * 11-Feb-2010  MV  [CR00188844] Code format cleanup.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 24-Nov-2009  MV  [CR00175837] Remove debug output from getTabCOntainer.
   * 20-Nov-2009  MV  [CR00175581] Fix getSelectedTab function, remove
   *                    refreshCurrentTab function, add getTabController function.
   * 18-Nov-2009  MV  [CR00172452] Add more tab related functions.
   * 03-Sep-2009  MLB [CR00164883] Added function to refresh the current tab.
   * 06-Aug-2009  MV  [CR00164029] Initial version.
   * 24-Jun-2010 BD  [CR00204119] Updated how the content panel iframe is returned
   */
  /**
   * Contains functions of general use for the tabbed UI.
   */
  curam.define.singleton("curam.tab", {
    SECTION_TAB_CONTAINER_ID: "app-sections-container-dc",
    SMART_PANEL_IFRAME_ID: "curam_tab_SmartPanelIframe",
    toBeExecutedOnTabClose: [],
    
    /**
     * @private
     *
     * Used for testing: when this is set by the test code the value
     * will be returned from the getSelectedTab() function instead of the real
     * selected tab.
     */
    _mockSelectedTab: null,

    // Returns the currently selected tab widget.
    getSelectedTab: function(sectionID) {
      // supports testing code that uses curam.tab API
      if (curam.tab._mockSelectedTab) {
        return curam.tab._mockSelectedTab;
      }

      if (curam.tab.getTabContainer(sectionID)) {
        return curam.tab.getTabContainer(sectionID).selectedChildWidget;
      }    
    },

    getTabContainer: function(sectionID) {
      return curam.tab.getTabContainerFromSectionID(sectionID
          || curam.tab.getCurrentSectionId());
    },
    
    /**
     * Determines ID of the currently selected section.
     * By default throws an error when no current section is found.
     * 
     * @param {boolean} [suppressNotFoundError] If this option is set to true
     *          the function will not throw err when no current section
     *          is found.
     * 
     * @return ID of the currently selected section or null
     *          if "suppressNotFoundError" parameter is true.
     */
    getCurrentSectionId: function(suppressNotFoundError) {
      var sectionTabContainer = curam.util.getTopmostWindow().dijit.byId(
          curam.tab.SECTION_TAB_CONTAINER_ID);
      if (sectionTabContainer) {
        // children of the curam.tab.SECTION_TAB_CONTAINER_ID have id's that
        // start with the section ID and have a 4 character suffix. See
        // the ApplicationSectionRenderer.
        var childID = sectionTabContainer.selectedChildWidget.domNode.id;
        return childID.substring(0, childID.length - 4);

      } else {
        if (!suppressNotFoundError) {
          throw new Error(
              "curam.tab.getCurrentSectionId() - application section"
                + " tab container not found");
        }
      }

      return null;
    },
    
    /**
     * Determines whether we are running within a tabbed UI (internal
     * application) or not.
     * 
     * @return True if we are in tabbed UI, otherwise false.
     */
    inTabbedUI: function() {
      return curam.tab.getCurrentSectionId(true) != null;
    },

    getTabContainerFromSectionID: function(sectionID) {
      var tabContainer = dijit.byId(sectionID + "-stc");
      // TODO: not sure what this should do now that sections have been
      // introduced
      if (!tabContainer && window.parent && window.parent != window) {
        tabContainer =
          curam.util.getTopmostWindow().dijit.byId(sectionID + "-stc");
      }
      return tabContainer;
    },

    // Returns the unique widget ID for the specified tab.
    getTabWidgetId: function(tab) {
      return tab.id;
    },

    // Returns the unique widget ID for the currently selected tab.
    getSelectedTabWidgetId: function() {
      return curam.tab.getTabWidgetId(curam.tab.getSelectedTab());
    },

    /**
     * Gets the tab that contains the given node. The node is typically the
     * "iframe" element (or its parent element) within the tab, but it can be
     * any other descendant node of the tab widget.
     *
     * @param {Node} node The node within the tab to be identified.
     * @return The tab content pane containing the given node.
     */
    getContainerTab: function(node) {
      var widget = dijit.getEnclosingWidget(node);

      if (widget && !widget.tabDescriptor) {
        // A valid tab has a "curam.tab.TabDescriptor" object. This is probably
        // a different widget nested within the tab. Look further up the tree.
        widget = curam.tab.getContainerTab(widget.domNode.parentNode);
      }

      if (!widget || !widget.tabDescriptor) {
        throw "Containing tab widget could not be found for node: " + node;
      }
      return widget;
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getContentPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab(),
          iframe = null;
      
      if (targetTab) {
        iframe = dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              // is-cp-iframe output by "ContentPanelRenderer".
              return dojo.attr(item,"iscpiframe") == "true";
            })[0];
      }
      return iframe ? iframe : null;
    },
    
    /**
     * Refreshes the main content panel for the specified tab. If the tab is not
     * specified, the currently selected one will be used.
     * @tab The tab to reload the main content panel for. 
     */
    refreshMainContentPanel: function(tab) {
      var iframe = curam.tab.getContentPanelIframe(tab);
      iframe.contentWindow.curam.util.publishRefreshEvent();
      iframe.contentWindow.location.reload(true);
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getSmartPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab();
      var iframe =
        dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              return item.id == curam.tab.SMART_PANEL_IFRAME_ID;
            })[0];

      return iframe;
    },

    unsubscribeOnTabClose: function(unsubscribeToken, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          dojo.unsubscribe(unsubscribeToken);
          return true;
        }

        return false;
      });
    },

    executeOnTabClose: function(func, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          func();
          return true;
        }

        return false;
      });
    },

    doExecuteOnTabClose: function(tabWidgetId) {
      var remainingFuncs = new Array();
      for (var i = 0; i < curam.tab.toBeExecutedOnTabClose.length; i ++) {
        var func = curam.tab.toBeExecutedOnTabClose[i];
        if (!func(tabWidgetId)) {
          remainingFuncs.push(func);
        }
      }

      curam.tab.toBeExecutedOnTabClose = remainingFuncs;
    },

    // Returns a handler function that handles the /curam/main-content/page/loaded events,
    // but only for the specified tab.
    getHandlerForTab: function(handler, tabWidgetId) {
      return function(pageId, actualTabWidgetId) {
        if (actualTabWidgetId == tabWidgetId) {
          handler(pageId, tabWidgetId);
        } else {
          // no action - event was for a different tab
        }
      };
    },

    getTabController: function() {
      return curam.util.getTopmostWindow().curam.ui.UIController;
    },

    initTabLinks: function(tabWindow) {
      if (typeof(window.pageContainsClassicIEG) != "undefined"
          && window.pageContainsClassicIEG == true) {
        return;      
      }
      dojo.query("a").forEach(
        function(link) {
          if (link.href.indexOf('#') != 0
              && link.href.indexOf('javascript:') != 0
              && (link.href.indexOf('Page.do') > -1
                        || link.href.indexOf('Frame.do') > -1)) {
            if (link.href.indexOf('&o3ctx') < 0
              && link.href.indexOf('?o3ctx') < 0) {
              var separator = (link.href.indexOf('?') > -1) ? "&" : "?";
          link.href += separator + jsScreenContext.toRequestString();
            }
          }
       });
      elements = document.forms;
      for (var i = 0; i < elements.length; ++i) {
        elem = elements[i];
        var ctxField = dojo.byId('o3ctx');
        if (!ctxField) {
          var ctx = new curam.util.ScreenContext();
          ctx.setContextBits('ACTION');
          dojo.create("input", {"type": "hidden", "name": "o3ctx",
                                 "value": ctx.getValue()
                               }, elem);
        }
        dojo.create("input", {"type": "hidden", "name": "o3prv",
              "value": jsPageID}, elem);
      }

      if (elements.length > 0) {
        curam.util.getTopmostWindow().dojo.publish("curam.fireNextRequest", []);
      }
    },

    initContent: function(window, pageId) {
      var contentDiv = dojo.byId('content');
      dojo.removeClass(contentDiv, "hidden-panel");
      return;
    },

    /**
     * This setups a listener on the SECTION_TAB_CONTAINER_ID tab container to
     * handle when a section tab is selected. This method is invoked from
     * JavaScript output from the ApplicationsSectionsRenderer Java class.
     */
    setupSectionSelectionListener: function() {
      dojo.subscribe(curam.tab.SECTION_TAB_CONTAINER_ID + "-selectChild",
          curam.tab.onSectionSelected) ;
    },

    /**
     * Checks if a section has a default page specified and if the section is
     * currently "empty" (i.e. nothing displayed in it). If so, it loads the
     * default default in the section.
     *
     * This function responds to the standard "selectChild" event provided by the
     * Dijit TabContainer and is setup by the setupSectionSelectionListener method
     * above.
     */
    onSectionSelected: function(section) {
      // The curamDefaultPageID attribute is added by the setSectionDefaultPage
      // method below. The Dijit TabContainer selectChild event passes the
       // selected child to the listener.
      if (section.curamDefaultPageID) {
        // The section has a default page. Check if anything has been opened up
        // in this section already. If not, then we trigger a request for that
        // page.

        // The tab container containing the "object" tabs will either be a direct
        // child of the sections tab container, or it will be nested within
        // a border container.
        var objectTabContainer;
        if (section.id.substring(
              section.id.length - 4, section.id.length) == "-sbc") {
          // This means it's a border container so extract the section ID and
          // find the nested tab container.
          var sectionID = section.id.substring(0, section.id.length - 4);
          objectTabContainer = curam.tab.getTabContainer(sectionID);
        } else {
          // This means the object tab container is a direct child of the section
          // tab container, so it's passed in by the "selectChild" event of the
          // section tab container.
          objectTabContainer = section;
        }

        // If the tab container does not have any children, then load the
        // default page.
        if (objectTabContainer 
          && objectTabContainer.getChildren().length == 0) {
            curam.tab.getTabController().handleUIMPageID(
              section.curamDefaultPageID, true);
         // TODO: now that the page has been loaded, can we set a flag on the
         // section so the code *before* the getChildren().length == 0 above
         // is not executed again. Just a minor optimization.
        }
        return true;
      }
      return false;
    },

    /**
     * Sets the section's default pageID as a custom attribute on the Dijit
     * container. The container can be either a border container or a tab
     * container which has a specific naming convention which is the section ID
     * plus a suffix of "-sbc" for a border container and "-stc" for a tab
     * container. The ApplicationSectionsRenderer generates the call to this
     * function and will set the containers ID appropriately.
     */
    setSectionDefaultPage: function(sectionDijitContainerID, defaultPageID) {
      var dijitContainer = dijit.byId(sectionDijitContainerID);
      if (dijitContainer) {
        // The "curamDefaultPageID" custom attribute is used by the
        // onSectionSelected method above.
        dijitContainer.curamDefaultPageID = defaultPageID;
      } else {
        throw "curam.tab.setSectionDefaultPage() - cannot find section dijit ID:"
              + sectionDijitContainerID;
      }
    },
    
    /**
     * Notifies the Smart Panel that its content page is loaded and ready to
     * receive updates from the tab's content page. This is done by publishing
     * an event, or, if the listeners are not set up yet, an attribute set on
     * the Smart Panel frame is used.
     */
    publishSmartPanelContentReady: function() {
            var rendererLoadedEvent = "smartpanel.content.loaded";
            //use the window object as cannot assume the currently selected tab is
            //the tab containing the Smart Panel of interest.
            var smartPanel = window.frameElement; 
            smartPanel.setAttribute("_SPContentLoaded", "true");
            curam.util.getTopmostWindow().dojo.publish(rendererLoadedEvent, [smartPanel]);
    }
    
  });

  return curam.tab;
});

},
'dojo/text':function(){
define("dojo/text", ["./_base/kernel", "require", "./has", "./_base/xhr"], function(dojo, require, has, xhr){
	// module:
	//		dojo/text
	// summary:
	//		This module implements the !dojo/text plugin and the dojo.cache API.
	// description:
	//		We choose to include our own plugin to leverage functionality already contained in dojo
	//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
	//		Also, this allows foreign AMD loaders to be used without their plugins.
	//
	//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
	//		loader. This feature is outside the scope of the CommonJS plugins specification.

	var getText;
	if(1){
		getText= function(url, sync, load){
			xhr("GET", {url:url, sync:!!sync, load:load});
		};
	}else{
		// TODOC: only works for dojo AMD loader
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache= {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {},

		result= {
			dynamic:
				// the dojo/text caches it's own resources because of dojo.cache
				true,

			normalize:function(id, toAbsMid){
				// id is something like (path may be relative):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var parts= id.split("!"),
					url= parts[0];
				return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
			},

			load:function(id, require, load){
				// id is something like (path is always absolute):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var
					parts= id.split("!"),
					stripFlag= parts.length>1,
					absMid= parts[0],
					url = require.toUrl(parts[0]),
					text = notFound,
					finish = function(text){
						load(stripFlag ? strip(text) : text);
					};
				if(absMid in theCache){
					text = theCache[absMid];
				}else if(url in require.cache){
					text = require.cache[url];
				}else if(url in theCache){
					text = theCache[url];
				}
				if(text===notFound){
					if(pending[url]){
						pending[url].push(finish);
					}else{
						var pendingList = pending[url] = [finish];
						getText(url, !require.async, function(text){
							theCache[absMid]= theCache[url]= text;
							for(var i = 0; i<pendingList.length;){
								pendingList[i++](text);
							}
							delete pending[url];
						});
					}
				}else{
					finish(text);
				}
			}
		};

	dojo.cache= function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return result;

/*=====
dojo.cache = function(module, url, value){
	// summary:
	//		A getter and setter for storing the string content associated with the
	//		module and url arguments.
	// description:
	//		If module is a string that contains slashes, then it is interpretted as a fully
	//		resolved path (typically a result returned by require.toUrl), and url should not be
	//		provided. This is the preferred signature. If module is a string that does not
	//		contain slashes, then url must also be provided and module and url are used to
	//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
	//		If value is specified, the cache value for the moduleUrl will be set to
	//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	//		in its internal cache and return that cached value for the URL. To clear
	//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	//		the URL contents, only modules on the same domain of the page can use this capability.
	//		The build system can inline the cache values though, to allow for xdomain hosting.
	// module: String||Object
	//		If a String with slashes, a fully resolved path; if a String without slashes, the
	//		module name to use for the base part of the URL, similar to module argument
	//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
	//		generates a valid path for the cache item. For example, a dojo._Url object.
	// url: String
	//		The rest of the path to append to the path derived from the module argument. If
	//		module is an object, then this second argument should be the "value" argument instead.
	// value: String||Object?
	//		If a String, the value to use in the cache for the module/url combination.
	//		If an Object, it can have two properties: value and sanitize. The value property
	//		should be the value to use in the cache, and sanitize can be set to true or false,
	//		to indicate if XML declarations should be removed from the value and if the HTML
	//		inside a body tag in the value should be extracted as the real value. The value argument
	//		or the value property on the value argument are usually only used by the build system
	//		as it inlines cache content.
	//	example:
	//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
	//		of call is used to avoid an issue with the build system erroneously trying to intern
	//		this example. To get the build system to intern your dojo.cache calls, use the
	//		"dojo.cache" style of call):
	//		| //If template.html contains "<h1>Hello</h1>" that will be
	//		| //the value for the text variable.
	//		| var text = dojo["cache"]("my.module", "template.html");
	//	example:
	//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
	//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
	//		erroneously trying to intern this example. To get the build system to intern your
	//		dojo.cache calls, use the "dojo.cache" style of call):
	//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
	//		| //text variable will contain just "<h1>Hello</h1>".
	//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
	//	example:
	//		Same example as previous, but demostrates how an object can be passed in as
	//		the first argument, then the value argument can then be the second argument.
	//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
	//		| //text variable will contain just "<h1>Hello</h1>".
	//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});
	return val; //String
};
=====*/
});


},
'dojo/i18n':function(){
define("dojo/i18n", ["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json"],
	function(dojo, require, has, array, config, lang, xhr, json) {
	// module:
	//		dojo/i18n
	// summary:
	//		This module implements the !dojo/i18n plugin and the v1.6- i18n API
	// description:
	//		We choose to include our own plugin to leverage functionality already contained in dojo
	//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
	//		allows foreign AMD loaders to be used without their plugins.


	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	true || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule= dojo.i18n=
			// the dojo.i18n module
			{},

		nlsRe=
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales= function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// return a vector of module ids containing all available locales with respect to the target locale
			// For example, assuming:
			//	 * the root bundle indicates specific bundles for "fr" and "fr-ca",
			//	 * bundlePath is "myPackage/nls"
			//	 * bundleName is "myBundle"
			// Then a locale argument of "fr-ca" would return
			//	 ["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			// Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			// If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			// therefore, assume everything is available and get 404 errors that indicate a particular localization is not available
			//

			for(var result= [bundlePath + bundleName], localeParts= locale.split("-"), current= "", i= 0; i<localeParts.length; i++){
				current+= (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
				}
			}
			return result;
		},

		cache= {},

		getL10nName= dojo.getL10nName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = "dojo/i18n!" + moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current= lang.clone(root.root),
					availableLocales= getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i= 1; i<availableLocales.length; i++){
						current= lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target= bundlePathAndName + "/" + locale;
					cache[target]= current;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// id may be relative
			// preload has form *preload*<path>/nls/<module>*<flattened locales> and
			// therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			//
			// id is in one of the following formats
			//
			//	1. <path>/nls/<bundle>
			//		=> load the bundle, localized to config.locale; load all bundles localized to
			//      config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//  2. <path>/nls/<locale>/<bundle>
			//		=> load then return the bundle localized to <locale>
			//
			//  3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//		=> for config.locale and all config.extraLocale, load all bundles found
			//		   in the best-matching bundle rollup. A value of 1 is returned, which
			//         is meaningless other than to say the plugin is executing the requested
			//         preloads
			//
			// In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			// normalize. In case 3, it <path> is assumed to be absolue; this is arranged by the builder.
			//
			// To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			// value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//   <path>/nls/<bundle>/<locale>
			//
			// will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//   define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			// Given this algorithm, other machinery can provide fast load paths be preplacing
			// values in the plugin's cache, which is public. When a load is demanded the
			// cache is inspected before starting any loading. Explicitly placing values in the plugin
			// cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			// For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			// plugin what additional localized bundles are required for a particular locale. These
			// additional locales are loaded and a mix of the root and each progressively-specific
			// locale is returned. For example:
			//
			// 1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			// 2. The loader demands load(some/path/nls/someBundle)
			//
			// 3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			// 4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//    are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//    requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			// 5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//    ab-cd-ef as...
			//
			//      mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//        require("some/path/nls/ab/someBundle")),
			//          require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//    This value is inserted into the cache and published to the loader at the
			//    key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			// The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			// (further preload requests will be serviced) until all ongoing preloading has completed.
			//
			// The preload signature instructs the plugin that a special rollup module is available that contains
			// one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			// are available. Here is an example:
			//
			//   *preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			// This indicates the following rollup modules are available:
			//
			//   some/path/nls/someModule_ROOT
			//   some/path/nls/someModule_ab
			//   some/path/nls/someModule_ab-cd-ef
			//
			// Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			// For example, assume someModule contained the bundles some/bundle/path/someBundle and
			// some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as folllows:
			//
			// define({
			//   some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//   some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			// });
			//
			// E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			// require(["some/path/nls/someModule_ab"], function(rollup){
			//   for(var p in rollup){
			//     var id = p + "/ab",
			//     cache[id] = rollup[p];
			//     define(id, rollup[p]);
			//   }
			// });
			//
			// Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			// load accordingly.
			//
			// The builder will write such rollups for every layer if a non-empty localeList  profile property is
			// provided. Further, the builder will include the following cache entry in the cache associated with
			// any layer.
			//
			//   "*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			// The *now special cache module instructs the loader to apply the provided function to context-require
			// with respect to the particular layer being defined. This causes the plugin to hold all normal service
			// requests until all preloading is complete.
			//
			// Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			// where the target locale has a single segment and a layer depends on a single bundle:
			//
			// Without Preloads:
			//
			//   1. Layer loads root bundle.
			//   2. bundle is demanded; plugin loads single localized bundle.
			//
			// With Preloads:
			//
			//   1. Layer causes preloading of target bundle.
			//   2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			// In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			// are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			// the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			// of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			// algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.
			//
			if(has("dojo-preload-i18n-Api")){
				var split = id.split("*"),
					preloadDemand = split[1]=="preload";
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || waitForPreloads(id, require, load)){
					return;
				}
			}

			var match= nlsRe.exec(id),
				bundlePath= match[1] + "/",
				bundleName= match[5] || match[4],
				bundlePathAndName= bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale=  localeSpecified || dojo.locale,
				loadTarget= bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				};
			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-unit-tests")){
		var unitTests = thisModule.unitTests = [];
	}

	if(has("dojo-preload-i18n-Api") || 1){
		var normalizeLocale = thisModule.normalizeLocale= function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid){
				return (1 && 1) ?
					require.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean*/ guaranteedAmdFormat){
				//	summary:
				//		Load available flattened resource bundles associated with a particular module for dojo.locale and all dojo.config.extraLocale (if any)
				//
				//  descirption:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would lonly load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.
				//

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return true;
						}
						parts.pop();
					}
					return func("ROOT");
				}

				function preload(locale){
					locale = normalizeLocale(locale);
					forEachLocale(locale, function(loc){
						if(array.indexOf(localesGenerated, loc)>=0){
							var mid = bundlePrefix.replace(/\./g, "/")+"_"+loc;
							preloading++;
							(isXd(mid) || guaranteedAmdFormat ? require : syncRequire)([mid], function(rollup){
								for(var p in rollup){
									cache[p + "/" + loc] = rollup[p];
								}
								--preloading;
								while(!preloading && preloadWaitQueue.length){
									load.apply(null, preloadWaitQueue.shift());
								}
							});
							return true;
						}
						return false;
					});
				}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			};
	}

	if(1){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var evalBundle=
				// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
				new Function(
					"__bundle",                // the bundle to evalutate
					"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
					"__mid",                   // the mid that __bundle is intended to define

					// returns one of:
					//		1 => the bundle was an AMD bundle
					//		a legacy bundle object that is the value of __mid
					//		instance of Error => could not figure out how to evaluate bundle

					  // used to detect when __bundle calls define
					  "var define = function(){define.called = 1;},"
					+ "    require = function(){define.called = 1;};"

					+ "try{"
					+		"define.called = 0;"
					+		"eval(__bundle);"
					+		"if(define.called==1)"
								// bundle called define; therefore signal it's an AMD bundle
					+			"return 1;"

					+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
								// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
					+			"return __checkForLegacyModules;"

					+ "}catch(e){}"
					// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
					// either way, re-eval *after* surrounding with parentheses

					+ "try{"
					+ 		"return eval('('+__bundle+')');"
					+ "}catch(e){"
					+ 		"return e;"
					+ "}"
				),

			syncRequire= function(deps, callback){
				var results= [];
				array.forEach(deps, function(mid){
					var url= require.toUrl(mid + ".js");

					function load(text){
						var result = evalBundle(text, checkForLegacyModules, mid);
						if(result===1){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							require([mid], function(bundle){
								results.push(cache[url]= bundle);
							});
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle= require.syncLoadNls(mid);
						// don't need to check for legacy since syncLoadNls returns a module if the module
						// (1) was already loaded, or (2) was in the cache. In case 1, if syncRequire is called
						// from getLocalization --> load, then load will have called checkForLegacyModules() before
						// calling syncRequire; if syncRequire is called from preloadLocalizations, then we
						// don't care about checkForLegacyModules() because that will be done when a particular
						// bundle is actually demanded. In case 2, checkForLegacyModules() is never relevant
						// because cached modules are always v1.7+ built modules.
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url]= {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url]= {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			},

			checkForLegacyModules = function(target){
				// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
				for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
				if(object){
					result = object[names[i]];
					if(!result){
						// fallback for incorrect bundle build of 1.6
						result = object[names[i].replace(/-/g,"_")];
					}
					if(result){
						cache[target] = result;
					}
				}
				return result;
			};

		thisModule.getLocalization= function(moduleName, bundleName, locale){
			var result,
				l10nName= getL10nName(moduleName, bundleName, locale).substring(10);
			load(l10nName, (!isXd(l10nName) ? syncRequire : require), function(result_){ result= result_; });
			return result;
		};

		if(has("dojo-unit-tests")){
			unitTests.push(function(doh){
				doh.register("tests.i18n.unit", function(t){
					var check;

					check = evalBundle("{prop:1}");
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("({prop:1})");
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("{'prop-x':1}");
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("({'prop-x':1})");
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("define({'prop-x':1})");
					t.is(1, check);

					check = evalBundle("this is total nonsense and should throw an error");
					t.is(check instanceof Error, true);
				});
			});
		}
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache
	});
});

},
'idx/oneui/_MenuOpenOnHoverMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/_MenuOpenOnHoverMixin", ["dojo/_base/declare"],
        function(declare){
    
	// Ensure we're not relying on the old globals, ready for 2.0.
	var dojo = {}, dijit = {};

  
	/**
	 * Creates a new idx.oneui._MenuOpenOnHoverMixin
	 * @name idx.oneui._MenuOpenOnHoverMixin
	 * @class This mix-in can be mixed into menus and menu bars to make them
	 * permanently active so that their drop down and cascade menus are
	 * activated by mouse hover without the need for the menu or menu bar to
	 * be clicked on first.
	 */
	return declare("idx.oneui._MenuOpenOnHoverMixin", null,
	/** @lends idx.oneui._MenuOpenOnHoverMixin.prototype */
	{
		/**
		 * If true, this menu / menu bar will open popup menu items when they
		 * are hovered over at any time. This is in addition to the usual
		 * mouse-click and key activations, which continue to work as
		 * usual. If false, the menu / menu bar will still open popup menu
		 * items on hover when it is "active" (ie, when the user is in the
		 * process of interacting with it), but will NOT open popup menu
		 * items on hover when the menu is inactive: only mouse-click and
		 * key activations work in this case. The default value is true,
		 * enabling menus to be activated by hover.
		 * @type boolean
		 */
		openOnHover: true,

		/**
		 * Used internally to track our true activation state, because when
		 * openOnHover is on we never allow ourselves to become inactive even
		 * when we normally would.
		 * @type boolean
		 */
		_isActuallyActive: false,

		/**
		 * Standard Dojo setter for handling the 'opnOnHover' property via calls to 
		 * set().
		 * @param {Object} newvalue
		 */
		_setOpenOnHoverAttr: function(newvalue){
			this.openOnHover = newvalue;
			if(newvalue){
				this._forceActive();
			}else{
				this._restoreActive();
			}
		},
			
		/**
		 * Keep track of our 'actual' active state.
		 */
		_markActive: function(){
			this.inherited(arguments);
			this._isActuallyActive = true;
		},

		/**
		 * Keep track of our 'actual' active state, but when open-on-hover
		 * is enabled prevent us becoming inactive even when we normally would.
		 */		
		_markInactive: function(){
			if(!this.openOnHover){
				this.inherited(arguments);
			}
			this._isActuallyActive = false;
		},
		
		/**
		 * Mark the menubar as active regardless of whether it 'actually' is,
		 * but preserve our memory of our 'actual' active state.
		 */
		_forceActive: function(){
			var actual = this._isActuallyActive;
			this._markActive();
			this._isActuallyActive = actual;
		},
		
		/**
		 * Return to our 'actual' active state after a force.
		 */
		_restoreActive: function(){
			if(this._isActuallyActive){
				this._markActive();
			}else{
				this._markInactive();
			}
		}

	});
});
},
'curam/util':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 06-Jun-2014  AS [CR00428142] TEC-17091. Skiplink should become visible when focused
 * 03-Jun-2014 BOS [CR00434187] Added the getCookie() function and updated 
 *                    replaceSubmitButton() to support timeout warning dialog.
 * 15-Apr-2014  JY [CR00425261] Refactored the print function to allow printing
 *                              the context panel.
 * 20-Feb-2014  AS [CR00414442] Skipped arrow and validation div of filtering 
 *                              select in doSetFocus and added a new method to 
 *                              focus the help icon on tab navigation after end 
 *                              of modal dialog. 
 * 28-Sep-2013  BOS [CR00396277] Added tests for undefined selected tab.
 * 07-Jun-2013 NLH  [CR00385557] Added highContrastModeType() funtion.
 * 11-Mar-2013  SB  [CR00372052] Added iframeTitleFallBack() function.
 * 21-Feb-2013  SB  [CR00369658] Updated setupGenericKeyHandler() to
					handle year field in Date Selector correctly.
 * 20-Feb-2013  MV  [CR00367727] Prevent opening multiple dialogs at once
 *      by clicking on link in quick succession.
 * 14-Dec-2012  SB  [CR00352283] Added removeRoleRegion() function to remove
 * 					aria role from multiselect.
 * 14-Dec-2012  JY  [CR00360602] Remove the hardcoded height for the actions 
 *                               panel.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 08-Nov-2012  SB  [CR00350381] Added focus setting code for error and
 *                  informational messages.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 03-Oct-2012  SB  [CR00344085] Updated openGenericErrorModalDialog() function
 *      to include boolean check for error or warning modal.
 * 01-Oct-2012  MV  [CR00345339] Improve a way to determine topmost window.
 * 24-Sep-2012  MV  [CR00345119] Handle mailto: links properly across browsers.
 * 17-Sep-2012  MK  [CR00344397] Updated incorrect calls to method called 
 *              hasClass to reference correct method called contains instead.
 * 17-Sep-2012  SB  [CR00341890] Added title attribute for page level action
 * 				    menu of the type submit.
 * 11-Sep-2012  MV  [CR00339639] Use local storage API from topmost window to
 *      avoid loading storage for every page. Move a function to this module. 
 * 06-Sep-2012  AF  [CR00330559] Added skip link focus method.
 * 31-Aug-2012  MK  [CR00339638] Reverted connect and disconnect functions back
 *              to previous versions. Added in searchButtonStatus that was 
 *              missed in the merge from TI_60.
 * 23-Aug-2012  BOS [CR00338361] Added the openGenericErrorModalDialog fucntion. 
 * 23-Jul-2012  MV  [CR00336202] Handle gracefully when no tab is open on dialog
 *              submit. Migrate to take on Dojo 1.7.3
 * 26-Jun-2012  SB  [CR00332545] Added searchButtonStatus() function.
 * 28-May-2012  MV  [CR00326704] Fix click event handling for row action menus.
 * 30-Apr-2012  MK  [CR00319243] Updated condition in isSameUrl function to
 *      check if the base string is the same. 
 * 24-Apr-2012  AF  [CR00317721] Updated online help URL in openHelpPage method. 
 * 14-Mar-2012  SB  [CR00312247] Added openAbout() function
 * 07-Feb-2012  MV  [CR00301458] Code cleanup - added comments,
 *      removed unused code.
 * 13-Dec-2011  BOS [CR00299497] Updating the getTopmostWindow() function
 *                    to check that the Screen Context is defined.
 * 02-Dec-2011  BOS [CR00298234] Updating the getTopmostWindow() function
 *                 in order to support portlets.
 * 05-Oct-2011  PK  [CR00289859] Dojo 1.6.1 upgrade and IE9+ support. 
 * 06-Sep-2011  MV  [CR00286500] Don't fail when Preferences anchor not found. 
 * 05-Aug-2011  MV  [CR00283589] Remove incorrect code from connect().
 * 02-Aug-2011  MV  [CR00283023] Some refactoring to allow unit testing.
 * 01-Aug-2011  MV  [CR00283020] Refactored redirectWindow() to allow unit
 *      testing.
 * 29-Jul-2011  MV  [CR00269970] Define curam.util using dojo.mixin to avoid
 *      overwriting other class definitions in the same package. Add support
 *      for new UI refresh handling implementation.
 * 28-Jul-2011  MV  [] Handle the FORCE_REFRESH case fully
 *      in redirectWindow()
 * 05-Jul-2011  KW  [CR00275353] Added setRpu() function and refactored
 *                                openLocaleSelector().
 * 18-Jul-2011  KW  [CR00277581] Connect() now strips '#' from end of event URL
 * 13-Jun-2011  MV  [CR00269902] Avoid 404 error coming from bad RPU.
 * 25-May-2011  MV  [CR00267843] Add function for setting up the Preferences
 *    link.
 * 29-Apr-2011  SC  [CR00264826] Modified page load event to include context.
 * 27-Apr-2011  MV [CR00265188] Added support for opening pages in new tab from
 *    dialog opened in the INLINE_PAGE context.
 * 11-Apr-2011  AF [CR00262956] Modified setupGenericKeyHandler method to
 *                              support device independence.  
 * 01-Apr-2011  KW [CR00262936] Altered 'alterScrollableListBottomBorder' to
 *                              run after page has loaded
 * 25-Mar-2011  SK [TEC-6335] Removed jsModals indicator as modals are always
 *     on for v6 
 * 25-Feb-2011  MV [CR00254937] Honour the RPU set by LinkTag when redirecting
 *     content panel.
 * 25-Feb-2011  MV [CR00254380] Prepare for fix: Honour the RPU set by LinkTag
 *    when redirecting content panel.
 * 18-Feb-2011  MV [CR00247527] Do not block submit when text field has focus.
 * 16-Feb-2011  MV [CR00252701] Fix the isSameUrl() function to work for action
 *    pages that take no parameters.
 * 07-Feb-2011  SJ [CR00247527]  Fixed dropdown submit issue.
 * 07-Jan-2011  MV  [CR00251284] Add support for button load mask.
 * 31-Jan-2011  MK [CR00250297]  Update the clickButton function to handle both
 *    an object and an id as an argument.
 * 28-Jan-2011  MV [CR00245381]  Remove obsolete help settings for dialogs.
 * 26-Jan-2011  MV  [CR00244801] Added another type of refresh behaviour. Strip
 *    o3rpu from RPU value.
 * 25-Jan-2011  MV  [CR00244623] Refactored the function for firing onsubmit
 *    events to work with the latest tab infrastructure changes.
 * 25-Jan-2011  PK  [CR00244773] Filtered all CDEJ parameters from comparison
 *                    in isSameURL. Previously only __o3rpu was filtered.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 21-Jan-2011  MV  [CR00243263] Add 1px to page height when in list row.
 *    Implement "force refresh" behaviour.
 * 20-Jan-2010  AF  [CR00243728] Added page toolbar button mouse effects.
 * 20-Jan-2010  MK  [CR00243648] Update getPageHeight function to take into
 *                    account the wizard progress bar.
 * 18-Jan-2010  AF  [CR00243204] Modified replaceSubmitButton function for the
 *                               agenda player.
 * 17-Jan-2010 MV [CR00242255] Remove the use of dijit.focus()
 * 16-Jan-2010  PK  [CR00242698] Changed file down load method for list row
 *                    menus so errors will be correctly reported.
 * 14-Jan-2011  MK  [CR00240138] Updated showModalDialog function to remove
 *                    contexts that were not needed in a modal.
 * 06-Jan-2011 KW [CR00240549] Added function to prevent overlapping of Action
 *                             set buttons of modals
 * 04-Jan-2011 MV [CR00240081] Fixes to the getPageHeight() function.
 * 15-Dec-2010 KW [CR00238785] Stopped the refresh event when submit button
 *                             clicked
 * 10-Dec-2010  AF  [CR00233054] Added button mouse event functions that will
 *                               add specific CSS class names when modal and
 *                               cluster buttons are clicked or rolled over.
 * 07-Dec-2010  MV  [CR00233442] Adjustments to the getPageHeight() function
 *    to bring the expandable list detail row more in line with
 *    the specification.
 * 08-Dec-2010  SJ  [CR00229344] Added the print functionality.
 * 03-Dec-2010  MV  [CR00232963] Optimize swapState() function.
 * 30-Nov-2010  MV  [CR00232623] Remove extra height when in-page navigation
 *    is present.
 * 24-Nov-2010  PK  [TEC-XXXX] Added NESTED_UIM context.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 18-Nov-2010  SJ [CR00228391]Fixed the issue with OPEN_NEW attribute on
 *                   List Row Actions Menu links.
 * 01-Nov-2010  SD  [CR00225331] An extra parameter has been added to both
 *                     openModalDialog and showModalDialog functions for
 *                     UIMDialog API.
 * 27-Oct-2010  SK   [CR00224193] Changed the redirection of the window so that
       the absence of the content panel not caused failure.
 * 14-Oct-2010  MV [CR00223441] Move functions to different namespaces.
 *    Add getSuffixFromClass function.
 * 29-Sep-2010  MV  [CR00221605] Enable submitting by pressing Enter. Check
 *    for existence of dijit before accesing it.
 * 18-Sep-2010  PK  [CR00204622] Ensure when a page loads for the first time
 *                    in an expandable list, only the "expandedList.toggle"
 *                    event is processed.
 * 17-Sep-2010  MV  [CR00220607] Set page focus only when the whole page
 *                    is loaded. Use dijit.focus() instead of plain element
 *                    focus().
 * 14-Sep-2010  MV  [CR00220152] Add the getLastPathSegmentWithQueryString
 *                    function and also use it where appropriate in this file.
 * 10-Sep-2010  MV  [CR00219824] The focus setting function now indicates
 *                    the result via its return value.
 * 14-Sep-2010  PK  [CR00219843] Fixed expandable list sizing.
 * 08-Sep-2010  MV  [CR00219540] Add support for loading pages in the same
 *                    dialog from the list actions menu.
 * 27-Aug-2010  MV  [CR00217499] Added the makeQueryString() function. Replaced
 *                  the use of escape() with the correct function.
 * 05-Jul-2010 BD [CR00204119]  Introduced use of UIMController in place of
 *                              iframe for expandable lists to cater for
 *                              In Page Navigation tabs.
 * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
 *                    tab-app-controller.js.
 * 27-Jul-2010  MK  [CR00211743] Optional display the help icon on a modal
 *                    dialog.
 * 22-Jul-2010  MV  [CR00211225] Fix page height calculation for inline row
 *                    pages.
 * 22-Jul-2010  JY  [CR00210937] add 10px spacing at the top of the actions
 *                    panel.
 * 20-Jul-2010  MV  [CR00211031] doSetFocus(): handle pages with no HTML form.
 * 15-Jul-2010  MV  [CR00210541] Moved focus handling for modals to
 *                    ModalDialog.js
 * 12-Jul-2010  MV  [CR00210064] Added swapState() function.
 * 10-Jul-2010  OK  [CR00209714] Added setupRemovePageMask function.
 * 06-Jul-2010  MV  [CR00180694] Added toCommaSeparatedList() function.
 * 05-Jul-2010  SOS [CR00209386] Added try/catch to getPageHeight() for when
 *                    it's called in a hidden iframe.
 * 02-Jul-2010  PK  [CR00203531] Extra null check added to listRowFrameLoaded
 *                    method.
 * 26-Jun-2010  MV  [CR00204069] Added getPageHeight() function. Used Curam
 *                    debug logger throughout the file.
 * 18-Jun-2010  MV  [CR00203864] Remove the code for automatically resizing the
 *                    details panel.
 * 17-Jun-2010  MV  [CR00202490] Create the iframe for expandable lists on
 *                    demand only.
 * 15-Jun-2010  FG  [CR00202535] Added in some further functions required by the
 *                    application search functionality.
 * 01-Jun-2010  FG  [CR00200968] Added in some functions required by the
 *                    application search functionality.
 * 11-May-2010  SJ  [CR00198617] Implemented caching on expandable list row
 *                    level actions. As a fix CACHE_BUSTER,
 *                    CACHE_BUSTER_PARAM_NAME parameters are added and the same
 *                    are appended to the iframe source.
 * 11-May-2010  MV  [CR00196066] Added stripeTable() function.
 * 22-Apr-2010  AF  [CR00194043] Added 3 pixels to autoSizeDetailsPane's frame
 *                    height which removes an unwanted vertical scroll bar from
 *                    appearing on the details panel.
 * 23-Apr-2010  MV  [CR00194352] Avoid adding extra ampersand in
 *                    addUrlParameter() if there are no more parameters to add.
 * 07-Apr-2010  BD  [CR00191597] Renamed resizeDetailsPanel() function to
 *                    autoSizeDetailsPanel() to better reflect its function.
 *                    Refactored to handle new html structure.
 * 18-Mar-2010  PK  [CR00191211] Added toggleListDetailsRow.
 * 24-Feb-2010  MV  [CR00189738] Re-enable focus on the first editable field in
 *                    modals.
 * 23-Feb-2010  AF  [CR00189289] Added iframe title as a parameter in the iframe
 *                    upload publish event.
 * 16-Feb-2010  BD  [CR00183006] Add try/catch block to addContentWidthListener
 *                    function. Swallows an exception that does not effect the
 *                    application.
 * 08-Jan-2010  MV  [CR00182272] Added a localizable error message for the
 *                    language selector.
 * 11-Dec-2009  MV  [CR00173949] Remove the SrPopUp target from the modal
 *                    handler form.
 * 25-Nov-2009  MV  [CR00175955] Set focus to the first control when the
 *                    curam.modalDisplayed event happens.
 * 24-Nov-2009  MV  [CR00175837] Add new fireTabOpenedEvent function and a
 *                    missing require for curam.tab.
 * 20-Nov-2009  MV  [CR00175615] Fix the firePageSubmittedEvent function.
 * 20-Nov-2009  MV  [CR00175581] Fix the curam.tab.redirectContentPanel call.
 */
  
define("curam/util", ["dojo/dom", "dijit/registry",
        "dojo/dom-construct",
        "dojo/ready",
        "dojo/_base/window",
        "dojo/dom-style",
        "dojo/_base/array",
        "dojo/dom-class",
        "dojo/topic",
        "dojo/_base/event",
        "dojo/query",
        "dojo/has",
        "dojo/_base/unload",
        "dojo/dom-geometry",
        "dojo/_base/json",
        "dojo/dom-attr",
        "dojo/_base/lang",
        "dojo/on",
		"dijit/_BidiSupport",		
        
        "curam/define",
        /* "dojox/storage", */
        "curam/debug",
        "curam/util/RuntimeContext",
        "curam/util/Constants",
        "dojo/_base/sniff",
        "cm/_base/_dom",
        "curam/util/ResourceBundle"
        
        ], function(dom, registry, domConstruct, ready, windowBase, style,
            array, domClass, topic, dojoEvent, query, has, unload,
            geom, json, attr, lang, on, bidi) {

/**
 * Creating Resource Bundle Object to access localized resources.
 */
dojo.requireLocalization("curam.application", "Debug");
var bundle = new curam.util.ResourceBundle("Debug");
  
/**
 * @name      curam.util
 * @namespace Functions for generic utiltities across CDEJ.
 */
curam.define.singleton("curam.util",
/**
 * @lends curam.util.prototype
 */
{
  PREVENT_CACHE_FLAG: "o3pc",
  INFORMATIONAL_MSGS_STORAGE_ID: "__informationals__",
  ERROR_MESSAGES_CONTAINER: "error-messages-container",
  ERROR_MESSAGES_LIST: "error-messages",
  CACHE_BUSTER: 0,
  CACHE_BUSTER_PARAM_NAME: "o3nocache",
  msgLocaleSelectorActionPage: "$not-locaized$ Usage of the Language Selector is not permitted from an editable page that has previously been submitted.",

  insertCssText: function(cssString, styleNodeId) {
    var id = styleNodeId ? styleNodeId : "_runtime_stylesheet_";
      var styleSheetNode = dom.byId(id);
    var rmNode;

    if(styleSheetNode) {
      if(styleSheetNode.styleSheet) {
        cssString = styleSheetNode.styleSheet.cssText + cssString;
        rmNode = styleSheetNode;
        rmNode.setAttribute("id", "_nodeToRm");
      } else {
        styleSheetNode.appendChild(document.createTextNode(cssString));
        return;
      }
    }

    var pa = document.getElementsByTagName('head')[0];
      styleSheetNode = domConstruct.create("style", {
      type: "text/css",
      id: id
    });

    if(styleSheetNode.styleSheet) {
      styleSheetNode.styleSheet.cssText = cssString;
    }
    else{
      styleSheetNode.appendChild(document.createTextNode(cssString));
    }
    pa.appendChild(styleSheetNode);
    if(rmNode) {
      rmNode.parentNode.removeChild(rmNode);
    }
  },

  fireRefreshTreeEvent: function() {
      if (dojo.global.parent && dojo.global.parent.amIFrame) {
        var wpl = dojo.global.parent.loader;
    }
    if(wpl && wpl.dojo) {
      wpl.dojo.publish("refreshTree");
    }
  },

  /**
   * Invoked when a form is submitted on a page in any context.
   *
   * This event tracks submitting of pages anywhere in the application
   * to enable proper UI refresh handling.
   * 
   * @param {String} context Specifies the context in which the submit
   *     happenned. The expected values are [main-content|dialog].
   */
  firePageSubmittedEvent: function(context) {
    require(["curam/tab"], function() {
      /*
       * This function is executed at onsubmit event and the call to
       * curam.tab.getContainerTab() below was failing in this scenario.
       * Using curam.tab.getSelectedTab() instead works fine.
       * Note that before refactoring to remove the use of getSelectedTab()
       * further changes will have to be made to make it work.
       */
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        var tabWidgetId = curam.tab.getTabWidgetId(sourceTab);
  
        var topWin = curam.util.getTopmostWindow();
        var ctx = (context == "dialog")
            ? curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_DIALOG
            : curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN;
        topWin.curam.util.Refresh.getController(tabWidgetId).pageSubmitted(
                dojo.global.jsPageID, ctx);
        topWin.dojo.publish("/curam/main-content/page/submitted",
                [dojo.global.jsPageID, tabWidgetId]);

      } else {
        curam.debug.log("/curam/main-content/page/submitted: " // don't localize
            + bundle.getProperty("curam.util.no.open")); // FIXME: localize
      }
    });
  },

  fireTabOpenedEvent: function(tabWidgetId) {
    // Publish the tab opened event
    curam.util.getTopmostWindow().dojo.publish("curam.tabOpened",
          [dojo.global.jsPageID, tabWidgetId]);
  },

  /**
   * Setup the submit event publisher for the main content panel.
   */
  setupSubmitEventPublisher: function() {
      ready(function() {
        var form = dom.byId('mainForm');
      if (form) {
        curam.util.connect(form, 'onsubmit', function() {
          curam.util.firePageSubmittedEvent("main-content");
        });
      }
    });
  },

  getScrollbar: function(){
    //  summary
    //  returns the width of a scrollbar.

    //  set up the test nodes.
      var scroll = domConstruct.create("div", {}, windowBase.body());

      style.set(scroll, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-300px",
      left: "0px"
    });

      var test = domConstruct.create("div", {}, scroll);

      style.set(test, {
      width: "400px",
      height: "400px"
    });

    var width = scroll.offsetWidth - scroll.clientWidth;
      domConstruct.destroy(scroll);

    //  we return an object because we may add additional info in the future.
    return { width: width };  //  object
  },

  // Returns true if the page is in a modal dialog, false otherwise.
  isModalWindow: function() {
    // the window.curamModal flag is set in curam.dialog.initModal()
      return (dojo.global.curamModal === undefined) ? false : true;
  },

  /**
   * Gets the top most window. If the screen context is set and contains the 
   * portlet context then the inner most window is returned, otherwise the 
   * topmost window window is returned starting with the current window object.
   */
  getTopmostWindow: function() {
    // check topmost window cache and cache it if it is not yet cached 
    if (typeof (dojo.global._curamTopmostWindow) == "undefined") {
      var parentWin = dojo.global;
      // if the screen context contains portlet context then
      // return parent window
      if (typeof(dojo.global.jsScreenContext) != "undefined" 
            && dojo.global.jsScreenContext.hasContextBits('CONTEXT_PORTLET')) {
          dojo.global._curamTopmostWindow = parentWin;
      } else if (parentWin.__extAppTopWin) {
        dojo.global._curamTopmostWindow = parentWin;
      } else {
        while (parentWin.parent != parentWin) {
          parentWin = parentWin.parent;
          if (parentWin.__extAppTopWin) {
            // found the top window of a public facing app
            break;
          }
        }
        dojo.global._curamTopmostWindow = parentWin;
      }
    }
    
    // report cases of incorrect topmost window
    if (dojo.global._curamTopmostWindow.location.href.indexOf(
        "AppController.do") < 0
        && typeof(dojo.global._curamTopmostWindow.__extAppTopWin) 
           == "undefined") {
      curam.debug.log(bundle.getProperty("curam.util.wrong.window")
          + dojo.global._curamTopmostWindow.location.href);
    }

    return dojo.global._curamTopmostWindow;
  },

  getUrlParamValue: function(url, paramName) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return null;}
    var paramStr = url.substring(qPos + 1, url.length);

    function getVal(delim) {
      var params = paramStr.split(delim);

      paramName += "=";
      for(var i = 0; i < params.length; i++) {
        if(params[i].indexOf(paramName) == 0){
          return params[i].split("=")[1];
        }
      }
    }

    return getVal("&") || getVal("");
  },

  addUrlParam: function(href, paramName, paramValue, prepend) {
    var hasQ = href.indexOf("?") > -1;
    var doPrepend = prepend ? prepend : 'undefined';

    if (!hasQ || (doPrepend == false)) {
      return href + (hasQ ? "&" : "?") + paramName + "=" + paramValue;

    } else {
      var parts = href.split("?");
      href = parts[0] + "?" + paramName + "=" + paramValue + (parts[1] != "" ? ("&" + parts[1]) : "");
      return href;
    }
  },

  replaceUrlParam: function(href, paramName, newValue) {
    href = curam.util.removeUrlParam(href, paramName);
    return curam.util.addUrlParam(href, paramName, newValue);
  },

  removeUrlParam: function(url, paramName, /*optional*/paramValue) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return url;}
    if(url.indexOf(paramName + "=") < 0){return url;}//shortcut

    var paramStr = url.substring(qPos + 1, url.length);
    var params = paramStr.split("&");
    var value;
    var paramParts, doRemove;

    for(var i = 0; i < params.length; i++) {
      if (params[i].indexOf(paramName+"=") == 0) {
        doRemove = false;
        if(paramValue) {
          paramParts = params[i].split("=");
          if (paramParts.length > 1) {
            if (paramParts[1] == paramValue){
              doRemove = true;
            }

          } else if ( paramValue == "") {
            doRemove = true;
          }

        } else {
          doRemove = true;
        }

        if(doRemove) {
          //remove the parameter from the array
          params.splice(i, 1);
          //in case the param is in the url more than once, keep checking
          i--;
        }
      }
    }
    return url.substring(0, qPos + 1) + params.join("&");
  },

  //Remove the hash symbol, and everything that follows it, from a url.
  stripHash: function(url) {
    var idx = url.indexOf("#");
    if(idx < 0){return url;}
    return url.substring(0, url);
  },

  /**
   * Compares the specified URLs.
   * 
   * This ignores the order of parameters - identical parameters in different
   * orders will still return true.
   * 
   * If the second href is omitted, it defaults to the location
   * of the specified runtime context.
   * 
   * @param href1 First HREF.
   * @param href2 Second HREF.
   * @param rtc current runtime context.
   * 
   * @return True if the two urls are the same, false otherwise.
   */
  isSameUrl: function(href1, href2, rtc) {
    if (!href2) {
      href2 = rtc.getHref();
    }
    if (href1.indexOf("#") == 0) {
      return true;
    }

    // Remove the # symbols from the comparison.
    var hashIdx = href1.indexOf('#');
    if (hashIdx > -1) {
      //If the first URL starts with a #, then it is automatically equal to the
      //second URL
      if (hashIdx == 0) {
        return true;
      }

      var urlParts1 = href1.split("#");
      var hashIdx2 = href2.indexOf("#");

      //If the second URL has a hash symbol, remove it and everything after it,
      //then do the comparison
      if (hashIdx2 > -1) {
        if (hashIdx2 == 0) {
          return true;
        }
        href2 = href2.split("#")[0];
      }
      return urlParts1[0] == href2;
    }

    var stripPageOrActionFromUrl = function(url) {
      var idx = url.lastIndexOf("Page.do");
      var len = 7;
      if (idx < 0) {
        idx = url.lastIndexOf("Action.do");
        len = 9;
      }
      if (idx < 0) {
        idx = url.lastIndexOf("Frame.do");
        len = 8;
      }
      if (idx > -1 && idx == url.length - len) {
        return url.substring(0, idx);
      }
      return url;
    };

    var rp = curam.util.removeUrlParam;

    var here = curam.util.stripHash(rp(href2,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var there = curam.util.stripHash(rp(href1,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var partsThere = there.split("?");
    var partsHere = here.split("?");

    //Remove the Action.do or Page.do from the url
    partsHere[0] = stripPageOrActionFromUrl(partsHere[0]);
    partsThere[0] = stripPageOrActionFromUrl(partsThere[0]);

      // This check to see if the page names are the same assumes that the
      // functions above to strip parameters and page or actions from the url
      // have been run first. So the end of each string is only the name of
      // the page.
    var baseEqual = (partsHere[0] == partsThere[0]
          || partsHere[0].match(partsThere[0]+"$")==partsThere[0]);
      
    if (!baseEqual) {
      return false;
    }

    if (partsHere.length == 1 && partsThere.length == 1 && baseEqual) {
      //If the base URL is equal, and the parameter string is exactly equal,
      //then don't bother checking the unordered parameters. Just return true,
      //because they're equal
      return true;

    } else {
      //Check the values of all of the parameters, ignoring order of url
      //parameters
      var paramsHere;
      var paramsThere;
      if (typeof partsHere[1] != "undefined" && partsHere[1] != "") {
        paramsHere = partsHere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsHere = new Array();
      }

      if (typeof partsThere[1] != "undefined" && partsThere[1] != "") {
        paramsThere = partsThere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsThere = new Array();
      }

      // don't include CDEJ parameters in the comparison
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere " 
          + bundle.getProperty("curam.util.before")
          + paramsHere.length);
        paramsHere = array.filter(paramsHere, curam.util.isNotCDEJParam);
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + bundle.getProperty("curam.util.after")
          + paramsHere.length);

      curam.debug.log(
          "curam.util.isSameUrl: paramsHere " 
          + bundle.getProperty("curam.util.before")
          + paramsThere.length);
        paramsThere = array.filter(paramsThere, curam.util.isNotCDEJParam);
        curam.debug.log(
            "curam.util.isSameUrl: paramsHere "
            + bundle.getProperty("curam.util.after")
          + paramsThere.length);

      if (paramsHere.length != paramsThere.length) {
        return false;
      }

      var paramMap = {};
      var param;
      for (var i = 0; i < paramsHere.length; i++) {
        param = paramsHere[i].split("=");
        paramMap[param[0]] = param[1];
      }
      for (var i = 0; i < paramsThere.length; i++) {
        param = paramsThere[i].split("=");
        if (paramMap[param[0]] != param[1]) {
          curam.debug.log(bundle.getProperty("curam.util.no.match",
              [param[0], param[1], paramMap[param[0]]]));
          return false;
        }
      }
    }

    //If the base url is the same, and all the parameters match, then
    //the urls are equal
    return true;
  },

  /**
   * Tests if the specified parameter name isn't a CDEJ parameter. It is used by
     * the array.filter used in the isSameUrl method.
   *
   * TODO: There is a similar method in PageRequest.js. Attempted to re-factor
   * but led to JavaScript errors in PageRequest.js when it was executed. Need
   * more time to work out dependency problem, for now duplicating the method.
   *
   * @return true if the specified parameter name is a CDEJ parameter, false
   *         otherwise.
   */
  isNotCDEJParam: function(paramName) {
    return !((paramName.charAt(0) == 'o' && paramName.charAt(1) == '3')
           || (paramName.charAt(0) == '_' && paramName.charAt(1) == '_'
               && paramName.charAt(2) == 'o' && paramName.charAt(3) == '3'));
  },

  //Sets one or more attributes on a DOM node. The map looks like:
  //{ type:'text', value:'This is text', style:'width:100px'}
  setAttributes: function(node, map) {
    for(var x in map) {
      node.setAttribute(x, map[x]);
    }
  },

  //This should be called if a pop up page has submitted a form, stating that
  //if this page is redirected to itself, rather than ignoring it, it should
  //refresh the browser.
  invalidatePage: function() {
    curam.PAGE_INVALIDATED = true;

      var parentWin = dojo.global.dialogArguments
          ? dojo.global.dialogArguments[0]:opener;

    if(parentWin && parentWin != dojo.global) {
      try {
        parentWin.curam.util.invalidatePage();

      } catch(e) {
        curam.debug.log(bundle.getProperty("curam.util.error"), e);
      }
    }
  },
  
  /**
   * Sends the window to a new URL. This needs to be done differently depending
   * on whether or not the window is modal (IE only).
   * @param force
   *    If set to true, it does not matter if the href is the same as
   *    the current href or not, it will be refreshed.
   * @param ignoreFrame
   *    If true, then any other frames on the page are not refreshed.
   */
  redirectWindow: function(href, force, ignoreFrames) {
    var rtc = new curam.util.RuntimeContext(dojo.global);
    var redirectContentPanelInDifferentFrameRootContext =
      function(context, rootObject, href, forceLoad, justRefresh) {
        curam.util.getFrameRoot(context, rootObject)
            .curam.util.redirectContentPanel(href, forceLoad, justRefresh);
      };
      curam.util._doRedirectWindow(href, force, ignoreFrames,
          dojo.global.jsScreenContext, rtc, curam.util.publishRefreshEvent,
        redirectContentPanelInDifferentFrameRootContext);
  },
  
  _doRedirectWindow: function(href, force, ignoreFrames, screenContext, rtc,
      publishRefreshEvent, redirectContentPanelInDifferentFrameRootContext) {
    if (href && curam.util.isActionPage(href)) {
      // Avoid 404 error coming from bad RPU. This is temporary,
      // will be properly fixed by TEC-7123.
      curam.debug.log(bundle.getProperty("curam.util.stopping"), href);
      return;
    }

    var rpl = curam.util.replaceUrlParam;
    //check if we are in the frameset context
    var inFrame = screenContext.hasContextBits('TREE')
                 || screenContext.hasContextBits('AGENDA')
                   || screenContext.hasContextBits('ORG_TREE');

    if(curam.util.FORCE_REFRESH) {
      //If the FORCE_REFRESH parameter is set, in dialog.js, then ignore the
      //href parameter and just reload the page. This is done for the user
      //preferences dialog, so that it doesn't lose the __o3rpu parameter,
      //but can be used in other places too.
      href = rpl(rtc.getHref(), curam.util.PREVENT_CACHE_FLAG,
                 (new Date()).getTime());
      if(curam.util.isModalWindow() || inFrame) {
        publishRefreshEvent();
          dojo.global.location.href = href;

      } else {
        if (screenContext.hasContextBits('LIST_ROW_INLINE_PAGE')
            || screenContext.hasContextBits('NESTED_UIM')) {
          
          curam.util._handleInlinePageRefresh(href);

        } else {
          publishRefreshEvent();
          if (dojo.global.location !== curam.util.getTopmostWindow().location) {
            require(["curam/tab"], function() {
              redirectContentPanelInDifferentFrameRootContext(dojo.global,
                  curam.tab.getTabController().ROOT_OBJ, href, true, true);
            });
          }
        }
      }
      return;
    }

    var u = curam.util;
    //if the URL is identical, it's not a real redirect, so do nothing.
    //This solves the case of a Cancel button being clicked in a modal window.
    var rtc = new curam.util.RuntimeContext(dojo.global);
    if(!inFrame && !force && !curam.PAGE_INVALIDATED
        && u.isSameUrl(href, null, rtc)) {
      return;
    }

    //If in a modal dialog, then submit a form via a 'POST', as doing a normal
    //redirect
    if(curam.util.isModalWindow() || inFrame) {

      //make sure that the modal parameter is set, and that a timestamp is added
      //to prevent the resulting page from being cached.
      href = rpl(rpl(href, "o3frame", "modal"),
        curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
        var form = domConstruct.create("form", {
        action:href,
        method:"POST"
      });

      //modals launched from Agenda Player in modal do not need artificial post
      if (!inFrame) {

          if(!dom.byId("o3ctx")) {
          // The o3ctx may exist on the url passed into this method already.
          // So, remove it and reset the form action.
          // This is a last-minute fix for an issue found during JDE 009
          // testing.
          form.action =
            curam.util.removeUrlParam(form.action, "o3ctx");
            var input1 = domConstruct.create("input", {
            type: "hidden", id: "o3ctx", name:"o3ctx",
            value: screenContext.getValue()
          }, form);
        }
          windowBase.body().appendChild(form);
        publishRefreshEvent();
        form.submit();
      }
      if(!ignoreFrames) {
        if (inFrame) {
          curam.util.redirectFrame(href);
        }
      }

    } else {
      //The base context case; no frameset, these are not supported in the tab
      //content panel. Just change the href
      if (screenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || screenContext.hasContextBits("NESTED_UIM")) {
        
        curam.util._handleInlinePageRefresh(href);

      } else {
        publishRefreshEvent();
        if (dojo.global.location !== curam.util.getTopmostWindow().location) {
          if (screenContext.hasContextBits("EXTAPP")) {
            var topWindow = window.top;
            topWindow.dijit.byId("curam-app").updateMainContentIframe(href);
          } else {
            require(["curam/tab"], function() {
              curam.util.getFrameRoot(dojo.global,
                  curam.tab.getTabController().ROOT_OBJ)
                     .curam.util.redirectContentPanel(href, force);
            });            
          }
        }
      }
    }
  },
  
  /**
   * Closing modal dialog opened from expanded list row or nested UIM.
   * Either Redirect expanded row iframe or open the url in a new tab,
   * depending on whether the target page is mapped to some tab or not.
   */
  _handleInlinePageRefresh: function(href) {
    curam.debug.log(bundle.getProperty("curam.util.closing.modal"), href);

    /*
     * The following code is based on assumption that inline pages are not
     * mapped to any tabs. If this is the case then the inline frame will
     * be refreshed. If the page is mapped to a tab then it will open in that
     * tab rather than in the inline frame.
     */
    var pageRequest = new curam.ui.PageRequest(href);
    require(["curam/tab"], function() {
      curam.tab.getTabController().checkPage(pageRequest, function(request) {
        // refresh the inline frame
        curam.util.publishRefreshEvent();
        dojo.global.location.reload(true);
      });
    });
  },

  /**
   * @param url
   *    The URL to redirect to.
   * @param forceLoad
   *    Load the page even if the existing URL is the same.
   * @param justRefresh
   *    Do not change to a different URL, only refresh the existing page.
   */
  redirectContentPanel: function(url, forceLoad, justRefresh) {
    require(["curam/tab"], function() {
      // add the return page parameter
      var iframe = curam.tab.getContentPanelIframe();
      var newUrl = url;
      if (iframe != null) {
        var rpu = curam.util.Constants.RETURN_PAGE_PARAM;
        var o3rpuValue = null;
        if (url.indexOf(rpu + "=") >= 0) { // if the url has RPU param
          curam.debug.log("curam.util.redirectContentPanel: " 
            + bundle.getProperty("curam.util.rpu"));
          o3rpuValue = decodeURIComponent(curam.util.getUrlParamValue(url, rpu));
        }
        // or the specified URL has no __o3rpu parameter - just pass through
        
        if (o3rpuValue) {
          // strip the __o3rpu parameter form the RPU value
          o3rpuValue = curam.util.removeUrlParam(o3rpuValue, rpu);

          newUrl = curam.util.replaceUrlParam(url, rpu,
              encodeURIComponent(o3rpuValue));
        }
      }
      var uimPageRequest = new curam.ui.PageRequest(newUrl);
      if (forceLoad) {
        uimPageRequest.forceLoad = true;
      }
      if (justRefresh) {
        uimPageRequest.justRefresh = true;
      }
      curam.tab.getTabController().handlePageRequest(uimPageRequest);
    });
  },

  //Redirects a page in a frame, and refreshes all other frames.
  //If 'href' is not set, then the current window is not refreshed,
  //just the other frames.
  redirectFrame: function(href) {
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      var target = curam.util.getFrameRoot(dojo.global, "wizard").targetframe;
      target.curam.util.publishRefreshEvent();
      target.location.href = href;

      } else if (dojo.global.jsScreenContext.hasContextBits('ORG_TREE')) {//lazy tree
      var target = curam.util.getFrameRoot(dojo.global, "orgTreeRoot");
        /* FIXME: this code expects that curam.util and dojo are loaded
         * and avaialble in the target context. Instead it should call require()
         * to load the required module. 
         */
      target.curam.util.publishRefreshEvent();
      target.dojo.publish("orgTree.refreshContent", [ href ]);

    } else { //tree frameset
      var treeRef = curam.util.getFrameRoot(dojo.global, "iegtree");
      var navigator = treeRef.navframe || treeRef.frames[0];
      var contents = treeRef.contentframe || treeRef.frames['contentframe'];
      contents.curam.util.publishRefreshEvent();
      if (curam.PAGE_INVALIDATED || navigator.curam.PAGE_INVALIDATED) {
        var newHref = curam.util.modifyUrlContext(href, 'ACTION');
        contents.location.href = newHref;

      } else {
        contents.location.href = href;
      }
    }

    //Return true, indicating that a redirect did take place.
    return true;
  },

  publishRefreshEvent: function() {
      topic.publish("/curam/page/refresh");
  },

  /**
   * Opens a basic error modal dialog using the href 
   * <code>generic-modal-error.jspx</code>. The paramters are used to contruct
   * the full URL to the dialog.
   * 
   * @param windowOptions       The windows options to specifiy the width and 
   *                              height of the dialog.
   * @param titleProp           The property key to be used when localizing
   *                              the text of the title on the dialog.
   * @param messageProp         The property key to be used when localizing
   *                              the message on the dialog.
   * @param messagePlaceholder1 The first placeholder to be within the message
   *                              on the dialog. THis will not be set if it is 
   *                              undefined.
   * @param isErrorModal        The boolean value to indicate whether it is an
   *                            error modal or a warning modal.            
   */
  openGenericErrorModalDialog: function(windowOptions, titleProp, 
      messageProp, messagePlaceholder1, isErrorModal) {
    var url;
    var msgPlaceholder1;
    var sc = new curam.util.ScreenContext('MODAL');
    var titlePropertyName = "titlePropertyName=" + titleProp + "&";
    var messagePropertyName = "messagePropertyName=" + messageProp + "&";
    var isErrormodal = "errorModal=" + isErrorModal + "&";
    
    if (messagePlaceholder1) {
      msgPlaceholder1 = "messagePlaceholder1=" + messagePlaceholder1 +"&";
      url ="generic-modal-error.jspx?" + titlePropertyName + messagePropertyName 
        + msgPlaceholder1 + isErrormodal + sc.toRequestString();
    } else {
      url ="generic-modal-error.jspx?" + titlePropertyName + messagePropertyName 
      + sc.toRequestString();
    }
    // TODO: May also want to take into account whether window options are set
    // or not -- BOS
    curam.util.openModalDialog({href:url}, windowOptions);
  },

  // Opens a modal dialog.
  // This is the public API function.
  // The function can take an anchor tag or an event as its first parameter
  // The uimToken parameter is only used in conjunction with the UIMDialog API.
  openModalDialog: function(
    eventOrAnchorTag, windowOptions, left, top, uimToken) {

    var href;
    if(!eventOrAnchorTag || !eventOrAnchorTag.href) {
      // it is an event
        eventOrAnchorTag = dojoEvent.fix(eventOrAnchorTag);

      var target = eventOrAnchorTag.target;
        while(target.tagName != "A" && target != windowBase.body()){
        target = target.parentNode;
      }

      href = target.href;

      //Mark the anchor tag as a modal dialog opener, so that other listeners on
      //it, e.g. the List Context Menus in /jscript/curam/listMenu.js, ignore
      //clicks on it.
      target._isModal = true;

        dojoEvent.stop(eventOrAnchorTag);

    } else {
      // it is an anchorTag
      href = eventOrAnchorTag.href;
      eventOrAnchorTag._isModal = true;
    }

        require(["curam/dialog"]);
    var opts = curam.dialog.parseWindowOptions(windowOptions);
    curam.util.showModalDialog(href, eventOrAnchorTag,
          opts['width'], opts['height'], left, top,  false, null, null, uimToken);
    return false;
  },

  // Shows a modal dialog.
  // Internal function, used from the public openModalDialog() function above
  // and also from pop-up-related code (omega3-util.js).

  // The uimToken parameter is only used in conjunction with the UIMDialog API.

  // @param realParent
  //            The parent window the request to open modal originated from.
  showModalDialog: function(url, eventOrAnchorTag,
      width, height, left, top, resizable, status, realParent, uimToken) {

    // handling nested modals ->
    // if called from within modal, redirect call to the parent window.
    var topmostWindow = curam.util.getTopmostWindow();
    if (dojo.global != topmostWindow) {
      curam.debug.log(
          "curam.util.showModalDialog: " 
            + bundle.getProperty("curam.util.redirecting.modal"));
      topmostWindow.curam.util.showModalDialog(url, eventOrAnchorTag,
          width, height, left, top, resizable, status, dojo.global, uimToken);
      return;
    }

    var rup = curam.util.replaceUrlParam;
    url = rup(url, "o3frame","modal");
    url = curam.util.modifyUrlContext(url, 'MODAL', 'TAB|LIST_ROW_INLINE_PAGE|LIST_EVEN_ROW|NESTED_UIM');
    url = rup(url, curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
    curam.debug.log(bundle.getProperty("curam.util.modal.url"), url);

    if (width) {
      width = typeof(width) == 'number' ? width : parseInt(width);
    }
    if (height) {
      height = typeof(height) == 'number' ? height : parseInt(height);
    }
    
    // Prevent multiple further requests for modal until this one is processed
    if (!curam.util._isModalCurrentlyOpening()) {
      curam.util._setModalCurrentlyOpening(true);

      require(["curam/ModalDialog"]);
      new curam.ModalDialog({href: url,
                             width: width,
                             height: height,
                             openNode: (eventOrAnchorTag && eventOrAnchorTag.target) ? eventOrAnchorTag.target : null,
                             parentWindow: realParent,
                             uimToken: uimToken});
    }
  },
  
  /**
   * Determine if a modal is being opened at this time.
   *
   * @returns True if modal open operation is in progress, otherwise false.
   */
  _isModalCurrentlyOpening: function() {
    return curam.util.getTopmostWindow().curam.util._modalOpenInProgress;
  },
  
  /**
   * Set the flag indicating if a modal is being opened at this time.
   *
   * @param isOpening {Boolean} Value for the flag, either true or false.
   */
  _setModalCurrentlyOpening: function(isOpening) {
    curam.util.getTopmostWindow().curam.util._modalOpenInProgress = isOpening;
  },
  
  setupPreferencesLink: function(href) {
      ready(function() {
        var prefsAnchor = query(".user-preferences")[0];
      if (prefsAnchor) {
        if (typeof(prefsAnchor._disconnectToken) == "undefined") {
          prefsAnchor._disconnectToken = curam.util.connect(prefsAnchor,
              "onclick", curam.util.openPreferences);
        }
        
        if (!href) {
            href = dojo.global.location.href;
        }
        if (curam.util.isActionPage(href)) {
          // disable the link
            domClass.replace(prefsAnchor, "disabled", "enabled");
          prefsAnchor._curamDisable = true;

        } else {
            domClass.replace(prefsAnchor, "enabled", "disabled");
          prefsAnchor._curamDisable = false;
        }

      } else {
        curam.debug.log(bundle.getProperty("curam.util.no.setup"));
      }
    });
  },
  
  openPreferences: function(event) {
      dojoEvent.stop(event);
    
    if (event.target._curamDisable) {
      // link disabled, do nothing
      return;
    }
    
    require(["curam/tab"], function() {
      curam.tab.getTabController().handleLinkClick(
          "user-prefs-editor.jspx", {dialogOptions:"width=450"});
    });
  },
  
  openAbout: function(event) {
      dojoEvent.stop(event);
      require(["curam/tab"], function() {
        curam.tab.getTabController().handleLinkClick(
            "about.jsp", {dialogOptions:"width=645,height=480"});
      });
  },
  

  addMinWidthCalendarCluster: function(id){

      var contentNode = dom.byId(id);
    var i = 0;

    function addWidth(evt){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "width", "97%");
          if(node.clientWidth < 700){
              style.set(node, "width", "700px");
          }
        }
      });
    }//end function addWidth

      if(has("ie") > 6){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "minWidth", "700px");
        }
      });
    } else {
        on(dojo.global, 'resize', addWidth);
        ready(addWidth);
    }
  },

  addPopupFieldListener: function(id){
      if(!has("ie") || has("ie") > 6){
      return;
    }
    if(!curam.util._popupFields) {
      function doResize(evt){
        var actionWidth=0;
        var j = 0;
        var x = 0;
        var arr = curam.util._popupFields;
          array.forEach(curam.util._popupFields, function(id){
            var fieldNode = dom.byId(id);
            query("> .popup-actions", fieldNode).forEach(function(node){
            actionWidth = node.clientWidth + 30;
          });

            query("> .desc", fieldNode).forEach(function(node){
              style.set(node, "width",
              Math.max(0, fieldNode.clientWidth - actionWidth) + "px");
          });
        });
      }// end doResize function
      curam.util._popupFields = [id];
        on(dojo.global, 'resize', doResize);
        ready(doResize);
    } else {
     curam.util._popupFields.push(id);
    }
  },

  /**
   * Sets the width and height (on IE6) of the main content area and sidebar
   * when the window is resized. The sidebar is not always included on a page.
   */
  addContentWidthListener: function(id) {
      if (has("ie") > 6) {
      // don't do if IE is 7 and higher
      return;
    }
      var setStyle = style.set;
      var hasClass = domClass.contains;

    function doResize(evt) {
      var i = 0;
        var contentNode = dom.byId("content");
      if (contentNode) {
        var width = contentNode.clientWidth;

        // Only set the height of the content if the footer is present,
        // and if the browser is Internet Explorer 6
          if (has("ie") == 6 && dom.byId("footer")) {
            var contentHeight = windowBase.body().clientHeight - 100;
          setStyle(contentNode, "height", contentHeight + "px");
            var sideNode = dom.byId("sidebar");
          if (sideNode) {
            setStyle(sideNode, "height", contentHeight + "px");
          }
        }

        try{
            query("> .page-title-bar", contentNode).forEach(function(node){
              var marginW = geom.getMarginSize(node).w
                  - geom.getContentBox(node).w;
              if (!has("ie")) {
              marginW +=1;
            }
            width =  contentNode.clientWidth - marginW;
              style.set(node, "width", width + "px");
          });
        }catch(e){
        // Do nothing. If the page-title-bar does not exist it won't need to be resized.
        }

          query("> .page-description", contentNode).style("width", width + "px");
          query("> .in-page-navigation", contentNode).style("width", width + "px");
      }
    }

    curam.util.subscribe("/clusterToggle", doResize);
    curam.util.connect(dojo.global, 'onresize', doResize);
      ready(doResize);
  },

  //depending on the final row and height of the visible scrollable area
  //we will have to add/remove the bottom border on the final row
  alterScrollableListBottomBorder: function(id, maxHeight){

    var visibleAreaHeight = maxHeight;
    var queryText = "#" + id + " table"; //to find the table contained in the div

    function alterBorder() {
        var scrollTable = query(queryText)[0];
      if (scrollTable.offsetHeight >= visibleAreaHeight) { //scrollbar visible & active
        //dont want a border on final row, if an odd row
          var lastRow = query(".odd-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "no-bottom-border");
        }
      }
      else if (scrollTable.offsetHeight < visibleAreaHeight) { //scrollbar visible & inactive
        //we want a border on final row, if an even row
          var lastRow = query(".even-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "add-bottom-border");
        }
      }
      else {
        curam.debug.log("curam.util.alterScrollableListBottomBorder: " 
          + bundle.getProperty("curam.util.code"));
      }
    }
    //added onLoad event to stop IE7 reading table heght before it is fully loaded
      ready(alterBorder);

  },

  //Set the width (on IE6) of the file upload button and its associated textfield,
  // and it will be auto resized when the window is resized.
  addFileUploadResizeListener:function(code){

    function fileUploadResize(evt){

        if(query(".widget")){

                query(".widget").forEach(function(widgetNode){
                var width = widgetNode.clientWidth;
                    if(query(".fileUpload", widgetNode)){

                        query(".fileUpload", widgetNode).forEach(function(fileUploadNode){
                        fileUploadWidth = width/30;
                        if(fileUploadWidth < 4){
                          fileUploadNode.size= 1;
                        }
                        else{
                          fileUploadNode.size= fileUploadWidth;
                        }
                      });
                  }
              });
          }
    }
      on(dojo.global, 'resize', fileUploadResize);
      ready(fileUploadResize);
  },


  //Opens a pop up dialog, non-modal, in the centre of the screen.
  openCenteredNonModalWindow: function(url, width, height, name) {
    // Fudge factors for window decoration space.
    width = Number(width);
    height = Number(height);
    var offsetLeft = (screen.width - width) / 2;
    var offsetTop = (screen.height - height) / 2;

    height = offsetTop < 0 ? screen.height : height;
    offsetTop = Math.max(0, offsetTop);

    width = offsetLeft < 0 ? screen.width : width;
    offsetLeft = Math.max(0, offsetLeft);

    var left = "left", top = "top";
      if(has("ff")) {
       left = "screenX", top = "screenY";
    }
    var defaultOptions = "location=no, menubar=no, status=no, toolbar=no, "
                         + "scrollbars=yes, resizable=no";

      var newWin = dojo.global.open(url, name || "name",
      'width=' + width + ', height=' + height + ', ' +
      left + '=' + offsetLeft + ',' + top + '=' + offsetTop + ',' +
            defaultOptions );
    // Enforce the size of the window.
    newWin.resizeTo(width, height);

    // Enforce the position of the window
    newWin.moveTo(offsetLeft, offsetTop);
    newWin.focus();
  },

  adjustTargetContext: function(win, href) {
      if (win && win.dojo.global.jsScreenContext) {
        var oldContext = win.dojo.global.jsScreenContext;
        oldContext.updateStates(dojo.global.jsScreenContext);
      return curam.util.replaceUrlParam(href, "o3ctx", oldContext.getValue());
    }
    return href;
    // TO DO: what context is needed to return here if the conditional
    // returns false?
    // Will be looked at in TEC-7946
  },

  modifyUrlContext: function(url, addBits, clearBits) {
    var newUrl = url;
    var ctx = new curam.util.ScreenContext();
    var valueInUrl = curam.util.getUrlParamValue(url, "o3ctx");
    if (valueInUrl) {
      ctx.setContext(valueInUrl);
    } else {
      ctx.clear();
    }
    if (addBits) {
      ctx.addContextBits(addBits);
    }
    if (clearBits) {
      ctx.clear(clearBits);
    }
    newUrl = curam.util.replaceUrlParam(url, "o3ctx", ctx.getValue());
    return newUrl;
  },

  updateCtx: function(initialValue) {
  var valueInUrl = curam.util.getUrlParamValue(initialValue, "o3ctx");
  if (!valueInUrl) {
    return initialValue;
  }
    return curam.util.modifyUrlContext(initialValue, null, 'MODAL');
  },

  getFrameRoot: function(thisWindow, rootObjectName) {
    var found = false;
    var topRef = thisWindow;
    if (topRef) {
      while (topRef != top && !topRef.rootObject) {
        topRef = topRef.parent;
      }
      if (topRef.rootObject) {
        found = (topRef.rootObject == rootObjectName);
      }
    }

    return found ? topRef : null;
  },

  //Saves HTML for informational messages locally on the clients machine.
  //This is used by modal windows to store informational messages before they
  //shut down. The parent page then loads these messages using
  //curam.util.loadInformationalMsgs, and clears the local
  //stored versions, so they are only loaded once.
  saveInformationalMsgs: function(callback) {
    curam.util.runStorageFn(function() {
      try {
          var context = curam.util.getTopmostWindow().dojox;
          context.storage.put(curam.util.INFORMATIONAL_MSGS_STORAGE_ID,
              json.toJson({
              //Store the page ID, so these messages are only loaded back onto
              //the same page as the one on which they were saved.
                pageID: windowBase.body().id,

              //Store the entire set of messages, including the header, the
              //<ul> element and it's contents. This will be used in most cases.
                total: dom.byId(curam.util.ERROR_MESSAGES_CONTAINER).innerHTML,

              //Save just the <li> elements. If the parent page already has
              //informational messages, these are appended to the existing list.
              //This should not happen really, but is possible. I think...
              //Either way, this doesn't hurt.
                listItems: dom.byId(curam.util.ERROR_MESSAGES_LIST).innerHTML
          }));

      } catch (e) {
        curam.debug.log(bundle.getProperty("curam.util.exception"), e);
      }
    },
    callback);
  },

  //Runs a function that uses dojox.storage. This makes it wait for the manager
  //to be initialized.  If the storage manager is ready, this function is run
  //immediately.
  runStorageFn: function(fn, callback) {
    var runAction = function() {
      fn();
      if(callback) {
        setTimeout(callback, 10);
      }
    };
    var context = curam.util.getTopmostWindow().dojox;
    require(["dojox/storage"], function() {
      var mgr = context.storage.manager;
      if (mgr.isInitialized()) {
        //If the storage manager is ready, just run the function
        runAction();
      } else {
        //Run the function when the manager is ready. If an addOnLoad method is
        //available use it, otherwise use the on function.
        if (mgr.addOnLoad) {
          mgr.addOnLoad(runAction);
        } else{
          var wrapper = {exp: runAction};
          on(mgr, "loaded", wrapper, "exp");
        }
      }
    });
  },

  //Disables the loading of informational messages on the current page.
  //This prevents the messages being cleared for a modal dialog's parent page
  //if the loadInformationalMsgs function runs on the page after the messages
  //are saved using the saveInformationalMsgs function.
  disableInformationalLoad: function() {
    curam.util._informationalsDisabled = true;
  },

  redirectDirectUrl: function() {
      ready(function(){
        if (dojo.global.parent == dojo.global) {
        var url = document.location.href;
        var idx=url.lastIndexOf("/");
        if (idx > -1) {
          if (idx <= url.length) {  
           url = url.substring(idx + 1);
         }
        } 
        
          dojo.global.location = jsBaseURL + "/AppController.do?o3gtu=" + encodeURIComponent(url);
      }
    });
  },
  
  //Loads any informational messages from local storage, and puts them
  //on the page. If they exist, they are wiped out, so that they only show once.
  loadInformationalMsgs: function() {
      ready(function(){
      // no informational messages are to be displayed within the context panel
        if(dojo.global.jsScreenContext.hasContextBits('CONTEXT_PANEL')) {
          return;
        }

      if(curam.util._informationalsDisabled) { return;}
      //run this function when the storage is ready.
      curam.util.runStorageFn(function() {
          var context = curam.util.getTopmostWindow().dojox;
          var msgs = context.storage.get(curam.util.INFORMATIONAL_MSGS_STORAGE_ID);

        // If informational messages are stored locally, insert them into the
        // page
        if(msgs && msgs != "") {
          //Deserialize the messages from text to a JSON object
            msgs = json.fromJson(msgs);

          //Wipe out the messages so they are only loaded once
          //We could use the dojox.storage.remove method here, but it is not
          //supported by all storage implementations, so just make it an empty
          //string.
            context.storage.put(curam.util.INFORMATIONAL_MSGS_STORAGE_ID, "");
            var div = dom.byId(curam.util.ERROR_MESSAGES_CONTAINER);
            var list = dom.byId(curam.util.ERROR_MESSAGES_LIST);

          //Only load the messages on the same page as they were saved.
          //The body of each page has it's ID set, which is the name of the
          //UIM file, more or less, and is therefore unique.
            if(msgs.pageID != windowBase.body().id) {
            return;
          }

          // If there are somehow messages already on the page, do not override
          // them, just append to them.
          if(list) {
            //Don't append duplicate informational messages.
              var tempUL = domConstruct.create("ul", {
              innerHTML: msgs.listItems
            });

            //Create an array of the LI elements already in the list.
            var currentLIs = [];
            for(var i = 0; i < list.childNodes.length; i++) {
              if(list.childNodes[i].tagName == "LI"){
                currentLIs.push(list.childNodes[i]);
              }
            }

            //Go through the existing messages to check for duplicates
            //If no duplicate informational message exists, then append the
            //message to the existing list of messages.
            var skip = false;
            var nodes = tempUL.childNodes;
            for(var i = 0; i < nodes.length; i++) {
              skip = false;
              for(var j = 0; j < currentLIs.length; j++) {
                if(nodes[i].innerHTML == currentLIs[j].innerHTML) {
                  skip = true;
                  break;
                }
              }
              if(!skip) {
                list.appendChild(nodes[i]);
                i--;
              }
            }
          } else if(div){
            div.innerHTML = msgs.total;
          } 
        }
        var informationalMessage = dojo.byId('error-messages');
          if (informationalMessage && !dojo.global.jsScreenContext.hasContextBits("MODAL")) {
            informationalMessage.focus();
          }
      });
    });
  },

  /**
   * sets focus to the input field with the biggest value
   * of tabindex property.
   */
   setFocus: function() {
    var isModal = curam.util.getUrlParamValue(
          dojo.global.location.href, "o3frame") == "modal";
    if (!isModal) {
      // for pages in main content call setFocus here, modals will
      // do it differently in ModalDialog.js
        ready(curam.util.doSetFocus);
    }
  },

  /**
   * Set focus on the first editable field in the page. If there are no editable
   * fields, the function does not do anything. In case the first editable field
   * is a FilteringSelect widget than it skipd the arrow and validation container
   * and sets the focus on the input container of FilteringSelect widget.
   *
   * @returns {Boolean} True if focus has been set to the first editable field.
   *                    False if there are no editable fields in the page.
   */
  doSetFocus: function() {
    var firstIdx = -1;  // marks the first element to set focus to
    var customIdx = -1; // marks any override of the first element
    var form = document.forms[0];
    if (!form) {
      // no editable fields - nothing to do
      return false;
    }
    var elements = form.elements;
    var l = elements.length;
    var elem;
    
    for (var i = 0; i < l; i++) {
      elem = elements[i];
      // we check firstIdx to prevent having to iterate over the
      // elements twice to find the first and custom fields for focus
      if (firstIdx == -1 && (
          elem.type == 'select-one'
          || elem.type == 'text'
          || elem.tagName == "TEXTAREA") 
          && !domClass.contains(elem, "dijitArrowButtonInner")
          && !domClass.contains(elem, "dijitValidationInner")) {
        firstIdx = i;
      }
      if (elem.tabIndex == '1') {
        // reset the tab index to prevent it having an effect on
        // screen tabbing.
        elem.tabIndex = 0;
        customIdx = i;
        break; // once we've found an override, no need to keep looping.
      }
    }

    var elem;
    if (customIdx != -1) {
      elem = elements[customIdx];

    } else if (firstIdx != -1) {
      elem = elements[firstIdx];
    }

    try {
      var errorMessage = dojo.byId('error-messages');
      if (errorMessage) {
        errorMessage.focus();
      } else {
      elem.focus();
      }
    } catch(e) {
      curam.debug.log(bundle.getProperty("curam.util.error.focus"), e.message);
      return false;
    }

    return true;
  },

  openLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
    var target = event.target;
    while(target && target.tagName != "A") {
      target = target.parentNode;
    }
    var loc = target.href;
    var rpu = curam.util.getUrlParamValue(loc, "__o3rpu");
    // strip the __o3rpu parameter form the RPU value
    rpu = curam.util.removeUrlParam(rpu, "__o3rpu");
    var href="user-locale-selector.jspx" + "?__o3rpu=" + rpu;

      if (!curam.util.isActionPage(dojo.global.location.href)) {
      openModalDialog({href:href},"width=500,height=300",200,150); 

    } else {
      alert(curam.util.msgLocaleSelectorActionPage);
    }

    return false;
  },

  isActionPage: function(url) {
    var pageAndQuery = curam.util.getLastPathSegmentWithQueryString(url);
    var pageName = pageAndQuery.split("?")[0];
    return pageName.indexOf("Action.do") > -1;
  },

  closeLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
      dojoEvent.stop(event);

      dojo.global.close();
    return false;
  },

  /**
   * Retrieves the remaining part of a class name which has the specified prefix.
   * E.g. for <theNode class="class1 class2 thePrefix-remaining-part-of-name" />
   * the call to curam.util.getSuffixFromClass(theNode, "thePrefix-")
   * will return "remaining-part-of-name".
   *
   * @param node
   *          The note to get the class from.
   * @param prefix
   *          The prefix to find the class by.
   * @returns
   *    If the class with the prefix is found it returns the remaining
   *    part of the class name. If the class is not found, returns null.
   *    If more than one class is found, it returns the first occurrence.
   */
  getSuffixFromClass: function(node, prefix) {
      var classes = attr.get(node, "class").split(" ");
      var namesFound = array.filter(classes, function(className) {
      return className.indexOf(prefix) == 0;
    });
    if (namesFound.length > 0) {
      return namesFound[0].split(prefix)[1];

    } else {
      return null;
    }
  },

  getCacheBusterParameter : function() {
    return this.CACHE_BUSTER_PARAM_NAME + "=" + new Date().getTime() + "_"
        + this.CACHE_BUSTER++;
  },

  /**
   * Add classes to table rows to allow striping in appearance.
   * Handles expandable and paginated lists in a specific way.
   */
  stripeTable: function(table, isExpandableList, lastVisibleRowIndex) {
    var tbody = table.tBodies[0];
    var mainRowStep = (isExpandableList ? 2 : 1);

    // for a list with one row do nothing
    if (tbody.rows.length < mainRowStep) {
      return;
    }

    var rows = tbody.rows;

    for (var i = 0; i < rows.length; i += mainRowStep) {
      curam.debug.log(
          "curam.util.stripeTable(%s, %s): i = %s", table, isExpandableList, i);

      // collect rows to change (to include details row in expandable lists)
      var rowsToChange = [ rows[i] ];
      // checking for existence of details row - if list is empty, there might
      // be just one empty row
      if (isExpandableList && rows[i + 1]) {
        rowsToChange.push(rows[i + 1]);
      }

      // remove classes before adding the right ones
        array.forEach(rowsToChange, function(row) {
          domClass.remove(row, "odd-last-row");
          domClass.remove(row, "even-last-row");
      });

      if (i % (2 * mainRowStep) == 0) {
          array.forEach(rowsToChange, function(row) {
          cm.replaceClass(row, 'odd', 'even');
        });

        if (i == lastVisibleRowIndex) {
            array.forEach(rowsToChange, function(row) {
              domClass.add(row, "odd-last-row");
          });
        }

      } else {
          array.forEach(rowsToChange, function(row) {
          cm.replaceClass(row, 'even', 'odd');
        });

        if (i == lastVisibleRowIndex) {
            array.forEach(rowsToChange, function(row) {
              domClass.add(row, "even-last-row");
          });
        }
      }
    }
  },

  fillString: function(fillChar, count) {
    // summary:
    //  Creates a string of 'x' repeating characters
    var string = "";
    while (count > 0) {
      string += fillChar;
      count-=1;
    }
    return string;
 },

  updateHeader: function(qId, newHeader, answer, source) {
      var header = dom.byId('header_' + qId);
    header.firstChild.nextSibling.innerHTML = newHeader;
      answerCell = dom.byId('chosenAnswer_' + qId);
    answerCell.innerHTML = answer;
      sourceCell = dom.byId('chosenSource_' + qId);
    sourceCell.innerHTML = source;
  },
 
  search: function(textWidgetID, typeWidgetID){
     // summary:
     //              Invokes the required search page for an application search as
     //              specified by the associated configuration data. How this
     //              is done is described below:
     //
     // description:
     //              <ol>
     //                <li>
     //                  Retrieving the value of the business object select drop
     //                  down. This value includes a business object code and
     //                  also a page identifier.
     //                </li>
     //                <li>
     //                  Retrieving the value of the input text control which
     //                  specifies the search text to be used.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has been
     //                  specified in the associated configuration data, the
     //                  page identifier specified by the selected option will
     //                  be used to construct a URL using the
     //                  <code>searchText</code> and <code>searchType</code>
     //                  page parameters and that page is invoked.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has not been
     //                  specified in the associated configuration data, the
     //                  default search page specified will be used to construct
     //                  a URL using the <code>searchText</code> page parameter
     //                  only and then that page is invoked.
     //                </li>
     //              </ol>
     //              <P>
     //              The data used here is generated by a renderer so therefore
     //              no validations are performed and it is assumed that the
     //              data is in the correct format for parsing.
     // textWidgetID:
     //              The identifier of the text input control for the application
     //              search which is used to retrieve the text to be used in the
     //              application search. The value taken from this field is
     //              associated with the <code>searchText</code> page parameter
     //              of the search page being invoked.
     // typeWidgetID:
     //              The identifier of the drop down control for the application
     //              search which is used to retrieve the business object type
     //              to be used in the application search. The value taken from
     //              this field is associated with the <code>searchType</code>
     //              page parameter of the search page being invoked. Note that
     //              this is optional as the list of business objects to search
     //              for is an optional element of an application search.
 
    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
 
    // Retrieve the search text from the input control.
      var searchText = registry.byId(textWidgetID).get("value");
    // The search type, if specified, from the drop down list of business
    // objects. This is a combination of the type and the page identifier
    // so split these out here.
      var searchTypeWidget = registry.byId(typeWidgetID);
    var currentlySelectedItem
          = searchTypeWidget ? searchTypeWidget.get("value"): null;
    var searchType = "";
    var pageIDFromSearchOptions;
    var tokens;
 
    if(currentlySelectedItem){
      // The currently selected item consists of the search type and the page
      // identifier to use in the search.
      tokens = currentlySelectedItem.split("|");
      searchType = tokens[0];
      pageIDFromSearchOptions = tokens[1];
    }
 
    var defaultSearchPageID = curam.util.defaultSearchPageID;
 
    // If the select box has not been specified, then the page identifier is
    // the default page identifier. Construct the page to be invoked.
    var searchPageURL = "";
    if (searchType==="") {
      searchPageURL = defaultSearchPageID + "Page.do?searchText="
                                              + encodeURIComponent(searchText);
    } else {
      searchPageURL = pageIDFromSearchOptions + "Page.do?searchText="
                          + encodeURIComponent(searchText) + "&searchType="
                            + encodeURIComponent(searchType);
    }
    // Call the function that will load the search page.
    var searchPageRequest = new curam.ui.PageRequest(searchPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(searchPageRequest);
    });
  },
 
  updateDefaultSearchText: function(typeWidgetID, textWidgetID){
    // summary:
    //              Updates the search text input control in the application
    //              search widget with some initial text from the item selected
    //              in the associated list of search business objects.
    //
    // description:
    //              Retrieves the initial text from the item selected in the list
    //              of business objects drop down and sets the place holder
    //              attribute of the application search text input control with
    //              this initial text. This is called from the
    //              <code>onChange()</code> event of the application search drop
    //              down list.
    // typeWidgetID:
    //              The identifier of the drop down control for the application
    //              search which is used to retrieve the initial text that is
    //              set in the place holder attribute of the associated text
    //              input control each time the value of the drop down list
    //              is changed. This initial text acts as an aid to the user
    //              when performing the search as it offers them a hint as to
    //              what should be entered into the text area for the type of
    //              search being performed.
    // textWidgetID:
    //              The identifier of the text input control whose place
    //              holder attribute will be set with initial text to aid the
    //              user perform the search.
 
    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
 
      var searchTypeWidget = registry.byId(typeWidgetID);
      var textWidget = registry.byId(textWidgetID);
    var currentlySelectedItem
      = searchTypeWidget ? searchTypeWidget.get("value"): null;
    // The initial text is the third token in the string.
    var str = currentlySelectedItem.split("|")[2];
 
      textWidget.set("placeHolder", str);
  },
 
  updateSearchBtnState: function(textWidgetID, btnID){
    // summary:
    //              Enables or disables the search anchor for an application
    //              search depending on whether this is text specified for the
    //              search.
    //
    // description:
    //              The search anchor specified for an application search is
    //              disabled if no text has been specified in the text input
    //              control. This function is called on the
    //              <code>onKeyPress</code> of the text input control so that when
    //              a user enters some text, the search anchor is enabled to allow
    //              that user perform the search.
    // textWidgetID:
    //              The identifier of the text input control for the application
    //              search which is used to determine if that text box contains
    //              any text. If it does, then the search anchor is enabled,
    //              otherwise it is disabled.
    // btnID:
    //              The identifier of the search anchor for the application search
    //              and this is used to retrieve the control to enable or disable
    //              depending on whether there is text in the associated search
    //              text input control.
 
    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
      var widget = registry.byId(textWidgetID);
      var btn = dom.byId(btnID);
      var value = widget.get("value");
 
      if(!value || lang.trim(value).length < 1){
        domClass.add(btn, "dijitDisabled");
      } else {
        domClass.remove(btn, "dijitDisabled");
    }
  },
 
  furtherOptionsSearch: function() {
 
    // summary:
    //              Invokes the page specified for the further options link
    //              in an application search.
    //
    // description:
    //               The further options search page is invoked by retrieving
    //               the page identifier specified in the configuration
    //               data, constructing a page request for that URL and
    //               calling the function to handle that request.
    //               <P>
    //               Validations performed elsewhere should ensure that the
    //               data is specified in the correct fashion and hence there
    //               are no validations invoked here.
 
    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
 
    // Retrieve the page identifier for the further options link.
    var furtherOptionsPageURL = curam.util.furtherOptionsPageID + "Page.do";
 
    // Call the function that will load the search page.
    var furtherSearchOptionsPageRequest
        = new curam.ui.PageRequest(furtherOptionsPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(
          furtherSearchOptionsPageRequest);
    });
  },
  
  searchButtonStatus: function(btnID){
    // summary:
	//              Returns true if the button is not disabled 
	//
	// description:
	//              The search anchor specified for an application search is
	//              disabled if no text has been specified in the text input
	//              control. This function is called on the
	//              <code>onKeyPress</code> of the text input control if this function returns true.
	// btnID:
	//              The identifier of the search anchor for the application search
	//              and this is used to retrieve the control to enable or disabled
	var btn = dojo.byId(btnID);
	if(!dojo.hasClass(btn,"dijitDisabled")){
	  return true;
	}
  }, 
 
  /**
  * Return the height of the page contents for the current width.
  * Note that if the width changes, the contents height might change as well.
  *
  * Note: this algorithm is dependent on the structure of the
  * DOM. Changes to the page layout will probably break this.
  *
  * @return page height.
  */
  getPageHeight: function() {
    var defaultHeight = 400;
    var resultingHeight = 0;
 
      if (query("frameset").length > 0) {
      /* Detect framesets and use default height for them.
      * Normally frameset windows should have fixed height specified
      * by the developer, but this is for the cases in which the developer
      * forgets to specify the height.
      */
      curam.debug.log(
        "curam.util.getPageHeight() " 
          + bundle.getProperty("curam.util.default.height"),
      defaultHeight);
      resultingHeight = defaultHeight;
 
    } else {
      // create function for determinning bottom coordinate of an element
      var bottom = function(node) {
        if (!node) {
          curam.debug.log(bundle.getProperty("curam.util.node"));
          return 0;
        }
 
        // Use getMarginBoxSimple if it's available
          var mb = geom.getMarginSize(node);
          var pos = geom.position(node);
 
        return pos.y + mb.h;
      };
 
        if (dojo.global.jsScreenContext.hasContextBits('LIST_ROW_INLINE_PAGE')) {
        // in case we are in list details row, just use the bottom spacer div
          var bottomSpacerDiv = query("div.bottom")[0];
        var divBottom = bottom(bottomSpacerDiv);
 
        curam.debug.log(
          bundle.getProperty("curam.util.page.height"), divBottom);
        curam.debug.log(bundle.getProperty("curam.util.ie7.issue"));
        resultingHeight = divBottom + 1;
 
      } else {
          var contentObj = dom.byId("content") || dom.byId("wizard-content");
 
        // find the bottom-most node
          var nodes = query("> *", contentObj).filter(function(n) {
          // leave out script and hidden nodes
          return n.tagName.indexOf("SCRIPT") < 0
            && style.get(n, "visibility") != "hidden"
            && style.get(n, "display") != "none";
        });
        var bottomNode = nodes[0];
        for (var i = 1; i < nodes.length; i++) {
          if(bottom(nodes[i]) >= bottom(bottomNode)) {
            bottomNode = nodes[i];
          }
        }
 
        // first count in the main contents height
        resultingHeight = bottom(bottomNode);
        curam.debug.log("curam.util.getPageHeight() " 
            + bundle.getProperty("curam.util.base.height"), resultingHeight);
 
        // count in modal dialog action set, if present
        var doesActionSetExist = query(".actions-panel", windowBase.body());
        
        if (doesActionSetExist.length > 0) {
          // Only one actions panel exists in one modal, we can get the height
          // of this panel dynamically.
          var actionsPanelHeight = geom.getMarginBox(doesActionSetExist[0]).h;

          curam.debug.log("curam.util.getPageHeight() " 
              + bundle.getProperty("curam.util.panel.height"));
            
          // Add the actions panel height to the total page height, here we
          // presume the actions panel is always positioned at the bottom of
          // the page.
          resultingHeight += actionsPanelHeight;
            
          // Then add additional 10px spacing at the top of the actions panel.
          resultingHeight += 10;
        }
 
        // in case we are in the details panel, count in the title bar height
          var detailsPanel = query("body.details");
        if (detailsPanel.length > 0) {
          curam.debug.log("curam.util.getPageHeight() " 
              + bundle.getProperty("curam.util.bar.height"));
            resultingHeight += 20;
        }
      }
    }
 
      curam.debug.log("curam.util.getPageHeight() " 
          + bundle.getProperty("curam.util.returning"), resultingHeight);
    return resultingHeight;
  },
 
  /**
  * Takes an array and from its elements it creates a comma separated
  * string of values, which is then returned.
  */
  toCommaSeparatedList: function(inputArray) {
    var result = "";
    for (var i = 0; i < inputArray.length; i++) {
      result += inputArray[i];
      if (i < inputArray.length -1) {
        result += ",";
      }
    }
    return result;
  },
 
  /**
   * Bring focus to skip link destination placeholder.
   */
  skipLinkFocus: function() {
    var dest = dojo.byId('skip-dest');
    if (dest) {
      dest.focus();
    }
  },
  
  /**
   * TEC-17091. Skiplink should become visible when focused (i.e. a user tabs on it)
   * and it should be visible only when it has focus, so it should hide again when 
   * the user tabs off it.
   */
  showHideSkipLink: function(e) {
    var skipLink = dojo.byId("skipLink");
    if (skipLink) {
      var skipLinkDiv = skipLink.parentNode;
      if (e.type == "focus" && domClass.contains(skipLinkDiv, "hidden")) {
        domClass.remove(skipLinkDiv, "hidden");
      } else if (e.type == "blur" && !domClass.contains(skipLinkDiv, "hidden")) {
        domClass.add(skipLinkDiv, "hidden");
      }
    }
  },
  
  /**
  * Registers a handler for submitting a form when Enter key is pressed.
  *
  * Called from the PageTag - will be called on every page in any context,
  * main content, dialog, etc.
  */
  setupGenericKeyHandler: function() {
      ready(function() {
      // The handler is never explicitly deregistered - disappears when
      // the runtime context is destroyed (new page loaded)
      var f = function(event) {
        
        // On ESC key handling: When ESC key is pressed and in a modal, 
        // the modal will close automatically.
        if (dojo.global.jsScreenContext.hasContextBits('MODAL')
            && event.keyCode == 27) {
          var ev = dojoEvent.fix(event);
          var dropdown = registry.byId(ev.target.id);
          var isDropdown =
            typeof dropdown != "undefined" && dropdown.baseClass == "dijitTextBox dijitComboBox";
          if (!isDropdown) {
            curam.dialog.closeModalDialog();
          }      
        }
        
        // On ENTER key handle the event
        if (event.keyCode == 13) {
            var ev = dojoEvent.fix(event);

        // only submit form when certain input fields have focus. This allows
        // for normal keyboard selection (example: pressing enter on date
        // selector icon) to happen without the form submitting.
 
    var isText = ev.target.type == "text";
    var isRadio = ev.target.type == "radio";
    var isCheckbox = ev.target.type == "checkbox";
    var isMultiSelect = ev.target.type == "select-multiple";
    var isPassword = ev.target.type == "password";
 
    var combo = registry.byId(ev.target.id);
    // Added a check so that form is not submitted when "Enter" key
    // is pressend in open state of dropdown.
    if (typeof combo != "undefined") {
      var comboWidget = registry.byNode(dojo.byId("widget_" + ev.target.id));
      if(comboWidget && comboWidget.enterKeyOnOpenDropDown) {
        comboWidget.enterKeyOnOpenDropDown = false;
        return false;
      }
    }
    
    var isCombo =
    typeof combo != "undefined" && combo.baseClass == "dijitComboBox";
    if ((!isText && !isRadio && !isCheckbox && !isMultiSelect
    && !isPassword) || isCombo ) {
      return true;
    }
    var defaultSubmitButton = null;
      var explicitDefaultBtnArray = query(".curam-default-action");
    // take the default button if set
    if (explicitDefaultBtnArray.length > 0) {
      defaultSubmitButton = explicitDefaultBtnArray[0];
 
    } else {
      // otherwise take the first found submit button
        var submitButtonsArr = query("input[type='submit']");
      if (submitButtonsArr.length > 0) {
        defaultSubmitButton = submitButtonsArr[0];
      }
    }
    // now click the button found
    if (defaultSubmitButton != null) {
        dojoEvent.stop(dojoEvent.fix(event));
      curam.util.clickButton(defaultSubmitButton);
      return false;
    }
	//Focus remains in the date selector on ENTER
    dojo.require("curam.dateSelectorUtil");
    var isInputyear = dojo.byId("year");
    if (isInputyear) {
      dojo.stopEvent(dojo.fixEvent(event));
      
      //Enter key updates the calendar
      curam.dateSelectorUtil.updateCalendar();
     }
        }
 
        // otherwise let the event continue
        return true;
      };
 
        // event must be onKeyUp, as the ESC key event is not fired during an
        // onKeyPress event.
        curam.util.connect(windowBase.body(), "onkeyup", f);
    });
  },
 
  /**
  * Returns true is key press event is triggered by the enter key.
  * Used by context panel toggle icon and list/cluster toggle icons.
  */  
  enterKeyPress: function(event) { 
    if(event.keyCode == 13) {
      return true;
    }
  },
  
  /**
   * Catches SHIFT + TAB keyboard event on modal help and close icon.
   * When tabbing backward, once visible button is encountered in the 
   * modal title bar the focus is looped back to the last button in 
   * the modal button bar.
   */  
   isShiftTab: function(e) { 
     if(e.shiftKey && e.keyCode == 9) {
       var elem, evt = e ? e:event;
       if (evt.srcElement) {
         elem = evt.srcElement;
       } else if (evt.target){
         elem = evt.target;
       }
       
       if (elem.previousSibling.className == "dijitDialogHelpIcon") {
         return false;
       } else {
         var modalId = elem.parentElement.parentElement.id;
         var endModal = dojo.byId("end-" + modalId);
         if (endModal) {
           endModal.focus();
         }
       }
     }
   },
 
   /**
    * When using tab navigation focus should come of help icon of title bar after the end of modal.
    * This is called from a keydown event on end of modal and sets the focus on help icon of title bar.
    */
   focusHelpIconOnTab: function(e) { 
     if(!e.shiftKey && e.keyCode == 9) {
       var helpIcon = dojo.query(".dijitDialogHelpIcon")[0];
       if (helpIcon) {
         setTimeout(function() { helpIcon.focus(); }, 5);
       }
     }
   },
   
  /**
  * Given a DOM node, boolean state and class names for true and false
  * alternatives, the function sets the appropriate classes on the node.
  */
  swapState: function(node, state, classTrue, classFalse) {
    if (state) {
        domClass.replace(node, classTrue, classFalse);
 
    } else {
        domClass.replace(node, classFalse, classTrue);
    }
  },
 
  /**
  * Creates a URL query string including the leading question mark
  * from the specified page parameters.
  * The function handles URL-encoding of the values so do NOT encode them.
  *
  * @param params Object in the following format:
  *                { param1Name:"value", param2Name:248 }
  */
  makeQueryString: function(params) {
    if (!params || params.length == 0) {
      return "";
    }
 
    var result = [];
    for (var paramName in params) {
      result.push(paramName + "=" + encodeURIComponent(params[paramName]));
    }
 
    return "?" + result.join("&");
  },
 
  /**
  * Handles the onClick event for the list action menu items.
  *
  * @param url
  *          The URL of the required page.
  * @param sameDialog
  *          True if we re in a dialog and the page flow should stay
  *          in the same dialog.
  */
    clickHandlerForListActionMenu: function(url, sameDialog, newWindow, event) {
    // TODO: This handler was intended only for the list row actions menu but
    // is now being used for page level actions menus also, so re-name
    // appropriately. Also, *some* of the code in this method is duplicated
    // in the "clickHandler" method of UIMPageAdaptor.js. AS LONG AS THESE
    // METHODS ARE SEPARATE, ANY UPDATES TO THE LOGIC BELOW MUST BE ANALYZED
    // TO SEE IF THEY NEED TO BE APPLIED IN THE "UIMPageAdaptor" CLASS.
    if (sameDialog) {
      var href = curam.util.replaceUrlParam(url, "o3frame", "modal");
        var ctx = dojo.global.jsScreenContext;
      ctx.addContextBits('MODAL');
      href = curam.util.replaceUrlParam(href, "o3ctx", ctx.getValue());
      curam.util.redirectWindow(href);
      return;
    }
 
    // create a dummy anchor object
    var anchor = { href: url };
 
        require(["curam/ui/UIMPageAdaptor"]);
    if (curam.ui.UIMPageAdaptor.allowLinkToContinue(anchor)) {
      // In the case of a list action menu the click event is no longer coming
      // from an anchor element, instead it's a Diji MenuItem. Explicitly
      // setting window.location fakes the same behaviour as clicking the anchor
      // element. This will handle the sceanrios tested by allowLinkToContinue,
      // which are file downloads and the mailto link.
      // TODO: Can this method just return and let the event continue without
      // setting window.location....??? Seems to be other event handers
      // supressing this, so going with this approach for now.
        dojo.global.location = url;
      return;
    }
 
    // if we have an anchor, stop the click event and perform standard tab
    // processing (i.e. should it open in a new tab etc.)
    if (anchor != null) {
        if (event) {
          dojoEvent.fix(event);
          dojoEvent.stop(event);
      }
 
      if (!anchor.href || anchor.href.length == 0) {
        // the event has been stopped, just return if it has no href.
        // any onclick handlers attached to the link will have executed by now.
        return;
      }
      if (newWindow && !curam.util.isInternal(url)) {
          dojo.global.open(url);
 
      } else if (curam.ui.UIMPageAdaptor.isLinkValidForTabProcessing(anchor)) {
        var uimPageRequest = new curam.ui.PageRequest(anchor.href);
        if (dojo.global.jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || dojo.global.jsScreenContext.hasContextBits("NESTED_UIM")) {
          uimPageRequest.pageHolder = dojo.global;
        }
        require(["curam/tab"], function() {
          curam.tab.getTabController().handlePageRequest(uimPageRequest);
        });
      }
    }
    // Otherwise we let the event continue uninterrupted.
  },
 
  /**
     * Gets browser to action a mailto: link in a separate iframe.
     * This is to avoid issues with page unloading when mailto link is clicked
     * on some browsers.
     * 
     * @param event The onclick DOM event.
     * @param url The URL of the link, including the mailto: protocol.
     */
    clickHandlerForMailtoLinks: function(event, url) {
      // stop anchor click from propagating and changing page
      dojo.stopEvent(event);

      // is there existing iframe to reuse?
      var iframe = dojo.query("#mailto_frame")[0];
      if (!iframe) {
        // no frame to reuse - create a new one
        iframe = dojo.io.iframe.create("mailto_frame", "");
      }
      
      // get browser to action the mailto: link in separate frame
      iframe.src = url;
      
      // return false as per convention for DOM click handlers
      return false;
    },
   
    /**
  * Decides whether or not the URL is internal.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns true if the URL is internal false it it is external.
  */
  isInternal: function(url) {
    var path = url.split("?")[0];
    // Occurrence of Page.do determines whether or not it is internal URL.
    // It is assumed that, the external URL's would not have Page.do as it
    // fixed internal action call for curam.
    // TODO : Determining the URL is internal based on Page.do is a
    // brittle solution.Implement the improved solution.
    var occurrence = path.match("Page.do");
    if (occurrence!= null) {
      return true;
    }
    return false;
  },
 
  /**
  * Takes a URL and extracts its last path segment with the query string.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns The last path segment of the URL with the query string,
  *      if it is part of the URL.
  */
  getLastPathSegmentWithQueryString: function(url) {
    var pathAndParams = url.split("?");
    var pathComponents = pathAndParams[0].split("/");
    return pathComponents[pathComponents.length - 1]
    + (pathAndParams[1] ? "?" + pathAndParams[1] : "");
  },
 
  /**
  * Replaces standard submit buttons with anchor tags when no images are used.
  * @param {String} buttonText
  *            The text to be displayed on submit button.
  */
  replaceSubmitButton: function(name, buttonText) {
    if(curam.replacedButtons[name] == "true") {
      return;
    }
 
    /*
    * In the agenda player search for input elements where the name attribute
    * ends with SUM. This is required because an extra string of SUM is
    * appended onto the end of the name attribute value in the agenda player.
    * For all other submit buttons in the application we'll search for the
    * input fields the normal way to ensure we're not breaking any older
    * functionality.
    */
    var buttonId = '__o3btn.' + name;
    var inputList;
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
        inputList = query("input[id='" + buttonId + "']");
 
    } else {
        inputList = query("input[name='" + buttonId + "']");
    }
 
    /*
    * You can supply 3 parameters to the forEach method of the dojo node list.
    * The current node, the index, and the node list itself.
    */
    inputList.forEach(function(replacedButton, index, theButtons) {
    	// if there is a paramter passed in for button text then set the 'value'
        // of the second button (the button dipalyed to user) node to the button
        // text specified.
        // Note: This will replace any value set in the value attribute already!
        if (buttonText) {
          var buttonDisplayed = theButtons[1];
          buttonDisplayed.setAttribute("value",buttonText);
        }
      replacedButton.tabIndex = -1;
      var parentSpan = replacedButton.parentNode;
 
      var buttonId = "btn-id-" + index;
      curam.util.setupWidgetLoadMask("a." + buttonId);
      
      var cssClass = 'ac initially-hidden-widget ' + buttonId;
      if(domClass.contains(replacedButton, "first-action-control")) {
        cssClass += ' first-action-control';
      }
      
      var newLink = domConstruct.create("a", {
        "class": cssClass,
        href: "#"
      }, replacedButton, "before");
 
      var pageLevelMenu = dojo.query(".page-level-menu")[0];
      if(pageLevelMenu) {
    	  dojo.attr(newLink,"title",replacedButton.value);
      }
      
      /*
      * Adding filler span to create spacing between buttons. This is needed
      * because if spacing is added to anchor element using CSS, the spacing is
      * still clickable in IE.
      */
        domConstruct.create("span", {
        "class": "filler"
      }, newLink, "before");
 
      // Adding span elements inside anchor tag to display rounded corners.
        var left = domConstruct.create("span", {
        "class": "left-corner"
      }, newLink);
 
        var right = domConstruct.create("span", {
        "class": "right-corner"
      }, left);
 
      // Changed from using inner HTML.
        var middle = domConstruct.create("span", {
        "class": "middle"}, right );
 
        middle.appendChild(document.createTextNode(replacedButton.value));
 
        curam.util.addActionControlClass(newLink);
 
          on(newLink, "click", function(event) {
          curam.util.clickButton(this._submitButton);
            dojoEvent.stop(event);
        });
 
        /*
        * Record the submit button on the link. This is for modal dialogs, so it
        * can distinguish a submit anchor tag from a normal anchor tag.
        *
        * NB: We have a temporary situation where we have 3 page-level-action
        * sets. 2 actions sets are the existing top and bottom ones, but they are
        * currently hidden. The third is the new button bar at the bottom of the
        * page. This is outside of the HTML form which means the "_submitButton"
        * variable was being set to a button that didn't have an associated form.
        * This caused errors in our modal dialog code. The temporary solution is
            * to set all _submitButtons to the first button found (theButtons[0])
            * which is guaranteed to be inside the form. The real solution
            * is to re-do the new button bar work so it is within the form.
        */
        newLink._submitButton = theButtons[0];
 
          domClass.add(replacedButton, 'hidden-button');
    });
 
    curam.replacedButtons[name] = "true";
  },
 
  /**
  * Adds a listener that will display the widget specified by query.
  *
  *  @param query
  *      Query of the widget to setup load mask for.
  */
    setupWidgetLoadMask: function(queryString) {
    curam.util.subscribe('/curam/page/loaded', function() {
        var widget = query(queryString)[0];
      if (widget) {
          style.set(widget, 'visibility', 'visible');
 
      } else {
        curam.debug.log("setupButtonLoadMask: " 
          + bundle.getProperty("curam.util.not.found") + "'" + queryString
         + "'" + bundle.getProperty("curam.util.ignore.mask"));
      }
    });
  },
 
  /**
  * Optionaly replaces standard submit buttons within agenda player.
  */
  optReplaceSubmitButton: function(name) {
    if (curam.util.getFrameRoot(dojo.global,"wizard") == null) {
      curam.util.replaceSubmitButton(name);
      return;
    }
    var navigator = curam.util.getFrameRoot(dojo.global,"wizard").navframe.wizardNavigator;
    if (navigator.delegatesSubmit[jsPageID] != 'assumed') {
      curam.util.replaceSubmitButton(name);
    }
  },
 
  /**
  * Clicks a HTML button.
  *
  * @param buttonObj the button object or the id of the button object.
  */
  clickButton: function(buttonObj) {
      var theForm = dom.byId("mainForm");
    var hiddenButton;
 
    // if we have no argument, then return
    if (!buttonObj) {
      curam.debug.log("curam.util.clickButton: " 
        + bundle.getProperty("curam.util..no.arg"));
      return;
    }
 
    // if the argument is a string, then we assume it is the id of the
    // input element and search for it.
    if (typeof(buttonObj) == "string") {
      var buttonObjID = buttonObj;
      curam.debug.log("curam.util.clickButton: " 
        + bundle.getProperty("curam.util.searching")
        + bundle.getProperty("curam.util.id.of") + "'" + buttonObjID + "'.");
        buttonObj = query("input[id='"  + buttonObjID + "']")[0];
 
      // if we still have not found the input element, the return
      if (!buttonObj.form && !buttonObj.id) {
        curam.debug.log("curam.util.clickButton: " 
            + bundle.getProperty("curam.util.searched")
            + bundle.getProperty("curam.util.id.of") + "'" + buttonObjID 
            + bundle.getProperty("curam.util.exiting"));
        return;
      }
    }
 
    // In the agenda player search for input elements where the name attribute
    // ends with SUM. This is required because an extra string of SUM is
    // appended onto the end of the name attribute value in the agenda player.
    // For all other submit buttons in the application we'll search for the
    // hidden buttons the normal way to ensure we're not breaking any older
    // functionality.
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      hiddenButton = buttonObj;
  
      } else {
        hiddenButton = query("input[name='" + buttonObj.id + "']", theForm)[0];
    }
    try {
      // if the page is being submitted to self, publish event to enable
      // code to be run before refresh - used for example for saving list state
      // data to be restored on the page reload
        if (attr.get(theForm, "action").indexOf(jsPageID) == 0) {
        curam.util.publishRefreshEvent();
      }
      hiddenButton.click();
  
    } catch(e) {
      curam.debug.log(bundle.getProperty("curam.util.exception.clicking"));
    }
  },
 
  /**
  * Handles click event on the page level print button.
  * Invokes the windows print function to print the context panel
  * and main content area.
  *
  * @param event the click event object.
  *
  */
  printPage:function(event) {
    
    dojoEvent.stop(event);
    
    var mainAreaWindow = dojo.window.get(event.currentTarget.ownerDocument);
    var mainAreaIframeNode = mainAreaWindow.frameElement;
    
    var searchNode = mainAreaIframeNode;
    
    // find the tab conent holder div which holds each tab.
    while(searchNode 
                    && !dojo.hasClass(searchNode, "tab-content-holder")){
            searchNode = searchNode.parentNode;
    }
    
    var tabContentHolderNode = searchNode;
    
    var contextPanel = dojo.query(".detailsPanelFrame", tabContentHolderNode)[0];
    
    if (contextPanel != undefined && contextPanel != null) {
      contextPanel.contentWindow.focus();
      contextPanel.contentWindow.print();
    }
    
    mainAreaWindow.focus();
    mainAreaWindow.print();
    
    return false;

  },
 
  /**
  * Handles onmousedown event on the page toolbar buttons.
  * Adds a class name of selected to allow for CSS selected effect.
  *
  * @param event the click event object.
  *
  */
  addSelectedClass:function(event) {
      domClass.add(event.target,"selected");
  },
 
  /**
  * Handles onmouseup event on the page toolbar buttons.
  * Removes class name of selected..
  *
  * @param event the click event object.
  *
  */
  removeSelectedClass:function(event) {
      domClass.remove(event.target,"selected");
  },
 
  /**
  * Opens up the page level help page in new window.
  *
  * @param event the mouse click event.
  * @param event the help tag.
  *
  */
  openHelpPage: function(event, helpUrl){
      dojoEvent.stop(event);
    //opens up the constructed URL in new window.
      dojo.global.open(helpUrl);
  },
 
  /**
  * Connects the handler to the specified event on the specified object
  * and ensures it is disconnected when the page is unloaded.
  *
  * @param object
  *    The object to connect to.
  * @param eventName
  *    Name of the event to connect to.
  * @param handler
  *    The handler for the event.
  *
  * @return The disconnect token to be used with curam.util.disconnect()
  *    function.
  */
  connect: function(object, eventName, handler) {
    // wrap in another function to allow fixing event before passsing
    // to the handler
    var h = function(event) {
        handler(dojoEvent.fix(event));
    };

      if (has("ie") && has("ie") < 9) {
      object.attachEvent(eventName, h);
 
        unload.addOnWindowUnload(function() {
        object.detachEvent(eventName, h);
      });
 
      return { object: object, eventName: eventName, handler: h };
 
    } else {
        // The dojo/on API takes event names without the "on" prefix.
        var eventNameWithoutOn = eventName;
        if (eventName.indexOf("on") == 0) {
          eventNameWithoutOn = eventName.slice(2);
        }
        var dt = on(object, eventNameWithoutOn, h);
   
        unload.addOnWindowUnload(function() {
          dt.remove();
      });
 
      return dt;
    }
  },
 
  disconnect: function(token) {
      if (has("ie") && has("ie") < 9) {
      token.object.detachEvent(token.eventName, token.handler);
      } else {
        token.remove();
    }
  },
 
  /**
  * Subscribes the handler to the specified topic in the current runtime
  * context and ensures it is unsubscribed when the page is unloaded.
  *
  * @param topicName
  *    Name of the topic to subscribe to.
  * @param handler
  *    The handler for the topic.
  */
  subscribe: function(topicName, handler) {
      var st = topic.subscribe(topicName, handler);
      unload.addOnWindowUnload(function() {
        st.remove();
    });
 
    return st;
  },
 
  unsubscribe: function(token) {
      token.remove();
  },
 
  /**
  * Retrieves all action controls in action set.
  *
  * @param panelId
  *   ID of action set element.
  */
  addActionControlClickListener:function(panelId){
      var actionsPanel = dom.byId(panelId);
      var actionControlList = query(".ac", actionsPanel);
    if (actionControlList.length > 0) {
      for(var i = 0; i < actionControlList.length; i++) {
        var acNode = actionControlList[i];
        curam.util.addActionControlClass(acNode);
      }
    }
  },
 
  /**
  * Adds a CSS class names to modal buttons that have been clicked.
  * This allows specific styling to be applied when buttons in a selected
  * state.
  *
  * @param acNode
  *    Modal action button node
  */
  addActionControlClass:function(acNode){
    curam.util.connect(acNode, "onmousedown",function(){
        domClass.add(acNode, "selected-button");
      curam.util.connect(acNode, "onmouseout",function(){
          domClass.remove(acNode, "selected-button");
      });
    });
  },
 
  /**
  * Gets all cluster level action sets contained in the content panel.
  *
  */
  getClusterActionSet:function(){
      var contentNode = dom.byId("content");
      var clusterActionSets = query(".blue-action-set", contentNode);
    if (clusterActionSets.length > 0){
      for (var i=0; i<clusterActionSets.length; i++) {
        curam.util.addActionControlClickListener(clusterActionSets[i]);
      }
    }
  },
 
  /**
  * Adjust Button spacing, if needed, to prevent them overlapping
  */
  adjustActionButtonWidth:function() {
      if (has("ie") == 8) {
        ready(function() {
          if (dojo.global.jsScreenContext.hasContextBits('MODAL')) {
            query(".action-set > a").forEach(function(node) {
            if(node.childNodes[0].offsetWidth > node.offsetWidth) {
                style.set(node, "width", node.childNodes[0].offsetWidth + "px");
                style.set(node, "display", "block");
                style.set(node, "display", "inline-block");
            }
          });
        }
      });
    }
  },
 
  /**
  * Sets the '__o3rpu' parameter for the URL. This parameter is an enocoded
  * value and holds the requesting URL and its parameters. This function may add
  * additonal parameters to the requesting URL prior to encoding it.
  *
  * @param {String} url
  *     The requested URL
  * @param {curam.util.RuntimeContext} rtc
  *     RunTimeContext Object - provides access to Window object.
  * @param {Array} [extraParaArray]
  *     An optional array of extra parametes to be added to the requesting URL.
  *     The expected array structure is
  *     [{key:"x1",value:"y1"},{key:"x2",value:"y2"},...]
  * @return The requested URL with the '__o3rpu' parameter appended.
  */
  setRpu:function(url, rtc, /*optional*/ extraParaArray){
    //Throw exception if null/blank values passed in
    if(!url||!rtc||!rtc.getHref()){
      throw {
        name:"Unexpected values",
        message:"This value not allowed for url or rtc"
      };
    }
 
    var o3rpuValue = curam.util.getLastPathSegmentWithQueryString(rtc.getHref());
 
    // strip the __o3rpu parameter from the RPU value
    o3rpuValue = curam.util.removeUrlParam(o3rpuValue, curam.util.Constants.RETURN_PAGE_PARAM);
 
    //Check for extra parameters passed in as {key:"",value:""} format
    if(extraParaArray){
      var i;
      for(i = 0; i < extraParaArray.length; i++) {
        if(!extraParaArray[i].key||!extraParaArray[i].value){
          throw {
            name:"undefined value error",
            message:"The object did not contain a valid key/value pair"
          };
        }
        o3rpuValue = curam.util.replaceUrlParam(o3rpuValue,
        extraParaArray[i].key, extraParaArray[i].value);
      }
    }
    var returnUrl = curam.util.replaceUrlParam(url, curam.util.Constants.RETURN_PAGE_PARAM, encodeURIComponent(o3rpuValue));
    curam.debug.log("curam.util.setRpu " 
      + bundle.getProperty("curam.util.added.rpu") + returnUrl);
    return returnUrl;
    },

    /**
     * Retrieves the base URL from the location.href property associated with 
     * the current DOM Window object.
     * <p>
     * The base URL is the contents of the URL up as far, and including, the
     * application name.
     * <p>
     * For example, if the value of location.href was 
     * "http://philippa:9080/TabTest/AppController.do" then the value returned
     * would be "http://philippa:9080/TabTest"
     * 
     * @return the base URL or null if the URL cannot be retrieved.
     *
     */
    retrieveBaseURL: function() {
      //The regular expression will match a path of the form 
      //[protocol]://[domain]/[name]. Where [protocol] can be any character
      //e.g. http. Where [domain] can be any character except for 
      //the forward slash character e.g. www.curamsoftware.com. Where [name] can 
      //be any character except for the forward slash character e.g. Curam.
      return dojo.global.location.href.match(".*://[^/]*/[^/]*");
    },
    
    removeRoleRegion:function(){
      var body = dojo.query("body")[0];
      dojo.removeAttr(body, "role");
    },
    
    /*
     * Function for iframe title fall back.
     * If PAGE_TITLE isn't specified in the UIM, this function takes care
     * of falling back to the navigation tab title or the application tab.
     */
    iframeTitleFallBack: function(){
      var currentiframe = curam.tab.getContainerTab(curam.tab.getContentPanelIframe());
      
      var iframe = dojo.byId(curam.tab.getContentPanelIframe());       
      var pageTitle = iframe.contentWindow.document.title;
      
      var currentAppTab = dojo.query("div.nowrapTabStrip.dijitTabContainerTop-tabs > div.dijitTabChecked.dijitChecked")[0];
      var currentAppTabName = dojo.query("span.tabLabel", currentAppTab)[0];
      
      var currentNavTab = dojo.query("div.nowrapTabStrip.dijitTabNoLayout > div.dijitTabChecked.dijitChecked", currentiframe.domNode)[0];
      var currentNavTabName = dojo.query("span.tabLabel", currentNavTab)[0];
      
      if(pageTitle && pageTitle!=null){
        return pageTitle;
      } else if (currentNavTab){
          return currentNavTabName.innerHTML;
      } else {
          return currentAppTabName.innerHTML;
      }
    },
    
    /**
     * Function to add a specific class to the last visible node (cluster, list
     * or action set) in the page content area. It only works specifically in
     * the external application.
     * 
     * @return There's no return value of this function.
     */
    addClassToLastNodeInContentArea: function() {
      var divNodes = query("> div", "content");
      var divNodesCount = divNodes.length;
      
      if (divNodesCount == 0) {
        return "No need to add";
      }
      
      var lastNode = divNodes[--divNodesCount];
      
      while (domClass.contains(lastNode, "hidden-action-set") && lastNode) {
        lastNode = divNodes[--divNodesCount];
      }
      
      domClass.add(lastNode, "last-node");
      
    },
    
    /*
     * Function to check Highcontrast mode
     * If High contrast mode is turned on the method checks the class name 
     * high-contrast on body element.
     */
    highContrastModeType: function(){      
      var highContrastMode = dojo.query("body.high-contrast")[0];
      return highContrastMode;
    },	
		  
	processBidiContextual: function (target){
		target.dir = bidi.prototype._checkContextual(target.value);			
	},
	
	getCookie: function(name) {
	    var dc=document.cookie;
	    var prefix=name+"=";
	    var begin=dc.indexOf("; "+prefix);
	    if(begin==-1) {
	      begin=dc.indexOf(prefix);
	      if(begin!=0)
	        return null;
	    } else {
	      begin+=2;
	    }
	    var end=document.cookie.indexOf(";",begin);
	    if(end==-1) {
	      end=dc.length;
	    }
	    return unescape(dc.substring(begin+prefix.length,end));
    }
  });

  return curam.util;
});

},
'idx/oneui/_EventTriggerMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

// This mix-in provides support for binding a widget to one or more DOM nodes 
// and being notified when specified events occur. Support for a "hover" trigger
// is also provided.

define("idx/oneui/_EventTriggerMixin", ["dojo/_base/array",
        "dojo/_base/declare",
        "dojo/_base/event",
        "dojo/_base/lang",
        "dojo/_base/window",
        "dojo/dom",
		"dojo/io/iframe",
        "dojo/mouse",
        "dojo/on",
        "dojo/window",
        "dijit/_MenuBase"],
        function(array,
                 declare,
                 event,
                 lang,
                 window,
                 dom,
				 iframe,
                 mouse,
                 on,
                 winUtils,
                 _MenuBase){
    
	// Ensure we're not relying on the old globals, ready for 2.0.
	var dojo = {}, dijit = {};

	/**
	 * Creates a new idx.oneui._EventTriggerMixin
	 * @name idx.oneui._EventTriggerMixin
	 * @class This mix-in provides support for binding a widget to one or more
	 * DOM nodes and being notified when specified events occur. Support for a
	 * "hover" trigger is also provided.
	 */
	return declare("idx.oneui._EventTriggerMixin", null, 
	/** @lends idx.oneui._EventTriggerMixin.prototype */
	{
		/**
		 * An array of "binding" objects that store details of the event
		 * triggers that are currently bound to trigger nodes.
		 * @type Object[]
		 */
		_bindings: null,
    
		/**
		 * A timer that is started at the beginning of a hover event and
		 * triggers the calling of onTrigger() after hoverDuration, unless it
		 * is cancelled.
		 * @type timer handle
		 */
		_hoverTimer: null,
    
		/**
		 * The time in milliseconds that the mouse needs to remain within a DOM
		 * node in order to cause a "hover" event to be reported. Initialised
		 * to match the hover delay used by menus.
		 * @type number
		 */
		hoverDuration: _MenuBase.prototype.popupDelay,
    
		/**
		 * Constructor.
		 * @private
		 */
		constructor: function(){
			this._bindings = [];
		},

		/**
		 * Register a DOM node to act as an event trigger. When the specified
		 * event is detected, the "_onTrigger" method is called, passing a
		 * trigger object containing contextual and event information as the
		 * single argument. The fields in the trigger object are as follows:
		 * <ul>
		 * <li>
		 * triggerNode: {DOMNode} the DOM node that triggered the event
		 * </li>
		 * <li>
		 * eventName: {string} the name of the event (as passed as eventName)
		 * </li>
		 * <li>
		 * event: {Event} the event object (in the case of "hover", this will be
		 * the most recent mouse.enter or mousemove event received
		 * </li>
		 * <li>
		 * additionalData: {Object} the additional data object supplied as additionalData
		 * </li>
		 * </ul>
		 * @param {string | DOMNode} triggerNode The DOM node or node ID that
		 * trigger events are to be detected on.
		 * @param {string} eventName The name of the event to be detected.
		 * As well as regular dojo events the value "hover" can also be used
		 * to configure a hover trigger.
		 * @param {function(params)} filterCallback An optional filter callback
		 * function that can be used to limit the events that are detected.
		 * If the function returns true the event is considered to be a
		 * trigger otherwise it is ignored. The same params object is supplied
		 * to the filter callback that will be passed to the _onTrigger method
		 * if the filter callback returns true. 
		 * @param {Object} additionalData Optional application-specific data
		 * that will be returned when an event is detected.
		 */
		_addEventTrigger: function(triggerNode, eventName, filterCallback, additionalData) {
 			// Resolve node ID (if passed as parameter) and validate DOM node.
			triggerNode = dom.byId(triggerNode);
			if(!triggerNode){
				require.log("ERROR: oneui._EventTriggerMixin._addEventTrigger(): Invalid triggerNode parameter.");
				return;
			}

			// a utility function to check the filter and call onTrigger
			// using data in the closure, hitched this, and a passed event			
			var trigger = lang.hitch(this, function(event){
				var params = { triggerNode: triggerNode, eventName: eventName, event: event, additionalData: additionalData }
				
				// If a filter callback is not defined or it returns true then
				// trigger the event. Otherwise ignore it.
				if (!filterCallback || filterCallback(params)) {
					this._onTrigger(params);
				}
			});
			
			// A utility function to create a 'hover' pseudo-event from real
			// mouse events.
			var createHoverEvent = function(event){
				return {
					type: "hover",
					pageX: event.pageX,
					pageY: event.pageY,
					screenX: event.screenX,
					screenY: event.screenY,
					clientX: event.clientX,
					clientY: event.clientY
				};
			};
      
			// store a binding object per call, containing:
			//   triggerNode: the node we attach a listener/listeners to
			//   connectHandles: an array of currently attached listeners
			//   hoverDuration: if eventName=="hover", the hover duration in ms
			//   hoverTimer: the handle to any currently-running hover timer
			//   bindFunction: a function that attaches the required listener(s)
			//   unbindFunction: a function that removes the listener(s)
			//   iframeOnLoadHandler: if triggerNode is an iframe, a function
			//                         that reattaches the listeners on iframe load
			var binding = { triggerNode: triggerNode, connectHandles: [] }
			
			if(eventName == "hover"){
				binding.hoverDuration = this.hoverDuration;
				binding.hoverTimer = null;
			} 
			
			// Create a function that implements the necessary binding logic.
			binding.bindFunction = function(){
      
				// Determine which node to connect event listeners to, which may need to 
				// be different to the specified trigger node.
				var connectNode;
				if(triggerNode.tagName == "IFRAME"){
					// If the trigger node is an iFrame then we need to attach event 
					// listeners to the <body> element of the iFrame's contents. 
					try{
						var iframeDocNode = iframe.doc(triggerNode);
						connectNode = iframeDocNode ? iframeDocNode.body : null;
					}catch(e){
						require.log("ERROR: oneui._EventTriggerMixin._addEventTrigger(): Error accessing body of document within iframe. " + e);
					}
				}else{
					// Normal trigger node specified - just attach event listeners to it.
					connectNode = triggerNode;
				}
				
				if(!connectNode){
					require.log("ERROR: oneui._EventTriggerMixin._addEventTrigger(): Unable to determine node to attach event listener(s) to.");
					return;
				}
				
				// If the event is "hover" then attach specific event listeners and 
				// callbacks to synthesise it, otherwise just attach the specified
				// event listener.
				if(eventName == "hover"){
					var hoverEvent = null;
					
					// Connect mouseenter and mouseleave event listeners to the 
					// connection node to start/clear the hover timer. Trigger
					// if/when the timer expires. Keep track of the mouse recent
					// mouse event too.
					binding.connectHandles.push(on(connectNode, mouse.enter, lang.hitch(this, function(event){
						hoverEvent = createHoverEvent(event);
						
						// there shouldn't be a running timer, but clear it if there is
						if(binding.hoverTimer){
							clearTimeout(binding.hoverTimer);
						} 
						
						// the hoverEvent may be replaced by the time the hover timer fires
						binding.hoverTimer = setTimeout(function(){ trigger(hoverEvent); }, binding.hoverDuration);
					})));
					
					binding.connectHandles.push(on(connectNode, mouse.leave, lang.hitch(this, function(event){
						if(binding.hoverTimer){
							clearTimeout(binding.hoverTimer);
							binding.hoverTimer = null;
						}
						hoverEvent = undefined;
					})));
					
					binding.connectHandles.push(on(connectNode, "mousemove", function(event){
						hoverEvent = createHoverEvent(event);
					}));
					
				}else{
					// Connect the appropriate event listener to the connect node.
					binding.connectHandles.push(on(connectNode, eventName, function(event){ trigger(event); }));
				}
			}
			
			// Create a disconnect function that removes all the event listeners.
			binding.unbindFunction = function(){
				array.forEach(binding.connectHandles, function(conn){ conn.remove(); });
				
				if(binding.hoverTimer){
					clearTimeout(binding.hoverTimer);
					binding.hoverTimer = null;
				}
			}
			
			// If the trigger node is an iframe then add an onload listener to it, 
			// with a callback that rebinds the handlers to the iframe content if 
			// it changes. Store the connect handle in the binding, so that it can
			// be cleaned up.
			if(triggerNode.tagName === "IFRAME"){
				binding.iframeOnLoadHandler = function(event){
					// Remove all existing event listeners.
					try{
						// This may fail because the iframe content node that the event
						// listeners are bound to has been destroyed.
						binding.unbindFunction();
					}catch(e){
						// Ignore failures - 'best efforts' cleanup.
					}

					// Rebind all of the event listeners to the iframe and new content 
					// document.
					binding.bindFunction();
				}
				
				if(triggerNode.addEventListener){
					triggerNode.addEventListener("load", binding.iframeOnLoadHandler, false);
				}else{
					triggerNode.attachEvent("onload", binding.iframeOnLoadHandler);
				}
			}

			// store the binding data, and call the bind function once now
			this._bindings.push(binding);
			binding.bindFunction(); 
		},

		/**
		 * Callback that is called whenever one of the specified trigger
		 * events (as configured via _addEventTrigger()) is detected on
		 * a DOM node.
		 * @param {Object} trigger An object that describes the triggering 
		 * event. The fields in the trigger object are as follows:
		 * <ul>
		 * <li>
		 * triggerNode: {DOMNode} the DOM node that triggered the event
		 * </li>
		 * <li>
		 * eventName: {string} the name of the event
		 * </li>
		 * <li>
		 * event: {Event} the event object (in the case of "hover", this will be
		 * a pseudo-event with properties of clientX, clientY, pageX, pageY, 
		 * screenX, screenY set when the data is available from the original 
		 * event, and type set to 'hover').
		 * </li>
		 * <li>
		 * additionalData: {Object} the additional data object supplied as
		 * additionalData via _addEventTrigger()
		 * </li>
		 * </ul>
		 */
		_onTrigger: function(trigger) {
			// summary:
			//   Callback that is called whenever one of the specified trigger events
			//   (as configured via _addEventTrigger()) is detected on a DOM node.
			//
			// parameters:
			//   trigger: Object
			//     an object containing data about the event.
			//
			//         triggerNode: DOMNode
			//           the DOM node that the trigger event was detected on.
			//
			//         eventName: String
			//           the name of the event that was detected.
			//
			//         event: Event
			//           the dojo event object describing the event.
			//
			//         additionalData: Object
			//           optional application-specific data that may have been 
			//           supplied when the event trigger was configured via
			//           _addEventTrigger().
			//
			// returns: nothing.
		},
    
		/**
		 * Deregisters a DOM node as an event trigger, by removing all the 
		 * event triggers that have been configured via _addEventTrigger().
		 * @param {string | DOMNode} triggerNode The DOM node or node ID that
		 * trigger events are no longer to be detected on. If undefined or
		 * null all event triggers for all nodes are unbound.
		 */
		_removeEventTriggers: function(triggerNode) {

			// Resolve node ID (if passed as parameter) and validate DOM node.
			if(triggerNode){
				triggerNode = dom.byId(triggerNode);
			}
      
			// Iterate through the array of bindings, unbind the appropriate ones,
			// and remove the binding records.
			for(var i = this._bindings.length - 1; i >= 0; i--){
				var binding = this._bindings[i];
				
				if(!triggerNode || (triggerNode === binding.triggerNode)){
					binding.unbindFunction();
					if(binding.iframeOnLoadHandler){
						if(binding.triggerNode.removeEventListener){
							binding.triggerNode.removeEventListener("load", binding.iframeOnLoadHandler, false);
						}else{
							binding.triggerNode.detachEvent("onload", binding.iframeOnLoadHandler);
						}
					}
					this._bindings.splice(i, 1);
				}
			}
		}
		
	});
});
	
},
'curam/dialog':function(){
/*
 * Copyright 2012-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define("curam/dialog", ["curam/util",
        "curam/debug",
        "curam/util/external",
        "curam/util/Refresh",
        "curam/tab",
        "curam/util/RuntimeContext",
        "curam/define",
        "curam/util/onLoad",
        "cm/_base/_dom",
        "curam/util/ResourceBundle"
        ], function(util, trace, external) {

/*
 * Modification History
 * --------------------
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.
 * 10-Jul-2013  KW  [CR00391894] Remove reference o3_artificial_post parameter.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 11-Mar-2013  MV  [CR00373738] Remove change to close dialog when page
 *    is loaded. We'll do it differently in curam/ModalDialog.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 24-Sep-2012  MV  [CR00345119] Revert the change to the function used for
 *      detecting when page unloads in a modal.
 * 24-Jul-2012  MK  [CR00336401] Wrapped contents of the closeModalDialog
 *    method in dojo.ready to prevent it closing the model before the page has
 *    finished loading.
 * 07-Feb-2012  MV  [CR00301458] Code cleanup.
 * 15-Sept-2011 MK  [CR00287680] Change the function that is used to detect a 
 *      page unloading in a modal. Changing from addOnUnload to addOnWindowUnload
 * 02-Aug-2011  MV  [CR00283023] Refactored modalEventHandler to allow
 *      unit testing. Avoid unwanted refresh when parent is an Action.do page.
 * 29-Jul-2011  MV [CR00269970] Add support for refreshing based on submit with
 *      inline page as parent. 
 * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
 *                    panel on submit.
 * 28-Jan-2011  MV  [CR00245381] Catch Access denied error when accessing
 *    external sites.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 13-Jan-2011  MV  [CR00241667] Fire event when the dialog infrastructure
 *    is ready.
 * 05-Jan-2011  SK  [CR00239843] Previous page id parameter is not added any
 *                  longer to the form submits from Agenda Player.
 * 12-Jan-2011  SK  [CR00241719] Added the option to close modal without
 *                               the parent redirect.
 * 29-Nov-2010  MV  [CR00232623] Add in a hack to properly unregister a handler
 *    on page unload when using agenda player.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 19-Nov-2010 MV [CR00231655] Store the display status and dialog size
 *     in the runtime context.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 27-Oct-2010  MV  [CR00224488] Refactor for the dialog closing to work well
 *    with new HTML structure.
 * 26-Oct-2010  SK  [CR00224193] The situation where the dialog is opened from
 *                               non-page parent is now handled correctly.
   * 14-Oct-2010  MV  [CR00223441] Move functions to util namespace. Remove
 *    double invoking of a function.
 * 07-Oct-2010  MV  [CR00221605] Refactor for dialogs to work with the generic
 *    key handler that submits the page when Enter is pressed.
 * 17-Sep-2010  MV  [CR00220607] Removed a dead branch of code.
 * 27-Aug-2010  MV  [CR00217499] Refactored to remove hacks previously needed
 *                    to support the agenda player. Documentation comments
 *                    switched to jsdoc.
 * 21-Jul-2010  MV  [CR00211225] Indicate in the `onLoad` context that modal
 *                    is closing.
 * 24-Jun-2010  AF  [CR00202526] Removing reference to content-panel class name
 *                               in the calculateHeightByContents method.
 * 24-Jun-2010  MV  [CR00203864] Add debug output to autoheight calculation.
 * 09-Jun-2010  MV  [CR00202971] Remove the curam.iframeLoaded event,
 *                               add the height calculation function.
 * 04-Jun-2010  MV  [CR00202412] Simplify getting event identifier.
 * 23-Apr-2010  MV  [CR00194352] Fix screen context handling for HTML forms.
 * 11-Feb-2010  MV  [CR00188844] Add event identifier to the iframeLoaded event.
 * 11-Dec-2009  MV  [CR00173949] Remove the "SrPopUp" window name.
 * 24-Nov-2009  MV  [CR00175899] Only call the closeModal function if there
 *                                are no informational messages.
 * 20-Nov-2009  MV  [CR00175581] Replace curam.tab.refreshCurrentTab() call
   *                               with the correct util.redirectWindow().
   * 20-Nov-2009  MV  [CR00175615] Use the util.firePageSubmittedEvent
 *                                function.
 * 03-Sep-2009  MLB [CR00164883] Updated to refresh the current tab for user
 *                  preferences.
 * 07-Aug-2009  MV  [CR00164029] Notify the tabbed UI refresh mechanism
                                on submit. Reverted the previous change as now
                                the refresh is working as expected.
 * 23-Jul-2009  MV  [CR00162771] Updated to not refresh parent window when
 *                  in Tabbed UI.
 */

/**
 * Creating Resource Bundle Object to access localized resources.
 */
dojo.requireLocalization("curam.application", "Debug");
var bundle = new curam.util.ResourceBundle("Debug");
  
/**
 * @namespace Functions related to the Curam dialog support for UIMs.
 */
curam.define.singleton("curam.dialog", {
  MODAL_PREV_FLAG: "o3modalprev",
  MODAL_PREV_FLAG_INPUT: "curam_dialog_prev_marker",
  FORCE_CLOSE: false,
  ERROR_MESSAGES_HEADER: "error-messages-header",

  /**
   * Keeps track of the hierarchy of window objects for the open dialogs.
   * @private
   */
  _hierarchy: [],

  /**
   * ID of the dialog for the current context.
   * @private
   */
  _id: null,

  /**
   * @private
   */
  _displayedHandlerUnsToken: null,

  /**
   * True if the dialog has been displayed, false otherwise.
   * @private
   */
  _displayed: false,

  /**
   * Holds the current size of the dialog or null if it was not yet published.
   * @private
   */
  _size: null,

  /**
   * Indicates if the dialog should close without the parent redirection. 
   * @private
   */
  _justClose: false,

  validTargets: {
    "_top":true,"_self":true
  },

  initModal: function(pageId, messagesExist) {
    curam.dialog.pageId = pageId;
    curam.dialog.messagesExist = messagesExist;

      var topWin = util.getTopmostWindow();
    // receive the ID of the dialog
    var isIdSet = false;
    var unsToken = topWin.dojo.subscribe(
        "/curam/dialog/SetId", this, function(dialogId) {
            trace.log("curam.dialog: " 
              + bundle.getProperty("curam.dialog.id"), dialogId);
          curam.dialog._id = dialogId;
          isIdSet = true;

          topWin.dojo.unsubscribe(unsToken);
        });

    // trigger the dialog infrastructure init
    // also sets the dialog ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!isIdSet) {
      // unsubscribe, the modal infrastructure already initialized
      // or nobody listening for this particular event
        trace.log("curam.dialog: " + bundle.getProperty("curam.dialog.no.id"));
      topWin.dojo.unsubscribe(unsToken);
    }

    if(curam.dialog.closeDialog(false)) {
      // Do not do any more modal processing. Either the body is hidden off to
      // the left of the screen and messages are being displayed, or the window
      // has been closed.
      return;
    }

    // let us know when we are displayed
    curam.dialog._displayedHandlerUnsToken =
          util.getTopmostWindow().dojo.subscribe(
        "/curam/dialog/displayed", null, function(dialogID, size) {
          if (dialogID == curam.dialog._id) {
            curam.dialog._displayed = true;
            curam.dialog._size = size;

              util.getTopmostWindow().dojo.unsubscribe(
                curam.dialog._displayedHandlerUnsToken);
            curam.dialog._displayedHandlerUnsToken = null;
          }
        });
    // a hack to unsubscribe for agenda pages
    if (jsScreenContext.hasContextBits("AGENDA")
        || jsScreenContext.hasContextBits("TREE")) {

      dojo.addOnUnload(function() {
          util.getTopmostWindow().dojo.unsubscribe(
            curam.dialog._displayedHandlerUnsToken);
        curam.dialog._displayedHandlerUnsToken = null;
      });
    }

    //Wait for the page to load, then add onClick and onKey listeners to the
    //body element
    dojo.addOnLoad(function() {
      // Handle clicks in the dialog window
        util.connect(dojo.body(), "onclick", curam.dialog.modalEventHandler);

      // setup the forms in the page
      for (var i = 0; i < document.forms.length; i++) {
        var form = document.forms[i];
        curam.dialog.addFormInput(form, 'hidden', 'o3frame', 'modal');

        var ctxField = dojo.byId('o3ctx');
        var sc = new curam.util.ScreenContext(jsScreenContext.getValue());
        sc.addContextBits("ACTION|ERROR");
        ctxField.value = sc.getValue();

          util.connect(form, "onsubmit", curam.dialog.formSubmitHandler);
      }

      // mark as modal window - for later detection
        // by util.isModalWindow()
      window.curamModal = true;
    });

    dojo.addOnUnload(function() {
        util.getTopmostWindow().dojo.publish(
          "/curam/dialog/iframeUnloaded", [ curam.dialog._id, window ]);
    });

    if (isIdSet) {
      dojo.publish("/curam/dialog/ready");
    }
  },

  closeDialog: function(force) {
    if(force) {
      curam.dialog.forceClose();
    }
    var closeFunction = curam.dialog.checkClose(curam.dialog.pageId);
    if(closeFunction) {
        util.onLoad.addPublisher(function(context) {
        context.modalClosing = true;
      });

      //If the dialog window should close, but informational messages exist,
      //delay the closing of the window. Add a class to the messages to make
      //them visible, and place a button under them to close the window.action
      //If no messages exist, then just close the window, and optionally
      //redirect the parent page.
      if(curam.dialog.messagesExist) {
        dojo.addOnLoad(function(){
            var errMsgContainer = dojo.byId(util.ERROR_MESSAGES_CONTAINER);
            var errMsgNode = dojo.byId(util.ERROR_MESSAGES_LIST);
          var errMsgHeaderNode = dojo.byId(curam.dialog.ERROR_MESSAGES_HEADER);

          if(errMsgNode && errMsgHeaderNode) {
            //Save the messages locally, to be loaded by the next page that loads
            //which should be the parent page. The closeFunction is called
            //once the messages have been saved.
              util.saveInformationalMsgs(closeFunction);

            //Disable loading of informational messages in the popup,
            //so it doesn't run. This prevents a race condition which would wipe
            //out the messages before the parent page loads.
              util.disableInformationalLoad();

          } else {
            closeFunction();
          }
        });

      } else {
        //If no error messages exist, just run the close function.
        closeFunction();
      }
      //Return true, stating that the dialog is closing.
      return true;
    }
    //Return false, that the dialog is not closing.
    return false;
  },

  addFormInput: function(form, type, name, value) {
    return dojo.create("input", {
      "type": type,
      "name": name,
      "value": value
    }, form);
  },

  /**
   * Checks if the window should be closed. If the window should close, this
   * function returns another function which, when executed, closes the dialog,
   * and optionally redirects the parent page. If the window should not close,
   * it returns false.
   */
  checkClose: function(pageId) {
    if (curam.dialog._justClose) {
      return function() {
        curam.dialog.closeModalDialog();
      };
    }
	
    var parentWindow = curam.dialog.getParentWindow(window);
    if (!parentWindow) {
      return false;
    }

    //Check if the page is in a modal dialog, and if it is, whether or not
    //it should be closed.
    var href = window.location.href;
    var prevFlag = curam.dialog.MODAL_PREV_FLAG;

      var oldPageId = util.getUrlParamValue(href, prevFlag);
    var doClose = true;
    if (oldPageId) {
      if (parentWindow) {
        // If the URL parameter MODAL_PREV_FLAG is set, and is not the same
        // as the current page id, then shut down the dialog and redirect
        // the parent page the current URL. Remove the MODAL_PREV_FLAG
        if(oldPageId == pageId) {
          doClose=false;
        }
      }
    
    } else {
      doClose = false;
    }

      var scReq = util.getUrlParamValue(href, "o3ctx");
    if (scReq) {
      var sc = new curam.util.ScreenContext();
      sc.setContext(scReq);
      if (sc.hasContextBits('TREE|ACTION')) {
        doClose=false;
      }
    }

    if (doClose || curam.dialog.FORCE_CLOSE) {
      if (!curam.dialog.FORCE_CLOSE) {
        if (oldPageId=="user-prefs-editor") {
          return function() {
            if (parentWindow && parentWindow.location
                               !== util.getTopmostWindow().location) {
              curam.dialog.doRedirect(parentWindow);
            }
            curam.dialog.closeModalDialog();
          };
        }
        return function() {
            var rp = util.removeUrlParam;
          // Remove the modal and prevent cache flags from the url
          // before telling the parent to change it's location.
            href = rp(rp(rp(href, prevFlag), "o3frame"),util.PREVENT_CACHE_FLAG);
            href = util.adjustTargetContext(parentWindow, href);
          if (parentWindow && parentWindow.location
                                 !== util.getTopmostWindow().location) {
            curam.dialog.doRedirect(parentWindow, href, true);

          } else {
            curam.tab.getTabController().handleLinkClick(href);
          }
          curam.dialog.closeModalDialog();
        };

      } else {
        return function() {
          // In case there are some informational messages on the modal dialog,
          // make sure they are loaded in to the parent page, even if it
          // isn't refreshed.
            if (parentWindow !== util.getTopmostWindow()) {
            parentWindow.curam.util.loadInformationalMsgs();
          } //otherwise nowhere to show them
          
          curam.dialog.closeModalDialog();
        };
      }
    }
    return false;
  },

  /**
   * Returns the parent window of either the current window or of the specified
   * window.
   *
   * @param {window} [child] If specified, the dialog hierarchy will be used
   *      to look up the parent window.
   */
  getParentWindow: function(/*optional*/child) {
    if (!child) {
        trace.log("curam.dialog.getParentWindow(): " 
          + bundle.getProperty("curam.dialog.no.child"), window);
        trace.log("returning as parent = ", window.parent.location.href);
      return window.parent;
    }
      trace.log("curam.dialog.getParentWindow(): " 
        + bundle.getProperty("curam.dialog.child"), child.location.href);
    var hierarchy = curam.dialog._getDialogHierarchy();
    for (var i = 0; i < hierarchy.length; i++) {
      if (hierarchy[i] == child) {
        // the child found in the stack, parent is at the previous index
        var realParent = (i > 0) ? hierarchy[i - 1] : hierarchy[0];
          trace.log("curam.dialog.getParentWindow(): " 
            + bundle.getProperty("curam.dialog.parent.window"), realParent);
        return realParent;
      }
    }
    // the child NOT found in the stack
      trace.log("curam.dialog.getParentWindow(): " 
        + bundle.getProperty("curam.dialog.child.not.found"), 
        child.location.href);
      trace.log("curam.dialog.getParentWindow(): " 
        + bundle.getProperty("curam.dialog.hierarchy"), hierarchy);
    var ret = hierarchy.length > 0 ? hierarchy[hierarchy.length - 1] : undefined;
      trace.log("curam.dialog.getParentWindow(): " 
        + bundle.getProperty("curam.dialog.returning.parent"), 
          ret ? ret.location.href : "undefined");
    return ret;
  },

  /**
   * Dialog hierarchy is a way for the code to keep track of parent/opener
   * windows for the open modal dialogs. The window.parent property
   * cannot be used for this purpose, because for dojo dialogs it is always
   * pointing at the same parent window, so it does not reflect the real
   * dialog hierarchy.
   *
   * The hierarchy is implemented as a simple stack of consecutive window
   * objects.
   *
   * @returns Array The hierarchy of window objects.
   * @private
   */
  _getDialogHierarchy: function() {
    // the hierarchy is stored in the topmost window - the truly global context
      var topmostWindow = util.getTopmostWindow();
      topmostWindow.require(["curam/dialog"]);
    return topmostWindow.curam.dialog._hierarchy;
  },

  /**
   * Pushes the specified window onto the dialog hierarchy stack,
   * unless the window is already part of the stack.
   */
  pushOntoDialogHierarchy: function(newParent) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if (dojo.indexOf(hierarchy, newParent) < 0) {
      hierarchy.push(newParent);
        trace.log(bundle.getProperty("curam.dialog.add.hierarchy"), 
          newParent.location.href);
        trace.log(bundle.getProperty("curam.dialog.full.hierarchy"), hierarchy);
    }
  },

  /**
   * Removes the specified window from the dialog hierarchy stack.
   *
   * @param child The window object to remove from the dialog hierarchy.
   */
  removeFromDialogHierarchy: function(child) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if(!child || hierarchy[hierarchy.length - 1] == child) {
      hierarchy.pop();

    } else {
        trace.log("curam.dialog.removeFromDialogHierarchy(): " 
          + bundle.getProperty("curam.dialog.ignore.request"));
      try {
          trace.log(child.location.href);
      
      } catch(e) {
        // in scenarios where we open external site in a dialog, this call
        // causes Access denied exception - we just  catch it and continue
          trace.log(e.message);
      }
    }
  },

  stripPageOrActionFromUrl: function(url) {
    var idx = url.lastIndexOf("Page.do");
    var len = 7;
    if(idx < 0) {
      idx = url.lastIndexOf("Action.do");
      len = 9;
    }
    if(idx < 0) {
      idx = url.lastIndexOf("Frame.do");
      len = 8;
    }
    if(idx > -1 && idx == url.length - len){
      return url.substring(0, idx);
    }
    return url;
  },

  /**
   * @private
   * 
   * @param href
   * @param rtc
   * @param stripPageOrAction
   * @returns {Boolean}
   */
  _isSameBaseUrl: function(href, rtc, stripPageOrAction) {
    if(href && href.indexOf('#') == 0){return true;}
    var hrefSplit = href.split("?");
    var hereSplit = rtc.getHref().split("?");

    //If one url is relative, and the other is absolute, compensate by removing
    //everything except what's after the last "/"
    if(hrefSplit[0].indexOf("/") < 0) {
      var parts = hereSplit[0].split("/");
      hereSplit[0] = parts[parts.length -1];
    }
    if(hereSplit[0].indexOf("/") < 0) {
      var parts = hrefSplit[0].split("/");
      hrefSplit[0] = parts[parts.length -1];
    }

    if (stripPageOrAction && stripPageOrAction == true) {
      hrefSplit[0] = curam.dialog.stripPageOrActionFromUrl(hrefSplit[0]);
      hereSplit[0] = curam.dialog.stripPageOrActionFromUrl(hereSplit[0]);
    }

    if(hrefSplit[0] == hereSplit[0]){
      return true;
    }

    return false;
  },

  modalEventHandler: function(event) {
    curam.dialog._doHandleModalEvent(event,
        new curam.util.RuntimeContext(window),
        curam.dialog.closeModalDialog,
        curam.dialog.doRedirect);
  },
  
  /**
   * Hanldes the specified event.
   * 
   * @param e The event to handle.
   * @param rtc Runtime context.
   * @param closeDialog The function to be called to close the dialog.
   * @param doRedirect The function to be called to redirect the parent window
   *    to a new location.
   * @returns {Boolean} True if the event should continue, false if it should
   *    be stopped.
   */
  _doHandleModalEvent: function(e, rtc, closeDialog, doRedirect) {
    var target = e.target;
      var u = util;

    switch(target.tagName) {
      case 'INPUT':
        // If the user clicks a submit control, copy its "keepModal" attribute
        // on to the form it is in so that can be read by the onSubmit handler
        if(dojo.attr(target, "type") == "submit"
            && typeof target.form != "undefined") {

          target.form.setAttribute("keepModal", target.getAttribute("keepModal"));
        }
        return true;

      case 'IMG': case 'SPAN': case 'DIV':
        target = cm.getParentByType(target, 'A');
        if (target == null) {
          return;
        }
        //If the IMG, SPAN or DIV node has an anchor tag parent, leave it run
        //into the 'A' case after changing the target to the parent anchor tag.
      case 'A':
      //If the target is an anchor tag, just get out of the switch statement
        //and keep going in the function, unless the anchor tag is a
        //dynamically generated tag used to replace a submit button.
          //This replacement is done in util.replaceSubmitButton function.
        if(target._submitButton) {
          target._submitButton.form.setAttribute("keepModal",
                                target._submitButton.getAttribute("keepModal"));
          return;
        }
        break;
      default:
        //If we're not interested in this tag, ignore the event
        return true;
    }
    var stopEvent = dojo.stopEvent;

    var href = target.getAttribute("href");

    // handling the case of a cancel link where there is no o3rpu
    if (href == '') {
      closeDialog();
      return false;
    }

    if (href.indexOf("javascript") == 0) {
      return false;
    }
    var ctx = jsScreenContext;
    ctx.addContextBits('MODAL');

    // If the anchor tag does not have a href, we simply cancel the event.
    // Any onlick handlers attached directly to the anchor element will have
    // completed by the time this handler is called.
    if (!href) {
      return false;
    }

    //If the anchor tag is trying to open a new window, open it separately,
    //and do not change this page, or redirect the parent
    var targetWindow = target.getAttribute("target");
    if(targetWindow && !curam.dialog.validTargets[targetWindow]) {
      return true;
    }
    //Make sure that file download links do not close the modal dialog.
    //Instead, create an iframe on the fly, and set it's source to the file
    //that is to be downloaded.
    if(href && href.indexOf("/servlet/FileDownload?") > -1) {
      var iframe = dojo.create("iframe", {
        src: href
      }, dojo.body());
      iframe.style.display = 'none';
      stopEvent(e);
      return false;
    }

    //If the link is to a URL outside the Curam application, open the link in
    //a new window.
    if(dojo.hasClass(target, "external-link")) {
      return true;
    }

    // If the link is not going to result in the page changing,
    // then do nothing
      if(util.isSameUrl(href, null, rtc)) {
      // If the link is not simply linking in this page, then redirect the page.
      // otherwise just let the page jump to the local anchor tag.
      if(href.indexOf("#") < 0) {
         href = u.replaceUrlParam(href, "o3frame", "modal");
         href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
         doRedirect(window, href);
         return false;
      }
      return true;
    }
    if(href && curam.dialog._isSameBaseUrl(href, rtc, true)
        && !target.getAttribute("keepModal")){

      target.setAttribute("keepModal", "true");
    }

    var parentWindow = curam.dialog.getParentWindow(rtc.contextObject());
    
    if(target && target.getAttribute) {
      stopEvent(e);

      //If the link has the 'keepModal' attribute set to true, then
      // the new page should be opened in the same modal dialog.
      if(target.getAttribute("keepModal") == "true") {
        href = u.replaceUrlParam(href, "o3frame", "modal");
        href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
        doRedirect(window, href);

      // Otherwise the dialog will close and target will be opened in the parent
      // page
      } else if(parentWindow) {
        href = u.removeUrlParam(href, "o3frame");
        href = u.removeUrlParam(href, curam.dialog.MODAL_PREV_FLAG);
        
        if (parentWindow.location !== util.getTopmostWindow().location) {
          var parentRtc = new curam.util.RuntimeContext(parentWindow);
          var phref = parentRtc.getHref(); 
          phref = u.removeUrlParam(phref, "o3frame");
          
          // only redirect if the parent window is not already on the target
          // page 

          // for submitted action pages in the parent window only comapare
          // the base URL, ignoring any page parameters, because they are not
          // included in the Action.do type URL anyway
          if (util.isActionPage(phref)) {
            if (!curam.dialog._isSameBaseUrl(href, parentRtc, true)) {
              href = u.adjustTargetContext(parentWindow, href);
              doRedirect(parentWindow, href);
            }
            
          // for all other pages compare full URLS and only redirect if
          // the same page is not already loaded
          } else {
            if (!util.isSameUrl(href, phref)) {
              href = u.adjustTargetContext(parentWindow, href);
              curam.dialog.doRedirect(parentWindow, href);
            }
          }
        
        } else {
          //no tab opened
          var tabContext = new curam.util.ScreenContext('TAB');
          href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
          curam.tab.getTabController().handleLinkClick(href);
        }

        closeDialog();
      }

      return false;
    }

    if (parentWindow && typeof(target) == "undefined" || target == null
      || target == "_self" || target == "") {
      stopEvent(e);
      href = href.replace(/[&?]o3frame=modal/g, "")
        .replace("%3Fo3frame%3Dmodal", "")
        .replace("?o3frame%3Dmodal", "");
      //modal closes, so the context should be replaced by the previous.
        href = util.updateCtx(href);
        if (parentWindow.location !== util.getTopmostWindow().location) {
        doRedirect(parentWindow, href);
      
      } else {
        //no tab opened
        var tabContext = new curam.util.ScreenContext('TAB');
        href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
        curam.tab.getTabController().handleLinkClick(href);
      }
      
      closeDialog();
      return false;
    }

    //In this case, the page wants to open a popup window
    return true;
  },

  /**
   * This listener handles the onSubmit event of all forms on the page.
   * It adds the current page ID to the URL as the 'oldPageId' parameter
   * and if the window should be closed, it adds the 'MODAL_PREV_FLAG=true'
   * parameter to the URL.
   */
  formSubmitHandler: function(e) {
    var parentWindow = curam.dialog.getParentWindow(window);
    if(typeof parentWindow == "undefined") {
      return true;
    }

    e.target.method="post";
    e.target.setAttribute("target", window.name);
    var action = e.target.action;

    var prevFlag = curam.dialog.MODAL_PREV_FLAG;
    var flagInputId = curam.dialog.MODAL_PREV_FLAG_INPUT;
      var u = util;

    // If the input has previously been written to the form, delete it.
    // This is to handle multiple submissions, which can happen if an exception
    // is thrown during submission.
    var input = dojo.byId(flagInputId);
    if(input) {
      input.parentNode.removeChild(input);
    }

    // Set the page id in the url if the following page should close the modal
    // dialog if the id has changed. Add a hidden input to the form too, which
    // will be used if the form is a multi-part post containing a file.
    if(e.target.getAttribute("keepModal") != "true"
         && !jsScreenContext.hasContextBits('AGENDA')) {
      var multipart = 'multipart/form-data';
      if(e.target.enctype == multipart || e.target.encoding==multipart) {
        e.target.action = u.removeUrlParam(action, prevFlag);
        input = curam.dialog.addFormInput(e.target, "hidden", prevFlag,
                                          curam.dialog.pageId);
        input.setAttribute("id", flagInputId);
        input.id = flagInputId;

      } else {
        e.target.action = u.replaceUrlParam(action, prevFlag, curam.dialog.pageId);
      }

    } else {
      e.target.action = u.removeUrlParam(action, prevFlag);
    }

    //Tell the parent page that the modal it opened has submitted a form, so
    //that if the user clicks a 'Cancel' link later, the parent page will
    //refresh itself.
    parentWindow.curam.util.invalidatePage();

    // Hook into the overall tabbed UI refresh mechanism (except for external
    // application).
    if (!jsScreenContext.hasContextBits("EXTAPP")) {
      util.firePageSubmittedEvent("dialog");
    }
    return true;
  },

  /**
   * If this is called in the document head, then initModal will shut down
   * no matter what the conditions. This is like a window.close call,
   * except it will refresh the parent if necessary.
   */
  forceClose: function() {
    curam.dialog.FORCE_CLOSE = true;
  },

  /**
   * If this is called in the document head, then any call to
     * util.redirectWindow in the parent window will only refresh it,
   * instead of redirecting it to another URL.  This is primarily used
   * in the user preferences dialog.
   */
  forceParentRefresh: function() {
    var parentWindow = curam.dialog.getParentWindow(window);
    if(!parentWindow){return;}
    parentWindow.curam.util.FORCE_REFRESH = true;
  },

  closeModalDialog: function() {
    var topmostWindow = util.getTopmostWindow();
    if (curam.dialog._displayedHandlerUnsToken != null) {
      topmostWindow.dojo.unsubscribe(curam.dialog._displayedHandlerUnsToken);
      curam.dialog._displayedHandlerUnsToken = null;
    }

    if (typeof(curam.dialog._id) == "undefined" || curam.dialog._id == null) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.dialog._id=modalID;
      trace.log("curam.dialog.closeModalDialog() " 
          + bundle.getProperty("curam.dialog.modal.id") + modalID);
    }
  
    trace.log("publishing /curam/dialog/close for ", curam.dialog._id);
    util.getTopmostWindow().dojo.publish(
        "/curam/dialog/close", [ curam.dialog._id ]);
    trace.log("publishing /curam/dialog/close for ", curam.dialog._id);
  },

  /**
   * Parses the window options string.
   *
   * @returns An object with window option properties. In case no windowOptions
   *          were passed if, empty object (with no properties) is returned.
   */
  parseWindowOptions: function(windowOptions) {
    var opts = {};

    if(windowOptions) {
        trace.log("curam.dialog.parseWindowOptions " 
          + bundle.getProperty("curam.dialog.parsing"), windowOptions);
      var tokens = windowOptions.split(',');
      var splitToken;
      for(var i = 0; i < tokens.length; i++) {
        splitToken = tokens[i].split('=');
        opts[splitToken[0]] = splitToken[1];
      }
        trace.log("done:", dojo.toJson(opts));

    } else {
        trace.log("curam.dialog.parseWindowOptions " 
          + bundle.getProperty("curam.dialog.no.options"));
    }

    return opts;
  },

  /**
   * Redirects to a new URL in the specified context.
   * 
   * @param context The runtime context in which the redirect will take place.
   * @param [href] URL of the target page or null.
   * @param [force] Indicates if the refresh should take place even
   *    if the href is the same as the current href.
   * @param [ignoreFrames] If true, then any other frames on the page are
   *    not refreshed.
   */
  doRedirect: function(context, href, force, ignoreFrames) {
    window.curamDialogRedirecting = true;

    context.curam.util.redirectWindow(href, force, ignoreFrames);
  },
  
  closeGracefully: function() {
    curam.dialog._justClose = true;
  }
  });
  
  return curam.dialog;
});

},
'dijit/_CssStateMixin':function(){
define("dijit/_CssStateMixin", [
	"dojo/touch",
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare",	// declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/window" // win.body
], function(touch, array, declare, domClass, lang, win){

// module:
//		dijit/_CssStateMixin
// summary:
//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
//		state changes, and also higher-level state changes such becoming disabled or selected.

return declare("dijit._CssStateMixin", [], {
	// summary:
	//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
	//		state changes, and also higher-level state changes such becoming disabled or selected.
	//
	// description:
	//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
	//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	//
	//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
	//
	//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	//		within the widget).

	// cssStateNodes: [protected] Object
	//		List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	//.
	//		Each entry in the hash is a an attachpoint names (like "upArrowButton") mapped to a CSS class names
	//		(like "dijitUpArrowButton"). Example:
	//	|		{
	//	|			"upArrowButton": "dijitUpArrowButton",
	//	|			"downArrowButton": "dijitDownArrowButton"
	//	|		}
	//		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	//		is hovered, etc.
	cssStateNodes: {},

	// hovering: [readonly] Boolean
	//		True if cursor is over this widget
	hovering: false,

	// active: [readonly] Boolean
	//		True if mouse was pressed while over this widget, and hasn't been released yet
	active: false,

	_applyAttributes: function(){
		// This code would typically be in postCreate(), but putting in _applyAttributes() for
		// performance: so the class changes happen before DOM is inserted into the document.
		// Change back to postCreate() in 2.0.  See #11635.

		this.inherited(arguments);

		// Automatically monitor mouse events (essentially :hover and :active) on this.domNode
		array.forEach(["onmouseenter", "onmouseleave", touch.press], function(e){
			this.connect(this.domNode, e, "_cssMouseEvent");
		}, this);

		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active"], function(attr){
			this.watch(attr, lang.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown":
				case "touchpress":
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(win.body(), touch.release, function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
		if(this.checked){
			multiply(checkedState);
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this.focused){
			multiply("Focused");
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		array.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			array.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		array.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because domClass.toggle() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = lang.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			domClass.toggle(node, clazz+"Hover", hovering && !active && !disabled);
			domClass.toggle(node, clazz+"Active", active && !disabled);
			domClass.toggle(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn(touch.press, function(){
			active = true;
			setClass();
		});
		cn(touch.release, function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});
});

},
'cwtk/util/UIMFragment':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012-2013. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 
define("cwtk/util/UIMFragment", [
    "dojo", 
    "dojo/_base/declare",
    "dojo/_base/url",
    "curam/util/UIMFragment"
], function(dojo, declare, DojoUrl, curamUIMFragment){

		return declare("cwtk.util.UIMFragment", null, {
		
            /**
             *   Loads UIM content (fragment) onto panel.
             */
            load : function(paneID, pageID, params) {
            	console.debug("Loaded fragment: " + pageID);
                var self = this;
                self.get({
                    targetID : paneID,
                    pageID : pageID,
                    params : params,
                    onLoad : function(data) {
                        console.debug(data);
                    }
                });
            },
            
            /**
             *  CDEJ Implementation of loading content onto panel.
             *   
             *   @param JSON object:
             *       - pageID
             *       - targetID
             *       - url
             *       - params
             *       - onLoad
             *       - onDownloadError
             */
            get : function (obj) {
                return curamUIMFragment.get(obj);
            },
            
            /**
             *  Builds URL based on UIM ID.
             */
            constructURL : function (pageID) {
            	return curamUIMFragment._constructPath(pageID);
            }            
            
        });
});
},
'dijit/_WidgetBase':function(){
define("dijit/_WidgetBase", [
	"require",			// require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy domConstruct.place
	"dojo/dom-geometry",	// isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.doc.createTextNode
	"./registry"	// registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, kernel,
			lang, on, ready, Stateful, topic, win, registry){

/*=====
var Stateful = dojo.Stateful;
=====*/

// module:
//		dijit/_WidgetBase
// summary:
//		Future base class for all Dijit widgets.

// For back-compat, remove in 2.0.
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/_base/manager"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

// Nested hash listing attributes for each tag, all strings in lowercase.
// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
var tagAttrs = {};
function getAttrs(obj){
	var ret = {};
	for(var attr in obj){
		ret[attr.toLowerCase()] = true;
	}
	return ret;
}

function nonEmptyAttrToDom(attr){
	// summary:
	//		Returns a setter function that copies the attribute to this.domNode,
	//		or removes the attribute from this.domNode, depending on whether the
	//		value is defined or not.
	return function(val){
		domAttr[val ? "set" : "remove"](this.domNode, attr, val);
		this._set(attr, val);
	};
}

return declare("dijit._WidgetBase", Stateful, {
	// summary:
	//		Future base class for all Dijit widgets.
	// description:
	//		Future base class for all Dijit widgets.
	//		_Widget extends this class adding support for various features needed by desktop.
	//
	//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
	//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
	//
	//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
	//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	//
	//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
	//
	//		- DOM node attribute
	// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
	// |		_setFocusAttr: "focusNode"	(shorthand)
	// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
	// 		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
	//
	//		- DOM node innerHTML
	//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		_setMyClassAttr: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		If the custom setter is null, no action is performed other than saving the new value
	//		in the widget (in this).
	//
	//		If no custom setter is defined for an attribute, then it will be copied
	//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
	//		That's only done though for attributes that match DOMNode attributes (title,
	//		alt, aria-labelledby, etc.)

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",
	_setIdAttr: "domNode",	// to copy to this.domNode even for auto-generated id's

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",
	// set on domNode even when there's a focus node.   but don't set lang="", since that's invalid.
	_setLangAttr: nonEmptyAttrToDom("lang"),

	// dir: [const] String
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
	//		default direction.
	dir: "",
	// set on domNode even when there's a focus node.   but don't set dir="", since that's invalid.
	_setDirAttr: nonEmptyAttrToDom("dir"),	// to set on domNode even when there's a focus node

	// textDir: String
	//		Bi-directional support,	the main variable which is responsible for the direction of the text.
	//		The text direction can be different than the GUI direction by using this parameter in creation
	//		of a widget.
	// 		Allowed values:
	//			1. "ltr"
	//			2. "rtl"
	//			3. "auto" - contextual the direction of a text defined by first strong letter.
	//		By default is as the page direction.
	textDir: "",

	// class: String
	//		HTML class attribute
	"class": "",
	_setClassAttr: { node: "domNode", type: "class" },

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
	//		widget state.
	baseClass: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's data-dojo-attach-point syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div data-dojo-type=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span data-dojo-type=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span data-dojo-type=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		data-dojo-attach-point assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		Deprecated.   Instead of attributeMap, widget should have a _setXXXAttr attribute
	//		for each XXX attribute to be mapped to the DOM.
	//
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling set('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {},

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dom.byId(srcNodeRef);

		// For garbage collection.  An array of listener handles returned by this.connect() / this.subscribe()
		this._connects = [];

		// For widgets internal to this widget, invisible to calling code
		this._supportingWidgets = [];

		// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }

		// mix in our passed parameters
		if(params){
			this.params = params;
			lang.mixin(this, params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = registry.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			// Also calls custom setters for all attributes with custom setters.
			this._applyAttributes();

			// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
			// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
			// widget being attached to the DOM since it isn't when a widget is created programmatically like
			// new MyWidget({}).   See #11635.
			var source = this.srcNodeRef;
			if(source && source.parentNode && this.domNode !== source){
				source.parentNode.replaceChild(this.domNode, source);
			}
		}

		if(this.domNode){
			// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
			// assuming that dojo._scopeName even exists in 2.0
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy  widget attributes to the
		//		DOM according to attributeMap and _setXXXAttr objects, and also to call
		//		custom _setXXXAttr() methods.
		//
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
		//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
		// tags:
		//		private

		// Get list of attributes where this.set(name, value) will do something beyond
		// setting this[name] = value.  Specifically, attributes that have:
		//		- associated _setXXXAttr() method/hash/string/array
		//		- entries in attributeMap.
		var ctor = this.constructor,
			list = ctor._setterAttrs;
		if(!list){
			list = (ctor._setterAttrs = []);
			for(var attr in this.attributeMap){
				list.push(attr);
			}

			var proto = ctor.prototype;
			for(var fxName in proto){
				if(fxName in this.attributeMap){ continue; }
				var setterName = "_set" + fxName.replace(/^[a-z]|-[a-zA-Z]/g, function(c){ return c.charAt(c.length-1).toUpperCase(); }) + "Attr";
				if(setterName in proto){
					list.push(fxName);
				}
			}
		}

		// Call this.set() for each attribute that was either specified as parameter to constructor,
		// or was found above and has a default non-null value.   For correlated attributes like value and displayedValue, the one
		// specified as a parameter should take precedence, so apply attributes in this.params last.
		// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
		// NaN and thus is not ignored like a default value of "".
		array.forEach(list, function(attr){
			if(this.params && attr in this.params){
				// skip this one, do it below
			}else if(this[attr]){
				this.set(attr, this[attr]);
			}
		}, this);
		for(var param in this.params){
			this.set(param, this[param]);
		}
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode.
		//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
		// tags:
		//		protected

		if(!this.domNode){
			// Create root node if it wasn't created by _Templated
			this.domNode = this.srcNodeRef || domConstruct.create('div');
		}

		// baseClass is a single class name or occasionally a space-separated list of names.
		// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
		// TODO: make baseClass custom setter
		if(this.baseClass){
			var classes = this.baseClass.split(" ");
			if(!this.isLeftToRight()){
				classes = classes.concat( array.map(classes, function(name){ return name+"Rtl"; }));
			}
			domClass.add(this.domNode, classes);
		}
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		if(this._started){ return; }
		this._started = true;
		array.forEach(this.getChildren(), function(obj){
			if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
				obj.startup();
				obj._started = true;
			}
		});
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();

		// remove this.connect() and this.subscribe() listeners
		var c;
		while((c = this._connects.pop())){
			c.remove();
		}

		// destroy widgets created as part of template, etc.
		var w;
		while((w = this._supportingWidgets.pop())){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		}

		this.destroyRendering(preserveDom);
		registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				domAttr.remove(this.domNode, "widgetId");
			}else{
				domConstruct.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				domConstruct.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		array.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},

	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribute of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this.domNode;

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(lang.isObject(value)){
			domStyle.set(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this._set("style", value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified by commands parameter.
		//		If commands isn't specified then it's looked up from attributeMap.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

		array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(lang.isFunction(value)){ // functions execute in the context of the widget
						value = lang.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					domAttr.set(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(win.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					domClass.replace(mapNode, value, this[attr]);
					break;
			}
		}, this);
	},

	get: function(name){
		// summary:
		//		Get a property from a widget.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a widget. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		//
		// 		For example, if the widget has properties `foo` and `bar`
		//		and a method named `_getFooAttr()`, calling:
		//		`myWidget.get("foo")` would be equivalent to calling
		//		`widget._getFooAttr()` and `myWidget.get("bar")`
		//		would be equivalent to the expression
		//		`widget.bar2`
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},

	set: function(name, value){
		// summary:
		//		Set a property on a widget
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a widget which may potentially be handled by a
		// 		setter in the widget.
		//
		// 		For example, if the widget has properties `foo` and `bar`
		//		and a method named `_setFooAttr()`, calling
		//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
		//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
		//		would be equivalent to the statement `widget.bar = 3;`
		//
		//		set() may also be called with a hash of name/value pairs, ex:
		//
		//	|	myWidget.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	});
		//
		//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var names = this._getAttrNames(name),
			setter = this[names.s];
		if(lang.isFunction(setter)){
			// use the explicit setter
			var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// Mapping from widget attribute to DOMNode attribute/value/etc.
			// Map according to:
			//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
			//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
			//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
			// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
			// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
			// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
			var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
				tag = this[defaultNode].tagName,
				attrsForTag = tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode])),
				map =	name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
						((names.l in attrsForTag && typeof value != "function") ||
							/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
			if(map != null){
				this._attrToDom(name, value, map);
			}
			this._set(name, value);
		}
		return result || this;
	},

	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){ return c.charAt(c.length-1).toUpperCase(); });
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",	// converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
			g: "_get"+uc+"Attr",
			l: uc.toLowerCase()		// lowercase name w/out dashes, ex: acceptcharset
		});
	},

	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute, and call handlers
		//		registered with watch() if the value has changed.
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks && this._created && value !== oldValue){
			this._watchCallbacks(name, oldValue, value);
		}
	},

	on: function(/*String*/ type, /*Function*/ func){
		// summary:
		//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
		// description:
		//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
		//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
		//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

		return aspect.after(this, this._onMap(type), func, true);
	},

	_onMap: function(/*String*/ type){
		// summary:
		//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove")
		var ctor = this.constructor, map = ctor._onMap;
		if(!map){
			map = (ctor._onMap = {});
			for(var attr in ctor.prototype){
				if(/^on/.test(attr)){
					map[attr.replace(/^on/, "").toLowerCase()] = attr;
				}
			}
		}
		return map[type.toLowerCase()];	// String
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	getParent: function(){
		// summary:
		//		Returns the parent widget of this widget
		return registry.getEnclosingWidget(this.domNode.parentNode);
	},

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var handle = connect.connect(obj, event, this, method);
		this._connects.push(handle);
		return handle;		// _Widget.Handle
	},

	disconnect: function(handle){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		var i = array.indexOf(this._connects, handle);
		if(i != -1){
			handle.remove();
			this._connects.splice(i, 1);
		}
	},

	subscribe: function(t, method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// t: String
		//		The topic
		// method: Function
		//		The callback
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.set("label", v);
		//	|	});
		// tags:
		//		protected
		var handle = topic.subscribe(t, lang.hitch(this, method));
		this._connects.push(handle);
		return handle;		// _Widget.Handle
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		// tags:
		//		protected
		this.disconnect(handle);
	},

	isLeftToRight: function(){
		// summary:
		//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
		// tags:
		//		protected
		return this.dir ? (this.dir == "ltr") : domGeometry.isBodyLtr(); //Boolean
	},

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (domStyle.get(this.domNode, "display") != "none");
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard domConstruct.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget possessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as domConstruct.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(win.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	button.on("click", function(e){ console.log('click'); }));
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			domConstruct.place(this.domNode, reference, position);
		}
		return this;
	},

	getTextDir: function(/*String*/ text,/*String*/ originalDir){
		// summary:
		//		Return direction of the text.
		//		The function overridden in the _BidiSupport module,
		//		its main purpose is to calculate the direction of the
		//		text, if was defined by the programmer through textDir.
		//	tags:
		//		protected.
		return originalDir;
	},

	applyTextDir: function(/*===== element, text =====*/){
		// summary:
		//		The function overridden in the _BidiSupport module,
		//		originally used for setting element.dir according to this.textDir.
		//		In this case does nothing.
		// element: DOMNode
		// text: String
		// tags:
		//		protected.
	},

	defer: function(fcn, delay){ 
		// summary:
		//		Wrapper to setTimeout to avoid deferred functions executing
		//		after the originating widget has been destroyed.
		//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
		// fcn: function reference
		// delay: Optional number (defaults to 0)
		// tags:
		//		protected.
		var timer = setTimeout(lang.hitch(this, 
			function(){ 
				timer = null;
				if(!this._destroyed){ 
					lang.hitch(this, fcn)(); 
				} 
			}),
			delay || 0
		);
		return {
			remove:	function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
		};
	}
});

});

},
'dojo/cookie':function(){
define("dojo/cookie", ["./_base/kernel", "./regexp"], function(dojo, regexp) {
	// module:
	//		dojo/cookie
	// summary:
	//		TODOC


/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary:
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props:
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'dijit/MenuBarItem':function(){
require({cache:{
'url:dijit/templates/MenuBarItem.html':"<div class=\"dijitReset dijitInline dijitMenuItem dijitMenuItemLabel\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<span data-dojo-attach-point=\"containerNode\"></span>\n</div>\n"}});
define("dijit/MenuBarItem", [
	"dojo/_base/declare", // declare
	"./MenuItem",
	"dojo/text!./templates/MenuBarItem.html"
], function(declare, MenuItem, template){

/*=====
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/MenuBarItem
	// summary:
	//		Item in a MenuBar that's clickable, and doesn't spawn a submenu when pressed (or hovered)


	var _MenuBarItemMixin = declare("dijit._MenuBarItemMixin", null, {
		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setIconClassAttr: null	// cancel MenuItem setter because we don't have a place for an icon
	});

	var MenuBarItem = declare("dijit.MenuBarItem", [MenuItem, _MenuBarItemMixin], {
		// summary:
		//		Item in a MenuBar that's clickable, and doesn't spawn a submenu when pressed (or hovered)

	});
	MenuBarItem._MenuBarItemMixin = _MenuBarItemMixin;	// dojox.mobile is accessing this


	return MenuBarItem;
});

},
'curam/util/cache/CacheLRU':function(){
define("curam/util/cache/CacheLRU", ["dojo/_base/declare",
        "dojox/collections/Dictionary"],
        function(declare, Dictionary) {
	



var CacheItem = declare("curam/util/cache/CacheItem", null,
{	
	constPriority : {
		Low: 10,
	    Normal: 20,
		High: 30
	},
	
	constructor: function(keys, items, optionss)
    {
		if (keys == null)
		{ 
            throw new Error("Cache key cannot be null ");
		}
		//.expirationSliding	=	Number of seconds after last access before it expires
		//.expirationAbsolute	=	Javascript Date object indicating when the item is to expire
		//.priority 			=	Integer value indicating priority
		
		this.key = keys;
        this.value = items;
        if (optionss == null)
        {
            optionss = {};
        }
        if (optionss.priority == null)
        {
            optionss.priority = this.constPriority.Normal;
        }
        this.options = optionss;
        this.lastAccessed = new Date().getTime();
    },
    
    destroy : function()
	{
		try
		{
			this.inherited(arguments);
		}	
  		catch(err){
			console.error(err);
		  	//throw err;
		}
	}	
});
	
	
	
	
	return declare("curam/util/cache/CacheLRU",null, 
{
	maxSize : 20, // maxumim size of the cache
	activePurgeFrequency : null, // Time in millie seconds to pole purge 
	_dataColection : null,
	_tippingPoint : null, // % of cache full when it get's purged
	_purgePoint : null,   // The numner of items in the cache when purge invoked
	_purgingNow : false,  // flag to indacate purging is taking place
	constPriority : {
		Low: 10,
	    Normal: 20,
		High: 30
	},
	
	
    constructor: function(params)
 	{
 		try
 		{	
			dojo.mixin(this, params);
			
			
		    this._dataColection = new dojox.collections.Dictionary();
		    if (this.maxSize == null)
		    {
		        this.maxSize = -1;
		    }   
		    
			//console.debug("CacheLRU: "+this.maxSize);
		    
		    if (this.activePurgeFrequency == null)
		    {
		        this.activePurgeFrequency = -1;
		    }
		    this._tippingPoint = .75; 
		    this._purgePoint = Math.round(this.maxSize * this._tippingPoint);  
		    this._purgingNow = false;
		    
		    if(this.activePurgeFrequency > 0)
			{
			    this._timerPurge();
			}
			
			//dojo.addOnUnload(dojo.hitch(this,this.destroy));
 		}
 		catch(e)
 		{
 			console.error('There has been an issue with cache LRU"');
 			console.error(e);
 		}
	    
    },      
    

	/**
	 * addItem Method sets an item in the cache
	 * 
	 * @param key :
	 *            The key to store the data under
	 * @param data :
	 *            The data to be cached
	 * @param options :
	 *            Optional prameter that can be spesfied.
	 *            <ul>
	 *            <li>
	 * 
	 * expirationAbsolute : The date/time when cache entry will expire </li>
	 * <li> expirationSliding : A number representing the seconds since the last
	 * cache access after which the cache entry will expire
	 * 
	 * </li>
	 * <li> priority : Ranking of experation order of items in the cache. Note
	 * that placing a priority on an item does not guarantee it will remain in
	 * cache. It can still be purged if an expiration is hit, or if the cache is
	 * full.
	 * 
	 * </li>
	 * <li> callback : A function that gets called when the a cache item is
	 * purged from the cache. </li>
	 * </ul>
	 */
	addItem : function(key, data, options) 
	{
		if(this.maxSize < 1) {
			//We dont cache anything
			return;
		}

	
	    // add a new cache item to the cache
	    if (this._dataColection.contains(key) == true)
	    {
	        this._removeItem(key);
	    }
	    var newItem = new CacheItem(key, data, options);	    
	    this._dataColection.add(newItem.key,  newItem);
	    
	    // purge cache if full
	    if ((this.maxSize > 0) && (this._dataColection.count > this.maxSize)) {
	        this._purge();
	    }
	},
    
    
	/**
	 * getItem Retrieves an item from the cache, null is returned if the item
	 * does not exits or has expired
	 * 
	 * @param key :
	 *            The key which the item in the cache is cached under
	 */
	getItem : function(key) 
	{
	
	    // retrieve the item from the cache
	    var item = this._dataColection.item(key);
	    
	    if (item != null) 
	    {
	        if (!this._isExpired(item)) 
	        {
	            // if the item is not expired
	            // update its last accessed date
	            item.lastAccessed = new Date().getTime();
	        } 
	        else 
	        {
	            // if the item is expired, remove it from the cache
	            this._removeItem(key);
	            item = null;
	        }
	    }
	    
	    // return the item value (if it exists), or null
	    var returnVal = null;
	    if (item != null) 
	    {
	        returnVal = item.value;
	    } 
	    return returnVal;
	},
	
			
	/*
	 * clear : Removes all items from the cache
	 */
	clear : function() 
	{
		this._dataColection.forEach(
			function(data, index, array) 
			{
		   		var tmp = data.value;
	      		this._removeItem(tmp.key);
		    },
		this); 
	},
	
	/**
	 * Removes expired items from the cache 
	 */
	_purge : function() 
	{			
    	//console.info("timer purge _purge now ********");
	//	if(this._purgingNow == false)
		//{	 
		console.debug("purging cache");
		
			this._purgingNow = true;   
		    var tmparray = new Array();
		    
		    // Expire items that should be expired		    
		    this._dataColection.forEach( 
		    	function(data, index, array) 
		    	{	
		    		var tmp = data.value;		   	
			   		if (this._isExpired(tmp)) 
			   		{
			            this._removeItem(tmp.key);
			        } 
			        else 
			        {
			            tmparray.push(tmp);
			        }
			    },
			this);
						    
			if (tmparray.length > this._purgePoint) 
		    {		
		        // sort this array based on the last accessed date and cache priority
		        tmparray = tmparray.sort(
			        function(a, b) 
			        { 
			            if (a.options.priority != b.options.priority) 
			            {
			                return b.options.priority - a.options.priority;
			            } else 
			            {
			                return b.lastAccessed - a.lastAccessed;
			            }
			        }
				);
		        
		        // remove items from the end of the array
		        while (tmparray.length > this._purgePoint) 
		        {
		            var temp = tmparray.pop();
		            this._removeItem(temp.key);
		        }
		    }
		    this._purgingNow = false;
		//}
	},
	
	/**
	 * Remove item from cache, invoke callback if there
	 */
	_removeItem : function(key) {
	    var item = this._dataColection.item(key);
	    this._dataColection.remove(key);
	    
	    // if there is a callback function, call it at the end of execution
	    if (item.options.callback != null) 
	    {
	        var callback = dojo.hitch(this,function() 
	        {
	            item.options.callback(item.key, item.value);
	        });
	        setTimeout(callback, 0);
	    }
	},
	
	/**
	 * Retruns true if item is be expired
	 */
	_isExpired : function(item) 
	{
	    var now = new Date().getTime();
	    var expired = false;
	    if ((item.options.expirationAbsolute) && (item.options.expirationAbsolute < now)) 
	    {
	        // if the absolute expiration has passed, expire the item
	        expired = true;
	    } 
	    if ((expired == false) && (item.options.expirationSliding)) 
	    {
	        // if the sliding expiration has passed, expire the item
	        var lastAccess = item.lastAccessed + (item.options.expirationSliding * 1000);
	        if (lastAccess < now) {
	            expired = true;
	        }
	    }
	    return expired;
	},
    
    _timerPurge : function()
    {
    	//console.info("timer purge _timerPurge");
    	if(this._dataColection.count  > 0)
    	{
    		this._purge();
    	}
	    
	    this._timerID = setTimeout(dojo.hitch(this,
	    	function()
	    	{  
	    		this._timerPurgeSecond();   
	    	}
	    ), this.activePurgeFrequency );
    },
    
    _timerPurgeSecond : function()
    {
    	//console.info("timer purge _timerPurgeSecond");
    	if(this._dataColection.count  > 0)
    	{
    		this._purge();
    	}
	    
	    this._timerID = setTimeout(dojo.hitch(this,
	    	function()
	    	{  
	    		this._timerPurge();   
	    	}
	    ), this.activePurgeFrequency );
    },
    
    generateCacheOptions/*static*/ : function(slidingTimeout,absoluteTimeout, priority)
	{		
		//slidingTimeout	=	Time in seconds before it expires	
		var cacheOptions = new Object();
		//var now = new Date();
		//now.setTime(now.getTime()+timeout);	
		if(slidingTimeout) {
			cacheOptions.expirationSliding = slidingTimeout;
		}
		if(absoluteTimeout) {
			cacheOptions.expirationAbsolute = absoluteTimeout;
		}
		
		if(priority) {
			cacheOptions.priority = priority;
		} 		
		return cacheOptions;
	},
    
    destroy : function()
	{
		try
		{
			this.clear();
			delete this._dataColection;
			this.inherited(arguments);
		}	
  		catch(err){
			console.error(err);
		  	//throw err;
		}
	}
		
});

});


},
'dojo/uacss':function(){
define("dojo/uacss", ["./dom-geometry", "./_base/lang", "./ready", "./_base/sniff", "./_base/window"],
	function(geometry, lang, ready, has, baseWindow){
	// module:
	//		dojo/uacss
	// summary:
	//		Applies pre-set CSS classes to the top-level HTML node, based on:
	//			- browser (ex: dj_ie)
	//			- browser version (ex: dj_ie6)
	//			- box model (ex: dj_contentBox)
	//			- text direction (ex: dijitRtl)
	//
	//		In addition, browser, browser version, and box model are
	//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),

			"dj_gecko": has("mozilla")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	// priority is 90 to run ahead of parser priority of 100
	ready(90, function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'curam/util/Refresh':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * -------------------- 
   * 07-Oct-2013  BOS [CR00396277] Refactored to take account that the selected
   *                    tab may be undefined.
   */

define("curam/util/Refresh", ["curam/util/Request",
        "curam/define",
        "curam/util",
        "curam/tab",
        "curam/debug",
        "curam/util/ContextPanel",
        "curam/util/ui/refresh/TabRefreshController",
        "curam/util/ResourceBundle"
        ], function(curamRequest) {
  
  /*
   * Modification History
   * --------------------
   * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
   * 07-Oct-2013  BOS [CR00396277] Refactoring to take account of the fact that
   *                    the selected tab may not be defined. 
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 05-Aug-2011  MV  [CR00283589] Stop the click event in refreshPage() function.
   * 29-Jul-2011  MV  [CR00269970] Make use of the new refresh controller.
   * 24-May-2011  MV  [CR00267843] Disallow auto refresh on submitted action pages.
   * 29-Apr-2011  SC  [CR00264826] Removed incorrect usage of getselectedtab.
   * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
   *                    panel on submit.
   * 22-Dec-2010  MV  [CR00239864] Only call menu/nav loaders if there is request
   *                    for menu/nav update.
   * 14-Dec-2010  DG  [CR00217921] Updated for "tabDescriptor" on a tab panel.
   *                    Added copyright.
   * 30-Nov-2010  FG  [CR00232780] Add a new function that may be used to refresh
   *                    the page content and smart panel of a page.
   * 13-Jul-2010  MV  [CR00210064] Ensure tab menu and navigation is not updated
   *                   twice on tab load.
   * 07-Jul-2010  MV  [CR00180694] Refactor to unify dynamic updates of actions
   *                  menu and tab navigation. Move JavaScript code from renderer
   *                  to here.
   * 29-Apr-2010  MV  [CR00195109] Uncomment menu bar refresh code.
   * 26-Apr-2010  JS  [CR00197709] Removed refresh navigation bar code.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 18-Nov-2009  MV  [CR00172452] Only call handlers for the corresponding tab.
   * 03-Aug-2009  MLB [CR00163869] Full refresh implementation.
   * 16-Jul-2009  MLB [CR00162701] Initial version.
   */
  
  /**
   * Creating Resource Bundle Object to access localized resources.
   */ 
  dojo.requireLocalization("curam.application", "Debug");
  var bundle = new curam.util.ResourceBundle("Debug");

  /**
   * Contains functions for refreshing the various panels.
   */
  curam.define.singleton("curam.util.Refresh", {
    // flag if the content panel has been submitted
    submitted : false,
    // the id of the page that was submitted
    pageSubmitted : "",
    // array of refresh configuration for all tabs
    refreshConfig : [],

    menuBarCallback: null,
    navigationCallback: null,
    refreshedOnTabOpen: {},
    
    /** Holds references to refresh controllers for individual tabs. */
    _controllers: {},
    
    /** Holds reference to the page level refresh button anchor. */
    _pageRefreshButton: undefined,

    /**
     * Called by the MenuBarRenderer to register functions to be used
     * for dynamically updating the menu items.
     * 
     * The function is called once for each opened tab that has dynamic menu
     * items. The assumption is that all such tabs are using the same callbacks
     * so only the first call to this function is used to set the callbacks.
     * Subsequent calls are ignored.
     * 
     * @param updateMenuItemStates
     * @param getRefreshParams
     */
    setMenuBarCallbacks: function(updateMenuItemStates, getRefreshParams) {
      if (!curam.util.Refresh.menuBarCallback) {
        curam.util.Refresh.menuBarCallback = {
          updateMenuItemStates: updateMenuItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    /**
     * Called by the NavigationTabRenderer to register functions to be used
     * for dynamically updating the navigation items.
     * 
     * The function is called once for each opened tab that has dynamic
     * navigation items. The assumption is that all such tabs are using the same
     * callbacks so only the first call to this function is used to set
     * the callbacks. Subsequent calls are ignored.
     * 
     * @param updateNavItemStates
     * @param getRefreshParams
     */
    setNavigationCallbacks: function(updateNavItemStates, getRefreshParams) {
      if (!curam.util.Refresh.navigationCallback) {
        curam.util.Refresh.navigationCallback = {
          updateNavItemStates: updateNavItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    refreshMenuAndNavigation: function(tabWidgetId, refreshMenuBar,
        refreshNavigation, onTabOpen) {
      // Summary:
      //    Sends an AJAX request to get dynamic menu and navigation data
      //    and calls the functions for updating these components.
      curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
          + "tabWidgetId=%s, refreshMenuBar || refreshNavigation: %s || %s",
          tabWidgetId, refreshMenuBar, refreshNavigation);

      if (onTabOpen && curam.util.Refresh.refreshedOnTabOpen[tabWidgetId]) {
        // guard against situations where both menu and navigation onTabOpen
        // is called simultaneously
        curam.debug.log(bundle.getProperty("curam.util.Refresh.stop"));
        return;

      } else if(onTabOpen
            && !curam.util.Refresh.refreshedOnTabOpen[tabWidgetId]) {

        curam.debug.log(bundle.getProperty("curam.util.Refresh.tab.open"));
        // flag the fact onTabOpen was called and proceed with refreshing
        curam.util.Refresh.refreshedOnTabOpen[tabWidgetId] = true;

      } else {
        curam.debug.log(bundle
          .getProperty("curam.util.Refresh.detect.refresh"));
        // otherwise refresh as requested
        curam.debug.log(bundle.getProperty("curam.util.Refresh.refresh"));
      }

      if (!refreshMenuBar && !refreshNavigation) {
        // do nothing
        curam.debug.log(bundle.getProperty("curam.util.Refresh.no.refresh"));
        // reset the onTabOpen flag
        curam.util.Refresh.refreshedOnTabOpen[tabWidgetId] = false;
        return;
      }

      var callbacks = {
        /**
         * Handles the successful return of the AJAX call.
         */
        update: function(tabWidgetId, result, ioargs) {
          curam.debug.log(bundle
            .getProperty("curam.util.Refresh.dynamic.refresh"), result);
          var ncb = curam.util.Refresh.navigationCallback;
          curam.debug.log("refreshNavigation? ", refreshNavigation);
          if (refreshNavigation && result.navData && ncb) {
            ncb.updateNavItemStates(tabWidgetId, result);
          };
          var mcb = curam.util.Refresh.menuBarCallback;
          curam.debug.log("refreshMenuBar? ", refreshMenuBar);
          if (refreshMenuBar && result.menuData && mcb) {
            mcb.updateMenuItemStates(tabWidgetId, result);
          }
        },

        /**
         * Handles the failure case of the AJAX call made to get data
         * for the dynamic items.
         */
        error: function(error, ioargs) {
          curam.debug.log("========= " + bundle
            .getProperty("curam.util.Refresh.dynamic.failure") 
              + " ===========");
          curam.debug.log(bundle
            .getProperty("curam.util.Refresh.dynamic.error"), error);
          curam.debug.log(bundle
            .getProperty("curam.util.Refresh.dynamic.args"), ioargs);
          curam.debug.log("==================================================");
        }
      };

      // send the AJAX request
      var fullUrl = "servlet/JSONServlet?o3c=TAB_DYNAMIC_STATE_QUERY";
      var mcb = curam.util.Refresh.menuBarCallback;
      if (refreshMenuBar && mcb) {
        var menuParams = mcb.getRefreshParams( tabWidgetId);
        if (menuParams) {
          fullUrl += "&" + menuParams;
        }
      }
      var ncb = curam.util.Refresh.navigationCallback;
      if (refreshNavigation && ncb) {
        var navParams = ncb.getRefreshParams(tabWidgetId);
        if (navParams) {
          fullUrl += "&" + navParams;
        }
      }
      curam.debug.log(bundle
          .getProperty("curam.util.Refresh.dynamic.refresh.req"));
      curamRequest.post({
         url: fullUrl,
         handleAs: "json",
         preventCache: true,
         load: dojo.hitch(callbacks, "update", tabWidgetId),
         error: dojo.hitch(callbacks, "error")
      });
    },
    
    /**
     * Called by the tab renderer this function ensures that if config is added
     * repeatedly, it overrides any existing config for the same tab.
     * 
     * This caters for closing and reopening tabs.
     * 
     * @param {Object} config The tab refresh configuration to add.
     */
    addConfig: function(config) {
      var updated = false;
      
      // if the config for the tab is already added, replace it with the new one
      dojo.forEach(curam.util.Refresh.refreshConfig, function(existingConfig) {
        if (existingConfig.tab == config.tab) {
          existingConfig.config = config.config;
          
          updated = true;
        }
      });
      
      // otherwise just add as a new config
      if (!updated) {
        curam.util.Refresh.refreshConfig.push(config);
      }
    },

    /**
     * Called by the tab renderer this function instantiates the refresh
     * controller for the specified tab.
     * 
     * @param {String} tabWidgetId Widget ID of the tab to create refresh
     *    controller for.
     */
    setupRefreshController: function(tabWidgetId) {
      curam.debug.log("curam.util.Refresh.setupRefreshController " 
         + bundle.getProperty("curam.util.ExpandableLists.load.for"), 
           tabWidgetId);
      
      var selectedTab = dijit.byId(tabWidgetId);
      var tabId = selectedTab.tabDescriptor.tabID;
      
      var filteredConfigs = dojo.filter(curam.util.Refresh.refreshConfig,
          function(item) { return item.tab == tabId; });

      if (filteredConfigs.length == 1) {
        var refreshConfigTab = filteredConfigs[0];
        var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, refreshConfigTab);
        curam.util.Refresh._controllers[tabWidgetId] = ctl;
        ctl.setRefreshHandler(curam.util.Refresh.handleRefreshEvent);
      
      } else {
        if (filteredConfigs.length == 0) {
          curam.debug.log(bundle
            .getProperty("curam.util.Refresh.no.dynamic.refresh"), tabWidgetId);
          var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, null);
          curam.util.Refresh._controllers[tabWidgetId] = ctl;
        
        } else {
          throw "curam.util.Refresh: multiple dynamic refresh "
              + "configurations found for tab " + tabWidgetId;

        }
      }
      
      // destroy controller reference on tab close
      curam.tab.executeOnTabClose(function() {
        curam.util.Refresh._controllers[tabWidgetId].destroy();
        curam.util.Refresh._controllers[tabWidgetId] = undefined;
      }, tabWidgetId);
    },
    
    /**
     * Returns the refresh controller for the specified tab, throwing exception
     * in case controller doesn't exist for the tab.
     * 
     * @param tabWidgetId Widget ID of the tab.
     * 
     * @returns The refresh controller.
     */
    getController: function(tabWidgetId) {
      var ctl = curam.util.Refresh._controllers[tabWidgetId];
      if (!ctl) {
        throw "Refresh controller for tab '" + tabWidgetId + "' not found!";
      }
      return ctl;
    },
    
    /**
     * This is called by nested frames to notify the refresh controller of a page
     * load.
     * 
     * @param iframeId ID of the source iframe.
     * @param context The context in which the load happened.
     */
    handleOnloadNestedInlinePage: function(iframeId, context) {
      curam.debug.log("curam.util.Refresh.handleOnloadNestedInlinePage " 
        + bundle.getProperty("curam.util.Refresh.iframe", [iframeId, context]));
       var topmostWin = curam.util.getTopmostWindow();
       var tabWidgetId = undefined;

      // get the source tab of the nested page
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        tabWidgetId = curam.tab.getTabWidgetId(sourceTab);  
      }

      if (tabWidgetId) {
        curam.debug.log(bundle.getProperty("curam.util.Refresh.parent"), 
                      tabWidgetId);
        topmostWin.curam.util.Refresh.getController(tabWidgetId).pageLoaded(
          context.pageID,
          curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_INLINE);
        topmostWin.dojo.publish("/curam/main-content/page/loaded",
          [context.pageID, tabWidgetId]);
        return true;
      }
      return false;
    },

    /**
     * Handles refresh events emitted by refresh controllers for tabs in the UI.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     */
    handleRefreshEvent: function(eventIds) {
      var contextPanelRefreshHandler = function(tabWidgetId) {
        curam.util.ContextPanel.refresh(dijit.byId(tabWidgetId));
      };
      var mainContentRefreshHandler = function(tabWidgetId) {
        curam.tab.refreshMainContentPanel(dijit.byId(tabWidgetId));
      };
      var menuAndNavigationRefreshHandler =
      function(tabWidgetId, refreshMenuBar, refreshNavigation) {
        curam.util.Refresh.refreshMenuAndNavigation(
            tabWidgetId, refreshMenuBar, refreshNavigation);
      };
      curam.util.Refresh._doRefresh(eventIds, contextPanelRefreshHandler,
        mainContentRefreshHandler, menuAndNavigationRefreshHandler);
    },
    
    /**
     * Performs the actual refresh using the specified handlers.
     * THis is factored out to a separate function so that it can be unit tested.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     * @param {Function} refreshContextPanel A handler to be called when context
     *            panel refresh is required.
     * @param refreshMainContent A handler to be called when main content panel
     *            refresh is required.
     * @param refreshMenuAndNavigation A handler to be called when menu
     *            and navigation refresh is required.
     */
    _doRefresh: function(eventIds, refreshContextPanel, refreshMainContent,
        refreshMenuAndNavigation) {

      var tabWidgetId = null;
      var refreshMenuBar = false;
      var refreshNavigation = false;
      var refreshContext = false;
      var refreshMain = false;
      var trc = curam.util.ui.refresh.TabRefreshController.prototype;
      dojo.forEach(eventIds, function(eventId) {
        var lastSlashIndex = eventId.lastIndexOf("/");
        var target = eventId.slice(0, lastSlashIndex);
        // all events are for the same tabWidgetId so just read the first one
        if (!tabWidgetId) {
          tabWidgetId = eventId.slice(lastSlashIndex + 1, eventId.length);
        }
        // now read the target part
        if (target == trc.EVENT_REFRESH_MENU) {
          refreshMenuBar = true;
        }
        if (target == trc.EVENT_REFRESH_NAVIGATION) {
          refreshNavigation = true;
        }
        if (target == trc.EVENT_REFRESH_CONTEXT) {
          refreshContext = true;
        }
        if (target == trc.EVENT_REFRESH_MAIN) {
          refreshMain = true;
        }
      });
      
      // perform the refreshes
      if (refreshContext) {
        // refreshes the context panel
        refreshContextPanel(tabWidgetId);
      }
      if (refreshMain) {
        refreshMainContent(tabWidgetId);
      }
      refreshMenuAndNavigation(tabWidgetId, refreshMenuBar, refreshNavigation);
    },
    
    setupRefreshButton:function(buttonClass) {
      dojo.ready(function() {
        var button = dojo.query("." + buttonClass)[0];
        if (!button) {
          throw "Refresh button not found: " + buttonClass;
        }
        curam.util.Refresh._pageRefreshButton = button;
        var href = window.location.href;
        if (curam.util.isActionPage(href)) {
          // disable the button
          dojo.addClass(button, "disabled");
          curam.util.Refresh._pageRefreshButton._curamDisable = true;

        } else {
          dojo.addClass(button, "enabled");
          curam.util.Refresh._pageRefreshButton["_curamDisable"] = undefined;
        }
        
        curam.util.getTopmostWindow().curam.util.setupPreferencesLink(href);
      });
    },
    
    /**
     * Sets the force refresh flag to true and then invokes the function
     * that refreshes the main content area of a page. An event is also fired
     * that ensures that the associated smart panel is also refreshed.
     */
    refreshPage: function(event){
      dojo.stopEvent(event);

      var href = window.location.href;
      var buttonDisabled = curam.util.Refresh._pageRefreshButton._curamDisable;
      if(buttonDisabled) {
        // do nothing
        return;
      }

      // Ensure that the force refresh flag is set to true and make a call to
      // the function that will carry out the refresh operation.
      curam.util.FORCE_REFRESH = true;
      curam.util.redirectWindow(href, true);
    }
  });
  
  return curam.util.Refresh;
});

},
'dijit/form/_FormWidget':function(){
define("dijit/form/_FormWidget", [
	"dojo/_base/declare",	// declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

/*=====
var _Widget = dijit._Widget;
var _TemplatedMixin = dijit._TemplatedMixin;
var _CssStateMixin = dijit._CssStateMixin;
var _FormWidgetMixin = dijit.form._FormWidgetMixin;
=====*/

// module:
//		dijit/form/_FormWidget
// summary:
//		FormWidget


// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/form/_FormValueWidget"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.  Use set('disabled', ...) instead.
		kernel.deprecated("setDisabled("+disabled+") is deprecated. Use set('disabled',"+disabled+") instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.  Use set('value', ...) instead.
		kernel.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use set('value',"+value+") instead.", "", "2.0");
		this.set('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.  Use get('value') instead.
		kernel.deprecated(this.declaredClass+"::getValue() is deprecated. Use get('value') instead.", "", "2.0");
		return this.get('value');
	},

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8484, #8660.
		// Regarding escaping, see heading "Attribute values" in
		// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
		this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/'/g, "&quot;") + '"') : '';
		this.inherited(arguments);
	},

	// Override automatic assigning type --> focusNode, it causes exception on IE.
	// Instead, type must be specified as ${type} in the template, as part of the original DOM
	_setTypeAttr: null
});

});

},
'url:cwtk/widget/templates/InlineDropDown.html':"<div id=\"${id}\" class=\"cw-inline-dropdown\">\n\t<div class=\"cw-inline-dropdown-container-wrapper\" \n\t\tdata-dojo-attach-point=\"containerWrapper\">\n\t\t<div class=\"cw-inline-dropdown-container\" \n\t\t\tdata-dojo-attach-point=\"containerNode\">\n\t\t</div>\n\t</div>\n\t<div id=\"${id}_dropdown\" class=\"cw-inline-dropdown-div\" \n\t\tdata-dojo-type=\"cwtk.widget.DropDown\"\n\t\tdata-dojo-attach-point=\"dropdownNode\"\n\t\tposition=\"below\">\n\t\t<div>\n\t\t\t<div id=\"${id}_button\" class=\"cw-inline-dropdown-button\" \n\t\t\t\tdata-dojo-attach-point=\"buttonNode\">\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"cw-tooltip-dialog cw-inline-dropdown-tooltip\" \n\t\t\tdata-dojo-type=\"dijit.TooltipDialog\">\n\t\t\t<div class=\"cw-inline-dropdown-tooltip-container\" \n\t\t\t\tdata-dojo-attach-point=\"tooltipContainer\"></div>\n\t\t</div>\n\t</div>\n</div>\n",
'dojo/fx/easing':function(){
define("dojo/fx/easing", ["../_base/lang"], function(lang) {
// module:
//		dojo/fx/easing
// summary:
//		This module defines standard easing functions that are useful for animations.

var easingFuncs = /*===== dojo.fx.easing= =====*/ {
	// summary:
	//		Collection of easing functions to use beyond the default
	//		`dojo._defaultEasing` function.
	//
	// description:
	//
	//		Easing functions are used to manipulate the iteration through
	//		an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	//		and the easing function progresses through that Line determing
	//		how quickly (or slowly) it should go. Or more accurately: modify
	//		the value of the _Line based on the percentage of animation completed.
	//
	//		All functions follow a simple naming convention of "ease type" + "when".
	//		If the name of the function ends in Out, the easing described appears
	//		towards the end of the animation. "In" means during the beginning,
	//		and InOut means both ranges of the Animation will applied, both
	//		beginning and end.
	//
	//		One does not call the easing function directly, it must be passed to
	//		the `easing` property of an animation.
	//
	//	example:
	//	|	dojo.require("dojo.fx.easing");
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',
	//	|		duration: 2000,
	//	|		//	note there is no ()
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//

	linear: function(/* Decimal? */n){
		// summary: A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; }
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that starts away from the target,
		//		and quickly accelerates towards the end value.
		//
		//		Use caution when the easing will cause values to become
		//		negative as some properties cannot be set to negative values.
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		// description:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		//		Use caution when the easing will cause values to become negative as some
		//		properties cannot be set to negative values.

		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function combining the effects of `backIn` and `backOut`
		//
		// description:
		//		An easing function combining the effects of `backIn` and `backOut`.
		//		Use caution when the easing will cause values to become negative
		//		as some properties cannot be set to negative values.
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary:
		//		An easing function the elastically snaps from the start value
		//
		// description:
		//		An easing function the elastically snaps from the start value
		//
		//		Use caution when the elasticity will cause values to become negative
		//		as some properties cannot be set to negative values.
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		// description:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		// description:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the beginning of an Animation
		return (1 - easingFuncs.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l;
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' at the beginning and end of the Animation
		if(n < 0.5){ return easingFuncs.bounceIn(n * 2) / 2; }
		return (easingFuncs.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

lang.setObject("dojo.fx.easing", easingFuncs);

return easingFuncs;
});

},
'curam/widget/menu/MenuPane':function(){
define("curam/widget/menu/MenuPane", [ "dojo/_base/declare", 
         "dojo/_base/lang", 
         "dojo/on", 
         "dojo/dom-class",
         "curam/widget/componentWrappers/ListWraper",
         "curam/widget/form/ToggleButtonGroup",
         "dojo/_base/window",
         "dojo/dom-construct",
         "dijit/TooltipDialog",
         "dijit/popup",
         "dojo/_base/fx",
         "dojo/dom-style",
         "dojox/layout/ExpandoPane",
         "dojo/dom-geometry",
         "dojo/aspect",
         "dojo/keys",
         "dijit/Tooltip",
         "idx/oneui/HoverCard",
         "dojo/query",
         "dojo/dom-style",
         "dojo/has",
         "dojo/dom-attr"], 
         function(declare,
                         lang, 
                         on, 
                         domClass,
                         listWraper, 
                         toggleButtonGroup,
                         window,
                         domConstruct,
                         tooltipDialog,
                         popup,
                         fx,
                         style,
                         expandoPane,
                         domGeom,
                         aspect,
                         keys,
                         Tooltip,
                         HoverCard,
                         query,
                         domStyle,
                         has,
                         domAttr) {

        var _MenuPaneButtonIndexer = declare("curam.widget.menu._MenuPaneButtonIndexer", null, {

                selectedButtonKey : -1,  // the id of the selected button
                selectedButtonDisplayIndex : -1,
                expandButtonDisplayIndex : -1, // index that the expand button is set at
                
                
                _buttonDisplayOrderArrayOrginale : null,  // keeps track of the order of the buttons been displayed
                _buttonMap : null, // map containing the buttons and there releated info index by the button ID
                _subPagenMap : null, // map containing the mapping between sub pages and there button key = sub page id value = button id                                       
                
                _buttonPrimaryContainerArray : null,
                _buttonSecondaryContainerArray : null,
                
                
                constructor: function(args) {
                        this._buttonMap = [];
                        this._subPagenMap = [];
                        this._buttonDisplayOrderArrayOrginale = new Array();
                        this._buttonPrimaryContainerArray = new Array();
                        this._buttonSecondaryContainerArray = new Array();
                        
            },
                
                addNewButton : function(button, key)
                {
                        var holder = {
                                        key : key,
                                        id : button.id,
                                        button : button,
                                        contextBox : null,
                                        displayOrderIndex : null,
                                        displayOrderOrginaleIndex : this._buttonDisplayOrderArrayOrginale.length
                        };                      
                        this._buttonMap[key] = holder;  
                        this._buttonDisplayOrderArrayOrginale.push(key);
                },
                
                addButtonReferenceToPrimaryContainer : function (key, primaryContainer)
                {
                        if(primaryContainer)
                        {
                                this._buttonPrimaryContainerArray.push(key);
                        }
                        else
                        {
                                this._buttonSecondaryContainerArray.push(key);
                        }
                },
                
                getButton : function(key)
                {
                        var buttonItem = this._buttonMap[key];
                        
                        return buttonItem;
                },
                
                /**
                 * Function adds index's to the sub page / primary page 
                 * mapping
                 * 
                 * @ subPageID the id of the sub page
                 * @ primaryPageID id of the primary page for this sub page
                 */
                setNewSubPage : function(subPageID, primaryPageID)
                {               
                        this._subPagenMap[subPageID] = primaryPageID;   
                },
                
                /**
                 * Function gets primary page of a sub page
                 * @param subPageID The id of the sub page been processed
                 * @returns
                 */
                getSubPagePrimaryPage : function(subPageID)
                {
                        var primaryPageID = this._subPagenMap[subPageID];
                        
                        return primaryPageID;
                },              
                
                getButtonPrimary : function(index)
                {
                        var key = this._buttonPrimaryContainerArray[index];
                        
                        var buttonItem = this.getButton(key);
                        
                        return buttonItem;
                },
                
                getButtonSecondary : function(index)
                {
                        var key = this._buttonSecondaryContainerArray[index];
                        
                        var buttonItem = this.getButton(key);
                        
                        return buttonItem;
                },
                
                swapButtonFomPrimaryContainerToSecondaryContainer : function(fromPrimaryToSecondary)
                {
                        if(fromPrimaryToSecondary)
                        {
                                var item = this._buttonPrimaryContainerArray.pop();
                                this._buttonSecondaryContainerArray.unshift(item);
                        }
                        else
                        {
                                var item = this._buttonSecondaryContainerArray.shift();
                                this._buttonPrimaryContainerArray.push(item);
                        }
                        
                },
                
                swapButtonContainerToContainer : function(fromPrimary, sourceIndex, targetIndex)
                {
                        if(fromPrimary)
                        {
                                var item = this._buttonPrimaryContainerArray.splice(sourceIndex,1);
                                this._buttonSecondaryContainerArray.splice(targetIndex,0,item[0]);
                        }
                        else
                        {
                                var item = this._buttonSecondaryContainerArray.splice(sourceIndex,1);
                                this._buttonPrimaryContainerArray.splice(targetIndex,0,item[0]);
                        }
                        
                },
                
                swapButtonContainerItemIndex : function(primary, sourceIndex, targetIndex)
                {
                        if(primary)
                        {
                                var item = this._buttonPrimaryContainerArray.splice(sourceIndex,1);
                                this._buttonPrimaryContainerArray.splice(targetIndex,0,item[0]);
                        }
                        else
                        {
                                var item = this._buttonSecondaryContainerArray.splice(sourceIndex,1);
                                this._buttonSecondaryContainerArray.splice(targetIndex,0,item[0]);
                        }
                        
                },
                
                /**
                 * function will return what container the button is
                 * currently stored in from it's orginale index
                 *  
                 * @param index is a number which represents the originale placement of a button 
                 * @returns {Number}  0 for primary container 1 for secondary container
                 */
                getWhichContinerFromIndex : function(index)
                {                       
                        var outPut = 0;                 
                        if( index >= this._buttonPrimaryContainerArray.length   )
                        {
                                // contained in the secondary container
                                outPut = 1;
                        }
                        
                        return outPut;
                }

        });     
        
        
        return declare("curam.widget.menu.MenuPane", [ expandoPane ], 
{
                _listWrapper : null,
                _expandButton : null, // button that toggles the pop up menu
                _expandButtonContentBox : null, // contains the size of the expand button
                _toolTipDialogExpand : null,
                _toolTipDialogExpandContents : null,
                _fadeIn : null,
                _fadeOut : null,
                _menuPaneButtonIndexer : null,
                duration : 300,  // time taken for fade in and fade out
                _buttonSizerDiv : null,
                _buttonSizerList : null,
                _resizeResizeHandler : null,
                _showEndresizeResizeHandler : null,
                _hideEndResizeHandler : null,
                resizeDelay : 250,  // time for the resize delay if set to 0 or less there is no delay
                _resizeDelayHandler : null,
                _previouseHeight : -1, // records the previouse hight, to pervent false resizes
                _resizeStatusQue : 1,  // resize is qued up
                _resizeStatusResizeing : 0,  // ressize is taking place
                _resizeStatusNotInUse : -1, // no resize under way
                _resizeCurentStatus : -1, // holds state bewteen resize delays
                
                // defines styles for the position on buttons in there OL
                _classNavMenu : "navMenu",
                _classNavMenuOverFlow : "navMenuOverFlow",
                
                // defines the class for the main menu pain
                _classCurramSideMenuButton : "curramSideMenuButton",
                _classCurramSideMenuButtonIcon : "curramSideMenuButtonIcon",
                
                // defines the styles for the over flow menu
                _classCurramSideMenuOverFlowButton : "curramSideMenuOverFlowButton",
                _classCurramSideMenuOverFlowButtonIcon : "curramSideMenuOverFlowButtonIcon",
                
                // defines the styles for the expand button that pops the over flow menu
                _classCurramSideMenuOverFlowButtonExpand : "curramSideMenuOverFlowButtonExpand",
                _classCurramSideMenuOverFlowButtonExpandIcon : "curramSideMenuOverFlowButtonExpandIcon",

                constructor:function (args) 
                {
                        this.inherited( arguments);
                        this._menuPaneButtonIndexer = new _MenuPaneButtonIndexer();
                },
                
                postCreate : function() {
                        this.inherited(arguments);
                        
                        // hide the expando pain's visule controles
                        domClass.add(this.titleWrapper, "dijitHidden");
                        
                        // setup the button that hides / displays the over flow menu
                        this._expandButton = new dijit.form.Button({
                                id: "navOverflowButton",
                                baseClass: this._classCurramSideMenuOverFlowButtonExpand, 
                                iconClass: this._classCurramSideMenuOverFlowButtonExpandIcon,
                                orgID : "exapnadButton",
                                showLabel : false
                        });

                        // used to contain the contents of the dialog
                        this._toolTipDialogExpandContentsListWrapper = new curam.widget.componentWrappers.ListWraper(
                                {
                                        listType   :       'ol',
                                        role       :       "menu",
                                        baseClass  :       this._classNavMenuOverFlow,
                                        _doBeforeItemSet : lang.hitch(this,function(item, listItem)
                                        {
                                                if (item != null)
                                                {                                                       
                                                        if(this.isLeftToRight())
                                                        {
                                                                // alight the button to one side of the over flow menu
                                                                domStyle.set(item.focusNode, "textAlign", "left");
                                                                // set padding at the traling side of the button
                                                                domStyle.set(item.containerNode, "marginRight", "10px"); 
                                                        }
                                                        else
                                                        {
                                                                // alight the button to one side of the over flow menu
                                                                domStyle.set(item.focusNode, "textAlign", "right");
                                                                // set padding at the traling side of the button
                                                                domStyle.set(item.containerNode, "marginLeft", "10px"); 
                                                        } 
                                                        
                                                        // over come an issue with the over lfow arrows witht the containg dialog
                                                        domStyle.set(item.containerNode, "padding", "0px");
                                                        
                                                        // set the over flow menu style
                                                        item.set("baseClass",this._classCurramSideMenuOverFlowButton);
                                                        // set the over flow menu style
                                                        domClass.replace(item.domNode, this._classCurramSideMenuOverFlowButton, this._classCurramSideMenuButton);                                                       
                                                        // set the icon style for the over flow menu
                                                        domClass.add(item.iconNode, this._classCurramSideMenuOverFlowButtonIcon);
                                                        
                                                } 
                                        })
                                }
                        );//.placeAt(this._toolTipDialogExpand.containerNode);
                        
                        var overFlowContainer = null;
                        
                        if(has("ie") != null && has("ie") < 9){
                          // ie 8 and less
                          overFlowContainer = domConstruct.create("div");
                        }
                        else
                        {
                            // every other browser
                            overFlowContainer = domConstruct.create("nav");                    
                        }

                        domAttr.set(overFlowContainer, "role", "navigation");
                        this._toolTipDialogExpandContentsListWrapper.placeAt(overFlowContainer);

                        this._toolTipDialogExpand = new idx.oneui.HoverCard(    
                                        {
                                                draggable : false,
                                                hideDelay : 450,
                                                showDelay : 0,
                                                target:this._expandButton.domNode,
                                                content : overFlowContainer,
                                                forceFocus : true,
                                                focus : lang.hitch(  this, function(){
                                                        //get the list of buttons from the over flow panel
                                                        var buttonToSwapBack = this._menuPaneButtonIndexer.getButtonSecondary(0);
                                                        // set the focus to be the first button
                                                        buttonToSwapBack.button.focus();
                                                        
                                                        }),
                                                defaultPosition : ['after-centered', 'before-centered'],
                                                moreActions:[ ],
                                                actions: [ ]
                                        }
                        );
                                      
                        // Hide the hover card initially.
                        domClass.add(this._toolTipDialogExpand.domNode, "dijitHidden");
                        // remove items from ibm one ui hovercard that are not needed
                        domClass.add(query(".idxOneuiHoverCardFooter",this._toolTipDialogExpand.bodyNode)[0], "dijitHidden");                   
                        domClass.add(this._toolTipDialogExpand.gripNode, "dijitHidden");
                        domClass.add(this._toolTipDialogExpand.actionIcons, "dijitHidden");
                        domClass.add(this._toolTipDialogExpand.moreActionsNode, "dijitHidden");
                                                
                        this._listWrapper = new curam.widget.componentWrappers.ListWraper(
                                        {
                                                listType       :       'ol',
                                                role           :       "menu",
                                                baseClass      :       this._classNavMenu,
                                                _doBeforeItemSet : lang.hitch(this,function(item, listItem)
                                                {               
                                                        if (item != null && item.orgID != "exapnadButton" )
                                                        {
                                                                // remove the over flow menu icon
                                                                domClass.remove(item.iconNode, this._classCurramSideMenuOverFlowButtonIcon);
                                                                if(has("ie"))
                                                                {
                                                                  // fix for ie to remove redendent style
                                                                  domClass.remove(item.domNode, "curramSideMenuOverFlowButtonHover");
                                                                }
                                                                
                                                                // center the text
                                                                domStyle.set(item.focusNode, "textAlign", "center");
                                                                
                                                                // set padding at the traling side of the button
                                                                if(this.isLeftToRight())
                                                                {
                                                                        domStyle.set(item.containerNode, "marginRight", "0px"); 
                                                                }
                                                                else
                                                                {
                                                                        domStyle.set(item.containerNode, "marginLeft", "0px"); 
                                                                }
                                                                
                                                                // the side menu style
                                                                item.set("baseClass", this._classCurramSideMenuButton);
                                                                // the side menu style
                                                                domClass.replace(item.domNode, this._classCurramSideMenuButton, this._classCurramSideMenuOverFlowButton);
                                                        }       
                                                })
                                                
                                        }
                        );//.placeAt(this.containerNode);
                        
                        if(has("ie") != null && has("ie") < 9){
                            // ie 8 and less
                            var div1 = domConstruct.create("div", null, this.containerNode);
                            domAttr.set(div1, "role", "navigation");
                            this._listWrapper.placeAt(div1);
                        }
                        else
                        {
                            // every other browser
                            var navEl = domConstruct.create("nav", null, this.containerNode);
                            domAttr.set(navEl, "role", "navigation");
                            this._listWrapper.placeAt(navEl);                       
                        }
                        
                        this._fadeIn = fx.fadeIn({ node: this._listWrapper.domNode, duration: this.duration, onEnd : lang.hitch(this, "_showContainer") });
                        this._fadeOut = fx.fadeOut({ node: this._listWrapper.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHideEnd") });
                
                        this._resizeResizeHandler = aspect.after(this, "resize", this._doResize, true);
                        
                        this._showEndresizeResizeHandler = aspect.after(this, "_showEnd", lang.hitch(this,"_onShowComplete"), false);
                        this._hideEndResizeHandler = aspect.after(this, "_hideEnd", lang.hitch(this,"_onHideComplete"), false);

                        
                },              
                
                /**
                 * Override to force startup/layout on BorderContainer.
                 */
                startup : function() {
                        this.inherited(arguments);

                             
                },
                
                fadeIn : function ()
                {
                        this._fadeIcons(true);
                },
                
                fadeOut : function()
                {
                        this._fadeIcons(false);
                },
                
                _fadeIcons : function(visable)
                {

                        // close popup
                        this._toolTipDialogExpand.hide(this._expandButton.domNode);

                        if(visable == true)
                        {
                                // show panel
                                
                                if(this._fadeOut.status() == "playing"){
                                        this._fadeOut.stop();
                                        this._fadeIn.play();
                                }
                                else
                                {
                                        if(this._fadeIn.status() != "playing"){
                                                this._fadeIn.play();
                                        }
                                }
                        }
                        else
                        {
                                // hide panel
                                if(this._fadeIn.status() == "playing"){
                                        this._fadeIn.stop();
                                        this._fadeOut.play();
                                }
                                else
                                {
                                        if(this._fadeOut.status() != "playing"){
                                                this._fadeOut.play();
                                        }
                                }
                        }
                        
                        
                },
                
                _showContainer : function()
                {
                        if(!this._showing){
                                this.toggle();
                        }
                },
                
                /**
                 * utility function to be over writen
                 */
                _onShowComplete : function()
                {
                        
                },
                
                _onHideEnd : function()
                {
                        if(this._showing){
                                this.toggle();
                        }
                },

                
                /**
                 * utility function to be over writen
                 */
                _onHideComplete : function()
                {
                        
                },
                
                /**
                 * add a new array of menu items
                 */
                addMenuItems : function (items)
                {
                        
                        this._cleanDownExistingMenuItems();
                        
                        dojo.forEach(items, function(item, i){
                            this._addMenuItem(item, i);
                          },this);
                        
                        this._initaleProcessMenuItems();
                        this._initalePlaceMenuItems();
                        
                },
                
                /**
                 * Function destroys all buttons and puts it back 
                 * to a clean unset state
                 */
                _cleanDownExistingMenuItems : function()
                {
                        // care full here the order is important
                        this._removeButtonCacheContent();
                        this._toolTipDialogExpandContentsListWrapper.deleteAllChildern();
                        
                        this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length = 0;
                        
                        this._removeExpandButton();     
                        this._listWrapper.deleteAllChildern();                  

                        this._menuPaneButtonIndexer._buttonDisplayOrderArrayOrginale.length = 0;
                        
                        this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length = 0;
                        
                        this._menuPaneButtonIndexer.selectedButtonKey = -1;
                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex = -1;
                        this._menuPaneButtonIndexer.expandButtonDisplayIndex = -1;
                        this._menuPaneButtonIndexer.selectedButtonKey = -1;
                        
                        for (var key in this._menuPaneButtonIndexer._subPagenMap) 
                        {                               
                                delete this._menuPaneButtonIndexer._subPagenMap[key];
                        }
                },
                
                /**
                 * Set's the selected button 
                 * 
                 * @param inputJson 
                 * @param exceptionButtonFound if true an exception will be thrown if button is not found
                 */
                setSelectedButton : function(inputJson)
                {
                        if(inputJson.exceptionButtonFound == null)
                        {
                                inputJson.exceptionButtonFound = true;
                        }
                        
                        if(this._menuPaneButtonIndexer.getButton(inputJson.key) == null && 
                                        this._menuPaneButtonIndexer.getSubPagePrimaryPage(inputJson.key) == null)
                        {
                                // display an abertory page that does not exist in the page maps
                                if(inputJson.exceptionButtonFound == false)
                                {
                                        // display the abertory page
                                        this._onSelectAfter(inputJson);
                                }
                                else
                                {
                                        // display an error if the page is not found
                                        throw new Error("No button exists with the requested id : "+inputJson.key);
                                }
                        }
                        else
                        {
                                this._buttonSelected(inputJson, true);
                        }
                        
                },
                
                /**
                 * Function unselects any selected menus. 
                 */
                deselect : function()
                {
                        if(this._menuPaneButtonIndexer.selectedButtonDisplayIndex !=-1 )
                        {
                                var button = this._menuPaneButtonIndexer.getButton(this._menuPaneButtonIndexer.selectedButtonKey);
                                
                                button.button.set('checked', false);
                        }
                },
                
                _onSelectBefore : function(inputJson)
                {
                        
                },
                
                _onSelectAfter : function(inputJson)
                {
                        
                },
                                
                /**
                 * Add new menu item
                 */
                _addMenuItem : function (item, index)
                {
                        item = this._filterItem(item);
                        
                        this._generateSubPageIndex(item.id, item.subPageIds);
                        
                        // defines call back for the selected button
                        // get get reference to the selected button
                        var cb = lang.hitch(this,function(selectedButton)
                                        {
                                                var pram = {
                                                                key : selectedButton.orgID,
                                                                param : []
                                                };
                                                
                                                this._buttonSelected(pram, false);
                                        });
                        
                        var but = new curam.widget.form.ToggleButtonGroup({
                                label : item.label,
                                orgID : item.id,
                                groupName : "menuPaneCuramWidget",
                                onClick :  function(e){         
                                        cb(this);
                                },
                                baseClass: this._classCurramSideMenuButton,
                                iconClass: this._classCurramSideMenuButtonIcon
                        });
                        
                        if(item.iconPath != null && lang.trim(item.iconPath).length >0 )
                        {
                                style.set(but.iconNode, {
                                    backgroundImage : "url("+item.iconPath+")" 
                                  });   
                        }                       
                        
                        if(item.selected != null && item.selected == true )
                        {
                                this._menuPaneButtonIndexer.selectedButtonKey = item.id;
                        }
                        
                        this._menuPaneButtonIndexer.addNewButton(but, item.id);
                        
                },
                
                /**
                 * Function builds up the index or primary to sub page
                 * relations
                 * 
                 * @primaryId id of primary page
                 * @subPageIds array of sub page id related to the primary id
                 */
                _generateSubPageIndex : function(primaryId, subPageIds)
                {
                        if(subPageIds != null && subPageIds.length >0)
                        {
                                dojo.forEach(subPageIds, function(subpageID){
                                        
                                        if(this._menuPaneButtonIndexer.getSubPagePrimaryPage(subpageID) == null)
                                        {
                                                this._menuPaneButtonIndexer.setNewSubPage(subpageID, primaryId);
                                        }
                                        else
                                        {
                                                throw new Error("There has been a clash, sub page has all ready been registered.  Primary ID : "+primaryId+" Subpage ID : "+subpageID);
                                        }

                                },this);
                        }
                },
                
                /**
                 * Utility function that can transform data in to 
                 * required format
                 */
                _filterItem : function(item)
                {
                        return item;
                },
                
                _initaleProcessMenuItems : function()
                {
                                
                        var boxSize = dojo.contentBox(this.domNode);    
                        
                        if(this._showing == false){
                                boxSize.w = this._showSize;
                        }       
                        
                        this._buttonSizerDiv = domConstruct.create("div", { style: { height : boxSize.h+"px", width : boxSize.w+"px" } }     );
                                                
                        domClass.add(this._buttonSizerDiv, "dijitOffScreen");
                        dojo.place(this._buttonSizerDiv, window.body());
                        
                        this._buttonSizerList = new curam.widget.componentWrappers.ListWraper(
                                        {
                                                listType : 'ol',
                                                baseClass : this._classNavMenu
                                                
                                        }
                        ).placeAt(this._buttonSizerDiv);

                        for (var key in this._menuPaneButtonIndexer._buttonMap)
                        {
                                var butItem = this._menuPaneButtonIndexer.getButton(key);
                                
                                if(butItem.button)
                                {
                                        this._buttonSizerList.set("item", butItem.button.domNode);
                                        var butonContextBox = dojo.contentBox(butItem.button.domNode);          
                                        
                                        this._menuPaneButtonIndexer.getButton(key).contextBox = butonContextBox;
                                }
                        }
                        
                        this._buttonSizerList.set("item", this._expandButton.domNode);

                        this._expandButtonContentBox = dojo.contentBox(this._expandButton.domNode);

                        domClass.add(this._expandButton.domNode, "dijitHidden");
                        
                        domConstruct.place(this._expandButton.domNode,window.body());
                },
                
                /**
                 * Function places the buttons in the nav bar for the first 
                 * time
                 */
                _initalePlaceMenuItems : function()
                {
                        var index =0;
                        for (var key in this._menuPaneButtonIndexer._buttonMap) 
                        {
                                var item = this._menuPaneButtonIndexer.getButton(key);
                                
                                if(item.button.get('checked'))
                                {
                                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex = index;
                                        this._menuPaneButtonIndexer.selectedButtonKey = key;
                                }
                                item.displayOrderOrginaleIndex = index;
                                
                                if( this._menuPaneButtonIndexer.expandButtonDisplayIndex == -1 &&  
                                                (this.get("ContainerHeight")-this._listWrapper.get("ContainerHeight") ) > (this._expandButtonContentBox.h + item.contextBox.h)   )
                                {
                                        // add the item to the main container 
                                        this._listWrapper.set("item", item.button);
                                        this._menuPaneButtonIndexer.addButtonReferenceToPrimaryContainer(key, true);
                                }
                                else
                                {                                       
                                        this._addExpandButton(index);
                                        
                                        // add button to the pop up dialog
                                        this._toolTipDialogExpandContentsListWrapper.set("item", item.button);
                                        this._menuPaneButtonIndexer.addButtonReferenceToPrimaryContainer(key, false);
                                        
                                        if(index == this._menuPaneButtonIndexer.selectedButtonDisplayIndex )
                                        {
                                                selectedIndexPositionTemp =this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length-1;
                                        }                                       
                                }       
                                
                                if(index == 0)
                                {
                                        idcar = item.button.id;
                                }
                                index++;
                        }
                        
                        //remove move sizer containers
                        this._buttonSizerList.destroy();
                        domConstruct.destroy(this._buttonSizerDiv);
                        
                        if(this._menuPaneButtonIndexer.selectedButtonKey != -1 )
                        {
                                var selectedButton = this._menuPaneButtonIndexer.getButton(this._menuPaneButtonIndexer.selectedButtonKey);
                                selectedButton.button._onClick();
                        }
                        
                },
                
                _addExpandButton : function(index)
                {
                        if( this._menuPaneButtonIndexer.expandButtonDisplayIndex == -1)
                        {
                                console.info("add expando");
                                // add the expand button
                                this._menuPaneButtonIndexer.expandButtonDisplayIndex = index;
                                
                                domClass.remove(this._expandButton.domNode, "dijitHidden");
                                this._listWrapper.set("item", this._expandButton);
                        }
                },
                
                _removeExpandButton : function()
                {
                        if( this._menuPaneButtonIndexer.expandButtonDisplayIndex != -1 &&
                                        this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length == 0)
                        {
                                this._menuPaneButtonIndexer.expandButtonDisplayIndex = -1;

                                console.info("Remove expando : "+this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length);
                                domClass.add(this._expandButton.domNode, "dijitHidden");
                                
                                domConstruct.place(this._expandButton.domNode, window.body() );
                                
                                this._listWrapper.deleteChild(this._listWrapper.get("ItemCount"));
                                
                        }
                },
                
                _doResize : function(args)
                {
                        if(args != null && args.h != null && args.h >10)
                        {                         
                            if(this._previouseHeight != args.h)
                            {
                                if(this.resizeDelay >0)
                                {
                                  // have a reisze delay helps performance                                
                                  if(this._resizeDelayHandler != null)
                                  {
                                      this._resizeDelayHandler.remove();
                                  }
                                  this._previouseHeight = args.h;
                                  this._toolTipDialogExpand.hide(this._expandButton.domNode);
                                
                                
                                  var cb = lang.hitch(this,function()
                                     {
                                        this._callRepositionButtons();
                                     });
                                
                                  this._resizeDelayHandler = this.defer(cb,this.resizeDelay);
                                }
                                else
                                {
                                  // no resize delay
                                  this._callRepositionButtons();
                                }
                            }
                        }
                },
                
                _callRepositionButtons : function()
                {
                    if(this._resizeCurentStatus == this._resizeStatusNotInUse)
                    {
                      this._positionButtonDuringResize();
                    }
                    else
                    {
                      this._resizeCurentStatus == this._resizeStatusQue;
                    }
                },
                
                _positionButtonDuringResize : function()
                {
                        this._resizeCurentStatus = this._resizeStatusResizeing;
                        if( this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length > 0 && 
                                        this.get("ContainerHeight") < this._listWrapper.get("ContainerHeight"))
                        {
                                // main menu panel has got smaller need to move 
                                // buttons to pop up
                                this._addExpandButton(this._listWrapper.get("ItemCount"));

                                var offset = 1;
                                while (  (this.get("ContainerHeight") < this._listWrapper.get("ContainerHeight"))
                                                && this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length > 0 )
                                {

                                        if(offset ==2 && this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length ==1)
                                        {
                                                offset =1;
                                        }
                                        
                                        var arrayIndex = this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-offset;
                                        

                                        var menuPaneItem = this._menuPaneButtonIndexer.getButtonPrimary(arrayIndex);

                                        //if (arrayIndex == this._menuPaneButtonIndexer.selectedButtonDisplayIndex )//this._menuPaneButtonIndexer.selectedButtonKey == key)
                                        if(menuPaneItem.button.get('checked') && this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length > 1)
                                        {
                                                // increase off set to leave selected button in place.
                                                offset = 2;
                                                console.info(arrayIndex+" : I am checked *************************  = "+menuPaneItem.button.get('checked'));
                                        }
                                        else
                                        {
                                                console.info("selected = "+menuPaneItem.button.get('checked'));
                                                
                                                // from primary to secondary, source : target 
                                                this._menuPaneButtonIndexer.swapButtonContainerToContainer(true, arrayIndex, 0);

                                                this._toolTipDialogExpandContentsListWrapper.set("item", menuPaneItem.button,"first");
                                                this._listWrapper.deleteChild(arrayIndex);

                                                this._menuPaneButtonIndexer.expandButtonDisplayIndex--;
                                                if(offset == 2)
                                                {
                                                        if (this._menuPaneButtonIndexer.selectedButtonDisplayIndex != 0)
                                                        {
                                                                this._menuPaneButtonIndexer.selectedButtonDisplayIndex--;
                                                        }
                                                        else
                                                        {
                                                                // not needed
                                                        }
                                                }
                                        }
                                }

                                console.info("Move from main to popup-----------------");

                        }
                        else if(this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length > 0 && 
                                        this.get("ContainerHeight") > this._listWrapper.get("ContainerHeight"))
                        {
                                // you have items in the pop up that could be moved to the main menu panel
                          
                          console.info(" secondary container size = "+this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length);

                                console.info("Move from popup to main****************");

                                var keepGoing = true;
                                while (keepGoing &&  this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length > 0 ) 
                                {
                                        var index =0;
                                        var item = this._menuPaneButtonIndexer.getButtonSecondary(index);
                                        
                                        if( item != null &&  
                                                        (this.get("ContainerHeight")-this._listWrapper.get("ContainerHeight") ) > item.contextBox.h   )
                                        {
                                                var insertPosition = this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length;// "last";
                                                
                                                
                                                if(this._menuPaneButtonIndexer.expandButtonDisplayIndex != -1)
                                                {
                                                        //insertPosition = this._menuPaneButtonIndexer.expandButtonDisplayIndex;
                                                        this._menuPaneButtonIndexer.expandButtonDisplayIndex++;
                                                        
                                                        if(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length  > 0 )
                                                        {
                                                                var lastButton = this._menuPaneButtonIndexer.getButtonPrimary(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1);
                                                                if(lastButton.button.get('checked') &&
                                                                                 lastButton.displayOrderOrginaleIndex >= insertPosition         )
                                                                {
                                                                        if(insertPosition != 0)
                                                                        {
                                                                                insertPosition--;
                                                                        }
                                                                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex ++;
                                                                }
                                                        }
                                                }
                                                
                                                // secondary to primary  : source : target
                                                this._menuPaneButtonIndexer.swapButtonContainerToContainer(false, 0, insertPosition);
                                                this._listWrapper.set("item", item.button,insertPosition);
                                                this._toolTipDialogExpandContentsListWrapper.deleteChild(index);
                                                

                                                if(this._menuPaneButtonIndexer.expandButtonDisplayIndex != -1 &&
                                                                this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length <=0)
                                                {       
                                                        this._removeExpandButton();
                                                }                                                       
                                        }
                                        else
                                        {
                                                keepGoing = false;
                                        }
                                }
                        }
                        else
                        {
                                // do nothing here as there is enough room to dispaly all
                                // buttons
                                //console.info("do nothing!"+this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length);
                        }
                        
                        // a resize request has been queued up; do it now
                        if(this._resizeCurentStatus <= this._resizeStatusResizeing)
                        {
                             this._resizeCurentStatus= this._resizeStatusNotInUse;
                        }
                        else
                        {
                            this._positionButtonDuringResize.apply(this);
                        }
                },
                
                /**
                 * Function handles a nav bar button been pressed
                 * in order to process the new page to be displayed
                 * 
                 * @param selectedButton If a @param secondaryPage is false or 
                 * null @param selectedButton will be a wrapper containing the 
                 * selected button, if it is true it will be the ID of the sub page to display
                 * 
                 * @param subPage is a boolean if true a sub page is requested if false the 
                 * primary page is requested
                 */
                _buttonSelected : function(inputJson, subPage)
                {       
                        
                        this._toolTipDialogExpand.hide(this._expandButton.domNode);
                        
                        var buttonWraped;
                        
                        if(this._menuPaneButtonIndexer.getButton(inputJson.key) != null )
                        {
                                buttonWraped = this._menuPaneButtonIndexer.getButton(inputJson.key);    
                        }
                        else if(this._menuPaneButtonIndexer.getSubPagePrimaryPage(inputJson.key) != null)
                        {
                                var prmaryButtonID = this._menuPaneButtonIndexer.getSubPagePrimaryPage(inputJson.key);
                                buttonWraped = this._menuPaneButtonIndexer.getButton(prmaryButtonID);
                        }
                        else
                        {
                                throw new Error("state unknow for requested selected button : "+inputJson.key);
                        }
                        
                        buttonWraped.button.set("checked",true);
                        this._onSelectBefore(inputJson);
                        this._positionSelectedButton(buttonWraped);
                        if(this._menuPaneButtonIndexer._buttonSecondaryContainerArray.length >0)
                        {
                              this._previouseHeight++;
                              this._callRepositionButtons();
                        }
                        this._onSelectAfter(inputJson);
                },
                
                _positionSelectedButton : function(selectedButton)
                {
                        
                        // if a button is all ready selected move it back to it's orginale place
                        if(this._menuPaneButtonIndexer.selectedButtonDisplayIndex !=-1 )
                        {
                                // this._menuPaneButtonIndexer.selectedButtonDisplayIndex
                                // this._menuPaneButtonIndexer.selectedButtonKey = item.id;
                                
                                var previousSelectedButton = this._menuPaneButtonIndexer.getButton(this._menuPaneButtonIndexer.selectedButtonKey);
                                var orginaleIndex = previousSelectedButton.displayOrderOrginaleIndex;
                                
                                // need to reposition the old selected button
                                if(this._menuPaneButtonIndexer.selectedButtonDisplayIndex != orginaleIndex)
                                {
                                        // need to reposition button to orginale place holder.
                                        
                                        
                                        if(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length >0)
                                        {
                                                // button spread accross both primary and secondary containers
                                        
                                                // get the index of the postion in the secondary
                                                var orginaleIndexPosition = orginaleIndex - (this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1);
                                                
                                                // get the button to sawap back that the selected button took it's place
                                                var buttonToSwapBack = this._menuPaneButtonIndexer.getButtonSecondary(0);
        
                                                // from primary to secondary, source : target 
                                                this._menuPaneButtonIndexer.swapButtonContainerToContainer(true, this._menuPaneButtonIndexer.selectedButtonDisplayIndex, orginaleIndexPosition);
                                                this._toolTipDialogExpandContentsListWrapper.set("item", previousSelectedButton.button, orginaleIndexPosition);
                                                this._listWrapper.deleteChild(this._menuPaneButtonIndexer.selectedButtonDisplayIndex);
                                                
        
                                                // from secondary to primary, source : target 
                                                this._menuPaneButtonIndexer.swapButtonContainerToContainer(false, 0, this._menuPaneButtonIndexer.selectedButtonDisplayIndex);
                                                this._listWrapper.set("item", buttonToSwapBack.button, this._menuPaneButtonIndexer.selectedButtonDisplayIndex);
                                                this._toolTipDialogExpandContentsListWrapper.deleteChild(0);
                                                
                                                this._menuPaneButtonIndexer.selectedButtonDisplayIndex =-1;
                                                this._menuPaneButtonIndexer.selectedButtonKey = -1;
                                        }
                                        else
                                        {
                                                // all buttons in the secondary container
                                                

                                                // get the index of the postion in the secondary
                                                var orginaleIndexPosition = previousSelectedButton.displayOrderOrginaleIndex;
                                                
                                                // reorder the buttons in the indexer | secondary  : source : target
                                                this._menuPaneButtonIndexer.swapButtonContainerItemIndex(false, 0, orginaleIndexPosition);
                                                
                                                // place it at the start of the list
                                                this._toolTipDialogExpandContentsListWrapper.set("item", previousSelectedButton.button,orginaleIndexPosition+1);                                        
                                                // remove old place holder
                                                this._toolTipDialogExpandContentsListWrapper.deleteChild(0);
                                                
                                                this._menuPaneButtonIndexer.selectedButtonDisplayIndex =-1;
                                                this._menuPaneButtonIndexer.selectedButtonKey = -1;
                                                
                                        }
                                        
                                }
                                else
                                {
                                        console.info('no need to repostion old selected button');
                                        // no need to reposition the button                                     
                                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex =-1;
                                }                               
                        }                       
                        
                        // now to reposition the newly slected button
                        
                        var orginaleIndex = selectedButton.displayOrderOrginaleIndex;
                        
                        if(this._menuPaneButtonIndexer.getWhichContinerFromIndex(orginaleIndex) == 1)
                        {
                                // selected button in secondary container need to move to primary container
                                
                                if(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length >0)
                                {
                                        // button spread accross both primary and secondary containers
                                        
                                        // get the index of the postion in the secondary
                                        var selectedButtonIndex = orginaleIndex - (this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length);                                    
                                        
                                        // the button that needs to be moved to creat space for selected button
                                        var buttonToMove = this._menuPaneButtonIndexer.getButtonPrimary(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1);
                                        
                                        // from primary to secondary, source : target 
                                        this._menuPaneButtonIndexer.swapButtonContainerToContainer(true, this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1, 0);
                                        this._toolTipDialogExpandContentsListWrapper.set("item", buttonToMove.button, 0);
                                        this._listWrapper.deleteChild(this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length);
                                        

                                        // from secondary to primary, source : target 
                                        this._menuPaneButtonIndexer.swapButtonContainerToContainer(false, selectedButtonIndex+1, this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length);
                                        this._listWrapper.set("item", selectedButton.button, this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1);
                                        this._toolTipDialogExpandContentsListWrapper.deleteChild(selectedButtonIndex+1);

                                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex = this._menuPaneButtonIndexer._buttonPrimaryContainerArray.length-1;
                                        this._menuPaneButtonIndexer.selectedButtonKey = selectedButton.key;                                     
                                        
                                }
                                else
                                {
                                        // all buttons in the secondary container                                       
                                        
                                        // reorder the buttons in the indexer | secondary  : source : target
                                        this._menuPaneButtonIndexer.swapButtonContainerItemIndex(false, orginaleIndex, 0);
                                        
                                        // place it at the start of the list
                                        this._toolTipDialogExpandContentsListWrapper.set("item", selectedButton.button,0);                                      
                                        // remove old place holder
                                        this._toolTipDialogExpandContentsListWrapper.deleteChild(orginaleIndex+1);
                                        
                                        this._menuPaneButtonIndexer.selectedButtonDisplayIndex = 0;
                                        this._menuPaneButtonIndexer.selectedButtonKey = selectedButton.key;
                                }                               
                        }
                        else
                        {
                                // selected button in primary container no need to reposition buttons
                                this._menuPaneButtonIndexer.selectedButtonDisplayIndex = orginaleIndex;
                                this._menuPaneButtonIndexer.selectedButtonKey = selectedButton.key;

                                console.info('no need to repostion New selected button :' +orginaleIndex +" key = "+selectedButton.key);
                        }                       
                },
                
                _placeMenuItems : function(item, index)
                {       
                        
                        if( this._menuPaneButtonIndexer.expandButtonDisplayIndex == -1 &&  
                                        (this.get("ContainerHeight")-this._listWrapper.get("ContainerHeight") ) > (this._expandButtonContentBox.h + item.contextBox.h)   )
                        {
                                // add the item to the main container 
                                this._listWrapper.set("item", item.button);
                        }
                        else
                        {                                       
                                if( this._menuPaneButtonIndexer.expandButtonDisplayIndex == -1)
                                {
                                        // add the expand button
                                        this._menuPaneButtonIndexer.expandButtonDisplayIndex = index;
                                        
                                        domClass.remove(this._expandButton.domNode, "dijitHidden");
                                        this._listWrapper.set("item", this._expandButton);
                                }
                                
                                // add button to the pop up dialog
                                this._toolTipDialogExpandContentsListWrapper.set("item", item.button);
                                
                        }
                },
                
                _getContainerHeightAttr : function()
                {
                        var contentBoxOuterContainer = domGeom.getContentBox(this.containerNode);
                        return contentBoxOuterContainer.h;
                },
                
                _setWidthAttr : function(width)
                {                                         
                        if(this._showing){
                                // resize container when visable
                                // not implamented
                        }
                        else
                        {
                                // resize container when not visable 
                                this._showAnim.properties.width = width;
                                this._showSize = width;
                                this._currentSize.w = width;

                        }
                },
                
                /**
                 * function removes the content of the button 
                 * cache;
                 */
                _removeButtonCacheContent: function()
                {
                        for (var key in this._menuPaneButtonIndexer._buttonMap) 
                        {
                                var entry = this._menuPaneButtonIndexer.getButton(key);
                                if(entry.button)
                                {
                                        entry.button.destroy();
                                }
                                delete entry.button;
                                delete entry.contextBox;
                                delete entry.displayOrderIndex;
                                delete entry.displayOrderOrginaleIndex;
                                delete entry.id;
                                delete entry.key;
                                delete entry;
                                
                                delete this._menuPaneButtonIndexer._buttonMap[key];
                        }
                },
                
                /**
                 * Clean up functions
                 */
                destroy: function() {
                        try
                        {       
                                this._resizeCurentStatus= this._resizeStatusNotInUse;
                                this._resizeDelayHandler != null ? this._resizeDelayHandler.remove() : null;                            
                                this._resizeResizeHandler.remove();
                                this._showEndresizeResizeHandler.remove();
                                this._hideEndResizeHandler.remove();
                                
                                this._expandButton.destroy();
                                this._removeButtonCacheContent();
                                this._toolTipDialogExpandContentsListWrapper.destroy();
                                this._toolTipDialogExpand.destroy();                            
                                this._listWrapper.destroy();    
                                delete this._menuPaneButtonIndexer;
                        }       
                        catch(err){
                                console.error(err);
                        }                       
                        this.inherited(arguments);
                }
        });
});

},
'dijit/dijit':function(){
define("dijit/dijit", [
	".",
	"./_base",
	"dojo/parser",
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./layout/_LayoutWidget",
	"./form/_FormWidget",
	"./form/_FormValueWidget"
], function(dijit){

	// module:
	//		dijit/dijit
	// summary:
	//		A roll-up for common dijit methods
	//		All the stuff in _base (these are the function that are guaranteed available without an explicit dojo.require)
	//		And some other stuff that we tend to pull in all the time anyway

	return dijit;
});

},
'dijit/MenuItem':function(){
require({cache:{
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"}});
define("dijit/MenuItem", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/event", // event.stop
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/sniff", // has("ie")
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, event, kernel, has,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _Contained = dijit._Contained;
	var _CssStateMixin = dijit._CssStateMixin;
=====*/

	// module:
	//		dijit/MenuItem
	// summary:
	//		A line item in a Menu Widget


	return declare("dijit.MenuItem",
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text
		label: '',
		_setLabelAttr: { node: "containerNode", type: "innerHTML" },

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id+"_text";
			domAttr.set(this.containerNode, "id", label);
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			this.domNode.setAttribute("aria-labelledby", label);
			dom.setSelectable(this.domNode, false);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			this.getParent().onItemUnhover(this);

			// When menu is hidden (collapsed) due to clicking a MenuItem and having it execute,
			// FF and IE don't generate an onmouseout event for the MenuItem.
			// So, help out _CssStateMixin in this case.
			this._set("hovering", false);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			event.stop(evt);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			domAttr.set(this.containerNode,'colSpan',value?"1":"2");

			this._set("accelKey", value);
		}
	});
});

},
'curam/ui/ClientDataAccessor':function(){
/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 09-Aug-2012  MV  [CR00337714] Convert to AMD.
 * 31-Jul-2012  MV  [CR00336202] Fix calls to log() function.
 * 08-Feb-2011  DG  [TEC-6115] Explicitly set content encoding to UTF-8.
 * 29-Jul-2010  PK  [CR00211736] Moved to "curam.ui" package.
 * 02-Jun-2010  PK  [CR00203531] Moved UIMPageRequest class to
 *                    curam\ui\PageRequest.js.
 * 13-Oct-2009  SC  [CR00172239] Moved ClientDataAccessor to this file.
 */

define("curam/ui/ClientDataAccessor", ["curam/util/Request",
        "curam/debug",
        "curam/util/ResourceBundle"
        ], function(curamRequest) {

  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  dojo.requireLocalization("curam.application", "Debug");
  var bundle = new curam.util.ResourceBundle("Debug");

  /**
   * Support for accessing the PathResolver servlet to retrieve and
   * set data on the web-tier. The PathResolver only supports a limited
   * set of paths.
   */
  return dojo.declare("curam.ui.ClientDataAccessor", null, {

    /**
     * Return a single string result by calling the specified path.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    get: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "text",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Return a list of results by calling the specified path.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    getList: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?r=l&p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "json",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Return a raw JSON object.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    getRaw: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?r=j&p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "json",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Set a value in the web-tier by calling the specified path. The
     * successCallback is optional in this case because the set may return
     * nothing of significance.
     *
     * path: The path to invoke on the web-tier.
     * value: The value to set.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    set: function(path, value, successCallback, failCallback, handleCallback) {
      // TODO: Would it be safer to submit the value as the "content" of the
      // xhrPost below? That would avoid problems with URI length limits. See
      // "codetable-hierarchy.js" and "ApplicationController.java" for an example.
      var tabServletURL =
        "servlet/PathResolver" + "?r=x&p=" + path + "&v="
          + encodeURIComponent(value);

      // Set defaults if not defined
      if (failCallback == undefined || failCallback == null) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined || handleCallback == null) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      if (successCallback == undefined || successCallback == null) {
        successCallback = dojo.hitch(this, this.handleClientDataAccessorSuccess);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "text",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Generic handler for errors when invoking the ClientDataAccessor path
     * resolver.
     */
    handleClientDataAccessorError: function(error, ioargs) {
      var errorPart1
        = bundle.getProperty("curam.ui.ClientDataAccessor.err.1")
          + "PathResolverServlet : ";
      var errorPart2 = bundle.getProperty("curam.ui.ClientDataAccessor.err.2");
      curam.debug.log(errorPart1 + error + errorPart2 + ioargs);
    },

    /**
     * Generic handler for successful invocation when invoking the ClientDataAccessor
     * path resolver.
     */
    handleClientDataAccessorSuccess: function(response, ioargs) {
      curam.debug
        .log("curam.ui.ClientDataAccessor.handleClientDataAccessorSuccess : "
          + response);
    },

    /**
     * Generic handler for errors when invoking the ClientDataAccessor path
     * resolver.
     */
    handleClientDataAccessorCallback: function(response, ioargs) {
      curam.debug
        .log("curam.ui.ClientDataAccessor.handleClientDataAccessorCallback :"
          + " " + bundle.getProperty("curam.ui.ClientDataAccessor.callback"));
    }
  });
});

},
'curam/util/onLoad':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 06-May-2014 AB   [Cr00430639]Adding title to Iframe-RPT project
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
   * 14-Dec-2010  MV  [CR00238518] Ensure the hidden iframe is not picked up by
   *    WordIntegration control.
   * 06-Dec-2010  MV  [CR00233442] Avoid never ending progress bar in IE.
   * 19-Nov-2010  MV  [CR00231655] Subscribe/connect to events with
   *    a function that will automatically unsubscribe/disconnect on page unload.
   * 30-Jun-2010 MV [CR00161271] Update documentation.
   * 11-Jun-2010 MV [CR00202971] Fixed function for removing subscribers.
   * 02-Jun-2010 MV [CR00202412] Initial version.
   */

define("curam/util/onLoad", ["curam/util",
        "curam/define",
        "curam/util/ResourceBundle"
        ], function() {

  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  dojo.requireLocalization("curam.application", "Debug");
  var bundle = new curam.util.ResourceBundle("Debug");
  
  curam.define.singleton("curam.util.onLoad", {
    EVENT: "/curam/frame/load",

    // Used in the context of the iframe.
    publishers: [],

    /* Used in the context of the parent window and contains subscribers
     * for all the iframes that exist in this window context.
     */
    subscribers: [],

    defaultGetIdFunction: function(iframeNode) {
      // summary:
      // This is the default function for getting a unique ID of an iframe.
      // If the iframe has a CSS class that starts with "iframe-" then this class
      // is returned as the unique ID of the iframe.
      var classes = dojo.attr(iframeNode, "class").split(" ");
      return dojo.filter(classes, function(className) {
        return className.indexOf("iframe-") == 0;
      })[0];
    },

    addPublisher: function(callback) {
      // summary:
      //   Public function, is called in the context of the iframe window.
      curam.util.onLoad.publishers.push(callback);
    },

    addSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //   This is called in the context of the parent window.
      //   Multiple subscribers per iframe can be registered, provided each
      //   has a different handler function.
      // parameter: getId
      //   optional, if not specified the default getId function will be used

      curam.util.onLoad.subscribers.push({
        "getId": getId ? getId : curam.util.onLoad.defaultGetIdFunction,
        "callback": callback,
        "iframeId": iframeId
      });
    },

    removeSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //  Must be called in the context of the parent window.

      curam.util.onLoad.subscribers =
        dojo.filter(curam.util.onLoad.subscribers, function(subscriberData) {
          return !(subscriberData.iframeId == iframeId
              && subscriberData.callback == callback);
        });
    },

    execute: function() {
      // summary:
      //   Public function, is called in the context of the iframe window.

      if(window.parent == window) {
        curam.debug.log("curam.util.onLoad.execute(): " 
          + bundle.getProperty("curam.util.onLoad.exit"));
        return;
      }

      var context = {};

      dojo.forEach(curam.util.onLoad.publishers, function(callback) {
        // Allow each of the publishers to add to the context object
        callback(context);
      });

      // Free up references to functions
      curam.util.onLoad.publishers = [];

      // A hack to avoid never ending progress bar in IE when multiple iframes
      // exist in the application.
      //Adding title - RPT project 
      require(["dojo/io/iframe"]);
      var iframe = dojo.io.iframe.create(null, null, "about:blank");
      dojo.attr(iframe, "id", "ie-progress-indicator-helper");
      dojo.attr(iframe, "title", "ie-progress-indicator-helper");

      // publish the event into the parent context
      window.parent.dojo.publish(curam.util.onLoad.EVENT, [window.frameElement, context]);
    }
  });

  /* Subscribe to events in the context this file is being loaded in.
   * This is meant for parent window contexts.
   */
  curam.util.subscribe(curam.util.onLoad.EVENT, function(iframeNode, context) {
    dojo.forEach(curam.util.onLoad.subscribers, function(subscriberData) {
      var currentId = subscriberData.getId(iframeNode);
      if (subscriberData.iframeId == currentId) {
        subscriberData.callback(currentId, context);
      }
    });
  });
  
  return curam.util.onLoad;
});

},
'dijit/DropDownMenu':function(){
require({cache:{
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n"}});
define("dijit/DropDownMenu", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_OnDijitClickMixin",
	"./_MenuBase"
], function(declare, event, keys, template, _OnDijitClickMixin, _MenuBase){

/*=====
	var _MenuBase = dijit._MenuBase;
	var _OnDijitClickMixin = dijit._OnDijitClickMixin;
=====*/

	// module:
	//		dijit/DropDownMenu
	// summary:
	//		dijit.DropDownMenu widget

	return declare("dijit.DropDownMenu", [_MenuBase, _OnDijitClickMixin], {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		postCreate: function(){
			var l = this.isLeftToRight();
			this._openSubMenuKey = l ? keys.RIGHT_ARROW : keys.LEFT_ARROW;
			this._closeSubMenuKey = l ? keys.LEFT_ARROW : keys.RIGHT_ARROW;
			this.connectKeyNavHandlers([keys.UP_ARROW], [keys.DOWN_ARROW]);
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		Handle keyboard based menu navigation.
			// tags:
			//		protected

			if(evt.ctrlKey || evt.altKey){ return; }

			switch(evt.charOrCode){
				case this._openSubMenuKey:
					this._moveToPopup(evt);
					event.stop(evt);
					break;
				case this._closeSubMenuKey:
					if(this.parentMenu){
						if(this.parentMenu._isMenuBar){
							this.parentMenu.focusPrev();
						}else{
							this.onCancel(false);
						}
					}else{
						event.stop(evt);
					}
					break;
			}
		}
	});
});

},
'cm/_base/_dom':function(){
define("cm/_base/_dom", [], function() {
  
/*
  This file includes generic functions for use with the DOM.
*/

/*
 * Modification History
 * --------------------
 * 24-Mar-2010 BD  [CR00191575] Added exit function to getParentByType() when 
 *                              the document root is reached. Handles the 
 *                              iframe scenario.
 */

  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  dojo.mixin(cm, {
    nextSibling: function(node, tagName) {
      //  summary:
            //            Returns the next sibling element matching tagName
      return cm._findSibling(node, tagName, true);
    },
    
    prevSibling: function(node, tagName) {
      //  summary:
            //            Returns the previous sibling element matching tagName
      return cm._findSibling(node, tagName, false);
    },
    
    getInput: function(name, multiple) {
      if(!dojo.isString(name)){
        return name;
      }
      var inputs = dojo.query("input[name='" + name + "'],select[name='" + name + "']");
      return multiple ? (inputs.length > 0 ? inputs : null) 
                                                                                  : (inputs.length > 0 ? inputs[0]:null);
    },
    
    getParentByClass: function(node, classStr) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      while (node) {
        if(dojo.hasClass(node, classStr)){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
    
    getParentByType: function(node, type) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      type = type.toLowerCase();
      var docRoot = "html";
      while (node) {
        // Give up when you reach the root of the doc,
        // applies to iframes
        if(node.tagName.toLowerCase() == docRoot){
          break;
        }
        if(node.tagName.toLowerCase() == type){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
  
    replaceClass: function(node, newCls, oldCls) {
      // summary:
      //   Replaces a single css class with another.
      //   node:   The node to operate on.
      //   newCls: The class to be added
      //   oldCls: The class to be removed
      dojo.removeClass(node, oldCls);
      dojo.addClass(node, newCls);
    },
    
    setClass: function(/* HTMLElement */node, /* string */classStr){
                  //      summary
                  //      Clobbers the existing list of classes for the node, replacing it with
                  //      the list given in the 2nd argument. Returns true or false
                  //      indicating success or failure.
                  node = dojo.byId(node);
                  var cs = new String(classStr);
                  try{
                          if(typeof node.className == "string"){
                                  node.className = cs;
                          }else if(node.setAttribute){
                                  node.setAttribute("class", classStr);
                                  node.className = cs;
                          }else{
                                  return false;
                          }
                  }catch(e){
                          dojo.debug("dojo.html.setClass() failed", e);
                  }
                  return true;
          },
  
    _findSibling: function(node, tagName, forward) {
      
      if(!node) { return null; }
      if(tagName) { tagName = tagName.toLowerCase(); }
      var param = forward ? "nextSibling":"previousSibling";
            do {
                    node = node[param];
            } while(node && node.nodeType != 1);
  
            if(node && tagName && tagName != node.tagName.toLowerCase()) {
                    return cm[forward ? "nextSibling":"prevSibling"](node, tagName);
            }
            return node;  //      Element
    },
    
    getViewport: function(){
                  // summary: returns a viewport size (visible part of the window)
          
                  // FIXME: need more docs!!
                  var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
                  if(dojo.isMozilla){
                          return {w: dd.clientWidth, h: w.innerHeight};   // Object
                  }else if(!dojo.isOpera && w.innerWidth){
                          return {w: w.innerWidth, h: w.innerHeight};             // Object
                  }else if (!dojo.isOpera && dd && dd.clientWidth){
                          return {w: dd.clientWidth, h: dd.clientHeight}; // Object
                  }else if (b.clientWidth){
                          return {w: b.clientWidth, h: b.clientHeight};   // Object
                  }
                  return null;    // Object
          },
          
          toggleDisplay: function(node) {
            dojo.style(node, "display", dojo.style(node, "display") == "none" ? "": "none");
          },
          
          
          
          endsWith: function(/*string*/str, /*string*/end, /*boolean*/ignoreCase){
                  // summary:
                  //      Returns true if 'str' ends with 'end'
          
                  if(ignoreCase){
                          str = str.toLowerCase();
                          end = end.toLowerCase();
                  }
                  if((str.length - end.length) < 0){
                          return false; // boolean
                  }
                  return str.lastIndexOf(end) == str.length - end.length; // boolean
          },
          
          hide: function(n){
                  dojo.style(n, "display", "none");
          },
          
          show: function(n){
                  dojo.style(n, "display", "");
          }
  });
  
  return cm;
});

},
'dijit/_base/typematic':function(){
define("dijit/_base/typematic", ["../typematic"], function(){
	// for back-compat, just loads top level module
});

},
'cwtk/util/EventHandler':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("cwtk/util/EventHandler", [
    "dojo", 
    "dojo/_base/declare"
], function(dojo, declare){

		return declare("cwtk.util.EventHandler", null, {

			addEventListener : function (event, func) {
				dojo.subscribe(event, func);
			},
			
			dispatchEvent : function (event, args) {
				dojo.publish(event, [args]);
			},
			
			initService: function(service) {
				dojo.ready(service.init);
			},
			
			registerAction: function(action) {
				this.addEventListener(action.eventType, action.execute);
				
			}
		});

});
},
'dojo/store/Memory':function(){
define("dojo/store/Memory", ["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine"], function(declare, QueryResults, SimpleQueryEngine) {
  //  module:
  //    dojo/store/Memory
  //  summary:
  //    The module defines an in-memory object store.


return declare("dojo.store.Memory", null, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo.store.api.Store.
	constructor: function(/*dojo.store.Memory*/ options){
		// summary:
		//		Creates a memory object store.
		// options:
		//		This provides any configuration information that will be mixed into the store.
		// 		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		//	summary:
		//		Retrieves an object by its identity
		//	id: Number
		//		The identity to use to lookup the object
		//	returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// 	summary:
		//		Returns an object's identity
		// 	object: Object
		//		The object to get the identity from
		//	returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// 	summary:
		//		Stores an object
		// 	object: Object
		//		The object to store.
		// 	options: dojo.store.api.Store.PutDirectives??
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		//	returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// 	summary:
		//		Creates an object, throws an error if the object already exists
		// 	object: Object
		//		The object to store.
		// 	options: dojo.store.api.Store.PutDirectives??
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		//	returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// 	summary:
		//		Deletes an object by its identity
		// 	id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		// 		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// 	summary:
		//		Queries the store for objects.
		// 	query: Object
		//		The query to use for retrieving objects from the store.
		//	options: dojo.store.api.Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		//	returns: dojo.store.api.Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// 	example:
		// 		Given the following store:
		//
		// 	|	var store = new dojo.store.Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// 	summary:
		//		Sets the given data as the source for this store, and indexes it
		//	data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

},
'idx/oneui/HoverCard':function(){
require({cache:{
'url:idx/oneui/templates/HoverCard.html':"<div class=\"idxOneuiHoverCard idxOneuiHoverCardLeft\">\r\n\t<div role=\"document\"> <span data-dojo-attach-point=\"closeButtonNode, focusNode\" class=\"idxOneuiHoverCardCloseIcon\" data-dojo-attach-event=\"ondijitclick: hide\" role=\"button\" tabIndex=\"0\"></span></div>\r\n\t\r\n\t<div data-dojo-attach-point=\"bodyNode\" class=\"idxOneuiHoverCardBody\">\t\r\n\t\t<div class=\"idxOneuiHoverCardGrip\" data-dojo-attach-point=\"gripNode\"></div>\r\n\t\t<div class=\"idxOneuiHoverCardContainer\" role='alert' data-dojo-attach-point=\"containerNode\">\t\t\r\n\t\t</div>\r\n\t\t<div class=\"idxOneuiHoverCardFooter\">\r\n\t\t\t<div class=\"idxOneuiHoverCardActionIcons\" data-dojo-attach-point=\"actionIcons\"></div>\r\n\t\t\t<span aria-haspopup=\"true\" data-dojo-attach-point=\"moreActionsNode\"></span>\r\n\t\t</div>\r\n\t\t<div class=\"idxOneuiHoverCardFooterExpand\"></div>\r\n\t</div>\r\n\t<div class=\"idxOneuiHoverCardConnector\" data-dojo-attach-point=\"connectorNode\"></div>\r\n</div>\r\n\r\n\r\n"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
* @name idx.oneui.HoverCard
* @class HoverCard provides pop-up information that displays when users hover the mouse pointer over an help indicator.  
* HoverCard is implemented according to standard and specification of IBM One UI(tm) 
* <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y21&vsub=*&hsub=*&openpanes=1111111111">Hover Preview Card</a></b>, 
* <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y44&vsub=*&hsub=*&openpanes=1111111111">Hover Person Card</a></b>
* @augments dijit.TooltipDialog
* @example
* 
&lt;!--Preview content of HoverCard--&gt;
&lt;div data-dojo-type="idx.oneui._Preview" data-dojo-props='
	id: "preview",
	title: "Preview Card title",
	image: "../../themes/oneui/idx/oneui/images/objectImagePlaceholder90px.png",
	content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam et purus lorem, eu semper massa. Phasellus rutrum, dui non ultrices convallis, nunc nunc dignissim neque, elementum imperdiet sapien massa ut risus&lt;br /&gt;&lt;br /&gt;"
'&gt;
&lt;/div&gt;
&lt;!--Declaration of Hover Preview Card--&gt;
&lt;div data-dojo-type="idx.oneui.HoverCard" 
	data-dojo-props='
		target:"anchor", 
		moreActions:[
			{label: "Item 1", onClick: fClick},
			{label: "Item 2", onClick: fClick},
			{label: "Item 3", onClick: fClick}
		],
		actions: [
			{iconClass: "placeHolderIcon", onClick: fClick, text:""},
			{iconClass: "placeHolderIcon", onClick: fClick, text:""},
			{iconClass: "placeHolderIcon", onClick: fClick, text:""}
		],
		content: "preview"
	'&gt;
&lt;/div&gt;
* <br>
* @example 
&lt;!--Declaration of Hover Person Card--&gt;
&lt;div dojoType="idx.widget.PersonCard" id="personInfo" query="{email: 'bcaceres@us.ibm.com'}"
url="https://w3-connections.ibm.com/profiles/json/profile.do" jsonp="callback"
spec="photo,fn,title,org,adr.work,tel.work,email.internet,sametime.awareness"
placeHolder="Sametime is not available on your client."&gt;&lt;/div&gt;

* @see dijit.TooltipDialog
**/
define("idx/oneui/HoverCard", [
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/keys", // keys
	"dijit/focus", 
	"dijit/a11y",
	"dojo/_base/event", // event.stop
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/_base/html",
	"dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
	"dijit/place",
	"dojo/dom",
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/dom-class",
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"dojo/_base/window", // win.body()
	"dojo/_base/connect",
	"dojo/_base/sniff", // has("ie")
	"dijit/_base/manager",	// manager.defaultDuration
	"dijit/BackgroundIframe",
	"dijit/TooltipDialog",
	"idx/oneui/Menu",
	"dijit/MenuItem",
	"dijit/form/DropDownButton",
	"dijit/form/Button",
	"dojo/text!./templates/HoverCard.html",
	"dijit/dijit",
	"dojo/i18n",
	"dojo/i18n!./nls/HoverCard"
], function(declare, array, keys, dijitfocus, a11y, event, fx, lang, html, domGeometry, place, dom, domStyle, domClass, Moveable, TimedMoveable, 
	win, connect, has, manager, BackgroundIframe, TooltipDialog, Menu, MenuItem, DropDownButton, Button, 
	template, dijit, i18n){

	var HoverCard = declare("idx.oneui.HoverCard", [TooltipDialog], {
	/** @lends idx.oneui.HoverCard.prototype */
		templateString: template,
		
		/**
		* target: String|HTML DOM
		*		Id of domNode or domNode to attach the HoverCard to.
		*		When user hovers over specified dom node, the HoverCard will appear.
		*		@type string
		**/	
		target: "",
		
		/**
		* draggable: Boolean
		*		Toggles the moveable aspect of the HoverCard. If true, HoverCard
		*		can be dragged by it's grippy bar. If false it will remain positioned 
		*		relative to the attached node
		*		@type boolean
		**/		
		draggable: true,
		
		/**
		 * The delay in milliseconds before the HoverCard displays
		 * @type integer
		 */
		showDelay: 500,		
		
		/**
		 * The delay in milliseconds before the HoverCard hides
		 * @type integer
		 */
		hideDelay: 800,	
		/**
		 * The items of "more action" menu at the bottom right of the HoverCard
		 * @type array
		*/
		moreActions: null,
		/**
		 * The items of "actions" listed at bottom left of HoverCard
		 * @type array
		 */
		actions: null,
		
		content: null,
		
		forceFocus: false,
		
		/**
		 * duration: Integer
		 * Milliseconds to fade in/fade out
		 * @type integer
		 */
		duration: manager.defaultDuration,
		
		postMixInProperties: function(){
			this.moreActionsLabel = i18n.getLocalization("idx.oneui", "HoverCard", this.lang).moreActionsLabel;
		},
		
		_setTargetAttr: function(/*String*/ target){
			// summary:
			//		Connect to specified node(s)

			var target = dom.byId(target);
			if(!target){return;}
			// Make connections
			this._connections = [
				this.connect(target, "onmouseenter", "_onHover"),
				this.connect(target, "onmouseleave", "_onUnHover"),				
				this.connect(target, "onkeypress", "_onConnectIdKey")
			];

			this._set("target", target);
		},
		_onConnectIdKey: function(/*Event*/evt){
            // summary:
            //		Handler for keyboard events
            // description:
            // tags:
            //		private
            var node = evt.target;
            
            if (evt.charOrCode == keys.ENTER || evt.charOrCode == keys.SPACE || evt.charOrCode == " ") {
                // Use setTimeout to avoid crash on IE, see #10396.
                 this._showTimer = setTimeout(lang.hitch(this, function(){
                    this.open(node)
                }), this.showDelay);
                
                event.stop(evt);     
            }
    	},
		
		_setActionsAttr: function(actions){
			array.forEach(actions, function(action){
				var button = new Button({
					iconClass:action.iconClass, 
					onClick: action.content ? lang.hitch(this, function(){
						//add content to footer expand
					}) : action.onClick,
					baseClass: "idxOneuiHoverCardFooterButton"})
				html.place(button.domNode, this.actionIcons);
				
			}, this);
		},
		
		_setMoreActionsAttr: function(actions){
			var menu = new Menu({});
			array.forEach(actions, function(action){
				menu.addChild(new MenuItem({label:action.label, onClick:action.onClick}));
			});
			menu.startup();
			var button = new DropDownButton({
				label: this.moreActionsLabel, 
				dropDown: menu,
				baseClass: "idxOneuiHoverCardMenu"}, this.moreActionsNode);
			this.moreActionsMenu = menu;
		},	
	
		_setContentAttr: function(content){
			var innerWidget = dijit.byId(content);
			if(!innerWidget.declaredClass){
				this.inherited(arguments);
			}else{
				html.place(innerWidget.domNode, this.containerNode);
				domClass.toggle(this.containerNode, "idxOneuiHoverCardWithoutPreviewImg", !innerWidget.image)
			}
		},
		/**
		 * Despite the name of this method, it actually handles both hover and focus
		 * events on the target node, setting a timer to show the HoverCard.
		 * @private
		 */
		_onHover: function(/*Event*/ e){			
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(lang.hitch(this, function(){this.open(target)}), this.showDelay);
			}
			if(this._hideTimer){
				clearTimeout(this._hideTimer);
				delete this._hideTimer;
			}
		},
		
		/**
		 * Despite the name of this method, it actually handles both mouseleave and blur
		 * events on the target node, hiding the HoverCard.
		 * @private
		 */
		_onUnHover: function(/*Event*/ /*===== e =====*/){
			// keep a HoverCard open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			if(!this._hideTimer){
				this._hideTimer = setTimeout(lang.hitch(this, function(){this.close()}), this.hideDelay);
			}
		}, 
		
		onBlur: function(){
			this._hideTimer = setTimeout(lang.hitch(this, function(){this.close()}), this.hideDelay);
		},
		
		_showConnector: function(){
			var connector = this.connectorNode;	
			domStyle.set(connector, "visibility", "visible");
		},		
		
		postCreate: function(){
			win.body().appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow")});
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide")});
			
			this.connect(this.gripNode, "onmouseenter", function(){domClass.add(this.gripNode,"idxOneuiHoverCardGripHover");});
			this.connect(this.gripNode, "onmouseleave", function(){domClass.remove(this.gripNode,"idxOneuiHoverCardGripHover");});			
			this.connect(this.domNode, "onkeypress", "_onKey");
			this.connect(this.domNode, "onmouseenter", function(){
				this._hovered = true;
				if(this._hideTimer){
					clearTimeout(this._hideTimer);
					delete this._hideTimer;
				}
			});
			this.connect(this.domNode, "onmouseleave", function(){
				this._hovered = false;
				this._onUnHover();
			});			
		},
		
		/**
		 * Display the HoverCard
		 * @public
		 */
		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the HoverCard; usually not called directly.
			// tags:
			//		private
			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			if(this.isShowingNow){
				if(this.forceFocus){
					this.focus();
				}
				return;}
			domClass.remove(this.domNode, "dijitHidden");
			if(dojo.isIE <= 7){
				domStyle.set(this.bodyNode, "width", domStyle.get(this.containerNode, "width") + 5 + "px");
			}
			this.show(this.domNode.innerHTML, target, this.position, !this.isLeftToRight(), this.textDir);
			if(this.forceFocus){
				this.focus();
			}
			this._connectNode = target;
			this.onShow(target, this.position);
		},
		/**
		 * Hide the HoverCard or cancel timer for show of HoverCard
		 */
		close: function(){
			if(this._connectNode && !this._hovered && !this._moved && 
				(!this.moreActionsMenu || !this.moreActionsMenu._hoveredChild)){
				this.hide(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},
		
		focus: function(){
			this.inherited(arguments);
			this._focus = true;
		},
		
		/**
		 * Display HoverCard around given node with specified contents.
		 * @param {string} innerHTML
		 * Contents of the hoverCard
		 * @param {DOM | Object} aroundNode
		 * Specifies that hoverCard should be next to this node / area
		 * @param {string[]} position
		 * List of positions to try to position tooltip (ex: ["right", "above"])
		 * @param {boolean} rtl
		 * Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		 * means "rtl"; specifies GUI direction, not text direction.
		 * @param {string} textDir
		 * Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		 */
		show:  function(innerHTML, aroundNode, position, rtl, textDir){
			
			this._showConnector();

			// reset width; it may have been set by orient() on a previous HoverCard show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous HoverCard is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			
			
			this.set("textDir", textDir);
			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : HoverCard.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the HoverCard connector for middle alignment.
			// This could not have been done in orient() since the HoverCard wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}

			
			var node = this.domNode,
				connector = this.connectorNode;
			if(this.gripNode && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.gripNode });
				
				this.connect(this._moveable, "onFirstMove", function(){
					domStyle.set(connector, "visibility", "hidden");
					domClass.add(this.gripNode,"idxOneuiHoverCardGripActive");
					this._moved = true;
				});
				this.connect(this._moveable, "onMoveStop", function(){
					domClass.remove(this.gripNode,"idxOneuiHoverCardGripActive");
					domClass.add(this.gripNode,"idxOneuiHoverCardGrip");
				});

			}else{
				//domClass.add(node,"dijitDialogFixed");
			}
			
				// show it
			domStyle.set(this.domNode, {
				"opacity": 0,
				"position": "absolute"
			});
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},
	
	
		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ HoverCardCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for HoverCard node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the HoverCard's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default

			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var HoverCardSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "idxOneuiHoverCard " +
				{
					"MR-ML": "idxOneuiHoverCardRight",
					"ML-MR": "idxOneuiHoverCardLeft",
					"TM-BM": "idxOneuiHoverCardAbove",
					"BM-TM": "idxOneuiHoverCardBelow",
					"BL-TL": "idxOneuiHoverCardBelow idxOneuiHoverCardABLeft",
					"TL-BL": "idxOneuiHoverCardAbove idxOneuiHoverCardABLeft",
					"BR-TR": "idxOneuiHoverCardBelow idxOneuiHoverCardABRight",
					"TR-BR": "idxOneuiHoverCardAbove idxOneuiHoverCardABRight",
					"BR-BL": "idxOneuiHoverCardRight",
					"BL-BR": "idxOneuiHoverCardLeft",
					"TR-TL": "idxOneuiHoverCardRight"
					//"MR-ML": "idxOneuiHoverCardLeft"
				}[aroundCorner + "-" + HoverCardCorner];

			// reduce HoverCard's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = domGeometry.getContentBox(this.domNode);

			var width = Math.min((Math.max(HoverCardSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;

			this.domNode.style.width = width+"px";

			//Adjust width for HoverCards that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our HoverCard needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + domStyle.get(this.domNode,"paddingLeft") + domStyle.get(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}

			// Reposition the HoverCard connector.
			if(HoverCardCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = domGeometry.getMarginBox(node);
				var HoverCardConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The HoverCard starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - ((aroundNodeCoords.h + HoverCardConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of HoverCard content, or top of connector
					// extend past top of HoverCard content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - HoverCardConnectorHeight/2, 0),
						mb.h - HoverCardConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the HoverCard back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - HoverCardSpaceAvaliableWidth);
		},
		
		/**
		 * Hide the HoverCard on specified node / area
		 * @param {DOM | Object} aroundNode
		 */
		hide: function(aroundNode){
			
			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode || this.isShowingNow){
				// this hide request is for the currently displayed HoverCard
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				
				this.fadeOut.play();
				this._focus = false;
				this._hovered = false;
				this._moved = false;
				dijitfocus.focus(this._connectNode);
				
			}else{
				// just ignore the call, it's for a HoverCard that has already been erased
			}
		},
		
		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},
		
		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			domClass.add(this.domNode, "dijitHidden");
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		},
		_getFocusItems: function(){
            // summary:
            //		Finds focusable items in dialog,
            //		and sets this._firstFocusItem and this._lastFocusItem
            // tags:
            //		protected
            
            var elems = a11y._getTabNavigable(this.domNode);
            this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
            this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
     },
		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handler for keyboard events
			// description:
			//		Keep keyboard focus in dialog; close dialog on escape key
			// tags:
			//		private

			var node = evt.target;
			if(evt.charOrCode === keys.TAB){
				this._getFocusItems(this.domNode);
			}
			var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
			if(evt.charOrCode == keys.ESCAPE){
				// Use setTimeout to avoid crash on IE, see #10396.
				setTimeout(lang.hitch(this, "hide"), 0);
				event.stop(evt);
			}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB){
				if(!singleFocusItem){
					dijitfocus.focus(this._lastFocusItem); // send focus to last item in dialog
				}
				event.stop(evt);
			}else if(node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey){
				if(!singleFocusItem){
					dijitfocus.focus(this._firstFocusItem); // send focus to first item in dialog
				}
				event.stop(evt);
			}else if(evt.charOrCode === keys.TAB){
				// we want the browser's default tab handling to move focus
				// but we don't want the tab to propagate upwards
				evt.stopPropagation();
			}
		}
		
	});
	
//	// summary:
//		//		Static method to display HoverCard w/specified contents in specified position.
//		//		See description of idx.oneui.HoverCard.defaultPosition for details on position parameter.
//		//		If position is not specified then idx.oneui.HoverCard.defaultPosition is used.
//		// innerHTML: String
//		//		Contents of the HoverCard
//		// aroundNode: dijit.__Rectangle
//		//		Specifies that HoverCard should be next to this node / area
//		// position: String[]?
//		//		List of positions to try to position HoverCard (ex: ["right", "above"])
//		// rtl: Boolean?
//		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
//		//		means "rtl"; specifies GUI direction, not text direction.
//		// textDir: String?
//		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.	
//	HoverCard.show = idx.oneui.showHoverCard = function(innerHTML, title, action, imgSrc, aroundNode, position, rtl, textDir){
//		
//		if(!HoverCard._masterTT){ idx.oneui._masterTT = HoverCard._masterTT = new MasterHoverCard(); }
//		return HoverCard._masterTT.show(innerHTML, title, action, imgSrc, aroundNode, position, rtl, textDir);
//	};
//
//	// summary:
//		//		Static method to hide the HoverCard displayed via showHoverCard()
//	HoverCard.hide = idx.oneui.hideHoverCard = function(aroundNode){
//		
//		return HoverCard._masterTT && HoverCard._masterTT.hide(aroundNode);
//	};
//	
	HoverCard.defaultPosition = ["after-centered", "before-centered", "below", "above"];
	
	return HoverCard;	
	
});

},
'curam/util/DialogObject':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.util.DialogObject
 * @namespace Provides access to a dialog instance.
 * 
 */
define("curam/util/DialogObject", ["curam/dialog",
        "curam/util"
        ], function() { 
/*
 * Modification History
 * --------------------
 * 05-Feb-2013  MV  [CR00366128] Fix documentation comment.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 13-Jan-2011  MV  [CR00241667] Added close() function. Updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the registerOnDisplayHandler() function.
 * 04-Nov-2010  MV  [CR00229849] Unsubscribe handlers in the right context.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */


var DialogObject = dojo.declare("curam.util.DialogObject", null, 
/** @lends curam.util.DialogObject.prototype */{  

    /**
     * Holds ID of the dialog in the current context.
     * @private
     */
    _id: null,
    
    /**
     * Constructor takes the input token and uses it to listen for a 
     * specific publish event which will return the dialogId for the
     * opened dialog.
     *
     * @constructor
     * @private
     */
    constructor: function(tokenValue, id) {
      if (!id) {
        var unSubConstructor = 
          window.top.dojo.subscribe(
            "/curam/dialog/uim/opened/" + tokenValue, this, function(dialogID) {
          this._id = dialogID;
          window.top.dojo.unsubscribe(unSubConstructor);
        });
      
      } else {
        this._id = id;
      }
    },
    
    /**
     * Registers a custom function that will be called before the dialog
     * is closed.
     * 
     * @param {Function} handler The handler function for the BeforeClose event.
     */
    registerBeforeCloseHandler: function(handler) {
      var unSubClose = 
        window.top.dojo.subscribe(
          "/curam/dialog/BeforeClose", this, function(dialogID) {
            if (dialogID == this._id) {
              handler();
            }
            window.top.dojo.unsubscribe(unSubClose);
      });
    },
    
    /**
     * Registers a custom handler for the onDispaly event of the dialog. 
     * If the handler is registered after the dialog has been displayed, then
     * it is executed immediately.
     * 
     * @param handler
     *    The handler function for the dialog OnDisplay event. The handler
     *    will be passed the size object in the following form:
     *    {width: 125, height: 236}
     */
    registerOnDisplayHandler: function(handler) {
      if (curam.dialog._displayed == true) {
        handler(curam.dialog._size);
        
      } else {
        var ut = window.top.dojo.subscribe(
            "/curam/dialog/displayed", this, function(dialogID, size) {
              if (dialogID == this._id) {
                handler(size);
              }
              window.top.dojo.unsubscribe(ut);
            });
      }
    },
    
    /**
     * Closes the dialog, optionally refreshing or redirecting the parent window.
     * 
     * @param {Boolean} [refreshParent=false] Should the parent be refreshed
     *              when this dialog closes?
     * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
     *      should be redirected to when this dialog closes. Alternatively
     *      a full URL including the page parameters can be passed.
     * @param {Object} [pageParameters] Page parameters to be used when
     *        redirecting the parent to the new page. The following format
     *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
     *        The infrastructure handles URL-encoding the values so do NOT encode
     *        them yourself.
     *        If full URL is specified then the pageParameters are ignored.
     */
    close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
        /*optional*/ pageParameters) {
      
      var win = curam.util.UimDialog._getDialogFrameWindow(this._id);
      var parentWindow = win.curam.dialog.getParentWindow(win);
      if (refreshParent && !newPageIdOrFullUrl) {
        win.curam.dialog.forceParentRefresh();
        curam.dialog.doRedirect(parentWindow, null);
        
      } else if (newPageIdOrFullUrl) {
        var newParentUrl = newPageIdOrFullUrl;
        // distinguish between pageId and full URL
        if (newPageIdOrFullUrl.indexOf("Page.do") == -1) {
          newParentUrl = newPageIdOrFullUrl + "Page.do"
              + curam.util.makeQueryString(pageParameters);
        }
  
        curam.dialog.doRedirect(parentWindow, newParentUrl);
      }
  
      curam.dialog.closeModalDialog();
    }
  });
  
  return DialogObject;  
});

},
'curam/define':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/define", [], function() {
  
  /*
   * Modification History
   * --------------------
   * 29-Jul-2011  MV [CR00269970] Initial version.
   */

  /**
   * This package contains function for working with classes in our code.
   */

  if(typeof(dojo.global.curam) == "undefined") {
    dojo.global.curam = {};
  }

  if (typeof(dojo.global.curam.define) == "undefined") {
    dojo.mixin(dojo.global.curam, {define: {}});
  }

  dojo.mixin(dojo.global.curam.define, {
    /**
     * Defines a singleton class ensuring any packages are created and no
     * existing packages are overwritten in the process.
     * 
     * @param {String} singletonName Name of the singleton class to be defined.cdej
     * @param {Object} [content] Optional content of the singleton class.
     */
    singleton: function(singletonName, content) {
      var parts = singletonName.split(".");
      
      // we assume we are runnning within a browser environment so the window
      // object is available.
      var currentContext = window;
      
      // now check for existence and create any missing packages
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (typeof currentContext[part] == "undefined") {
          currentContext[part] = {};
        }
        currentContext = currentContext[part];
      }
      
      // now set the content
      if (content) {
        dojo.mixin(currentContext, content);
      }
    }
  });
  
  return dojo.global.curam.define;
});

},
'dojox/storage':function(){
// wrapped by build app
define("dojox/storage", ["dijit","dojo","dojox","dojo/require!dojox/storage/_common"], function(dijit,dojo,dojox){
dojo.provide("dojox.storage");
dojo.require("dojox.storage._common");

});

},
'curam/util/ui/AppExitConfirmation':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 03-Apr-2013  MV  [] Initial version.
 */

/**
 * @name curam.util.ui.AppExitConfirmation
 * @namespace Controls the page exit confirmation dialog functionality.
 */
define("curam/util/ui/AppExitConfirmation", ["curam/define",
        "dojo/_base/array",
        "curam/util/ui/AppExitConditionHandler"
        ], function(cdef, darray) {
  
  cdef.singleton("curam.util.ui.AppExitConfirmation",
      /** @lends curam.util.ui.AppExitConfirmation.prototype */ {
    _exitConditionHandlers: [],
    _lastClickedToken: null,
    _lastClicked: null,
    
    /**
     * Performs the actual confirmation dialog processing.
     * @returns {String} Empty string so that no custom message is displayed.
     */
    _confirmationHandler: function() {
      var mesg = " "; // no message
      // By returning a string here we are asking the browser to display
      // a confirmation dialog before allowing page unload.
      e.returnValue = mesg; // IE
      return mesg; // Any other browsers
    },

    /**
     * Installs a handler which will cause a confirmation dialog to be displayed
     * when the user tries to leave the application by refreshing or closing
     * the browser window or by navigating away from the application.
     *
     * @returns A token to be used by the uninstall function. 
     */
    install: function() {
      // first install an onclick handler that will help us recognize mailto:
      // link clicks
      curam.util.ui.AppExitConfirmation._lastClickedToken =
        dojo.connect(dojo.global, "onclick", null, function(e) {
          e = e || window.event;
          curam.util.ui.AppExitConfirmation._lastClicked = e.target;
        });
      
      curam.util.ui.AppExitConfirmation.registerExitConditionHandler(
          new curam.util.ui.AppExitConditionHandler(function() {
            var lastClicked = curam.util.ui.AppExitConfirmation._lastClicked;

            // disallow confirmation for mailto links
            var disallow = lastClicked && lastClicked.href
                && lastClicked.href.substring(0,7) === 'mailto:';

            // clean up last clicked info after using it
            curam.util.ui.AppExitConfirmation._lastClicked = null;
            return disallow ? false : true;
          }));
      
      return dojo.connect(dojo.global, "onbeforeunload", null, function(e) {
        var exitConditionHandlers =
                  curam.util.ui.AppExitConfirmation._exitConditionHandlers;

        // Ask all registered exit condition handlers if we can display
        // confirmation dialog. If any of them disagrees we do not ask the user
        // and page unload is allowed to proceed.
        var doConfirmation = darray.every(exitConditionHandlers,
            function(eh) {
              return eh.isConfirmationAllowed();
            });

        if (doConfirmation) {
          return curam.util.ui.AppExitConfirmation._confirmationHandler(
              "Number of condition handlers consulted: "
                + exitConditionHandlers.length);
        }
      });
    },
    
    /**
     * Installs an alternative handler to be called for confirmation.
     * Used for automated testing purposes.
     * @param handler Function returning a message.
     */
    _setTestHandler: function(handler) {
      curam.util.ui.AppExitConfirmation._confirmationHandler = handler;
    },
    
    uninstall: function(token) {
      dojo.disconnect(token);

      // also disconnect last clicked element handler
      dojo.disconnect(curam.util.ui.AppExitConfirmation._lastClickedToken);
      curam.util.ui.AppExitConfirmation._lastClicked = null;
      
      // remove handlers
      curam.util.ui.AppExitConfirmation._exitConditionHandlers = [];
    },
    
    /**
     * 
     * @param {curam/util/ui/AppExitConitionHandler} handler
     */
    registerExitConditionHandler: function(handler) {
      curam.util.ui.AppExitConfirmation._exitConditionHandlers.push(handler);
    }
  });
  
  return curam.util.ui.AppExitConfirmation;
});

},
'dijit/typematic':function(){
define("dijit/typematic", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect", // connect.connect
	"dojo/_base/event", // event.stop
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin, lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie")
	"."		// setting dijit.typematic global
], function(array, connect, event, kernel, lang, on, has, dijit){

// module:
//		dijit/typematic
// summary:
//		These functions are used to repetitively call a user specified callback
//		method when a specific key or mouse click over a specific DOM node is
//		held down for a specific amount of time.
//		Only 1 such event is allowed to occur on the browser page at 1 time.

var typematic = (dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);

		// Schedule next event, timer is at most minDelay (default 10ms) to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			this._minDelay);
		this._timer = setTimeout(lang.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay (optional):
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay (optional):
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		// minDelay (optional):
		//		the maximum delay in milliseconds for event to fire, default=10ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._minDelay = minDelay || 10;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = lang.hitch(_this, callback);
			this._fireEventAndReload();
			this._evt = lang.mixin({faux: true}, evt);
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for:
		// 		charOrCode:
		//			the printable character (string) or keyCode (number) to listen for.
		// 		keyCode:
		//			(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// 		charCode:
		//			(deprecated - use charOrCode) the charCode (number) to listen for.
		// 		ctrlKey:
		//			desired ctrl key state to initiate the callback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// 		altKey:
		//			same as ctrlKey but for the alt key
		// 		shiftKey:
		//			same as ctrlKey but for the shift key
		// returns:
		//		a connection handle
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			kernel.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			kernel.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		var handles = [
			on(node, connect._keypress, lang.hitch(this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					event.stop(evt);
					typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
				}else if(typematic._obj == keyObject){
					typematic.stop();
				}
			})),
			on(node, "keyup", lang.hitch(this, function(){
				if(typematic._obj == keyObject){
					typematic.stop();
				}
			}))
		];
		return { remove: function(){ array.forEach(handles, function(h){ h.remove(); }); } };
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		a connection handle
		var handles =  [
			on(node, "mousedown", lang.hitch(this, function(evt){
				event.stop(evt);
				typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
			})),
			on(node, "mouseup", lang.hitch(this, function(evt){
				if(this._obj){
					event.stop(evt);
				}
				typematic.stop();
			})),
			on(node, "mouseout", lang.hitch(this, function(evt){
				event.stop(evt);
				typematic.stop();
			})),
			on(node, "mousemove", lang.hitch(this, function(evt){
				evt.preventDefault();
			})),
			on(node, "dblclick", lang.hitch(this, function(evt){
				event.stop(evt);
				if(has("ie") < 9){
					typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
					setTimeout(lang.hitch(this, typematic.stop), 50);
				}
			}))
		];
		return { remove: function(){ array.forEach(handles, function(h){ h.remove(); }); } };
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		a connection handle
		var handles = [
			this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay),
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay)
		];
		return { remove: function(){ array.forEach(handles, function(h){ h.remove(); }); } };
	}
});

return typematic;

});

},
'url:idx/oneui/form/templates/TextBox.html':"<div id=\"widget_${id}\" class=\"dijitInline dijitReset dijitLeft idxComposite\"\r\n\t><div class=\"idxLabel dijitInline dijitHidden\"><span class=\"idxRequiredIcon\">*&nbsp</span><label for=\"${id}\" dojoAttachPoint=\"compLabelNode\"></label></div\r\n\t><div class=\"dijitInline\"\r\n\t\t><div dojoAttachPoint='stateNode,oneuiBaseNode' class=\"dijit dijitReset dijitInline dijitLeft\" role=\"presentation\"\r\n\t\t\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\" ${!nameAttrSetting} type='${type}'/\r\n\t\t\t></div\r\n\t\t></div\r\n\t\t><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"></div\r\n\t\t><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\r\n\t\t><div class='dijitValidationIcon'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\r\n\t\t></div\r\n\t></div\r\n\t><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\r\n\t></div\r\n></div>\r\n",
'url:cwtk/widget/templates/DropDown.html':"<span class=\"dijit dijitReset dijitInline\">\r\n  <span class='dijitReset dijitInline' \r\n    data-dojo-attach-event=\"ondijitclick:_onClick\" \r\n    data-dojo-attach-point=\"_buttonNode\" >\r\n    <span class=\"dijitReset dijitStretch dijitButtonContents\"   \r\n      data-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"   \r\n      role=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\">\r\n      <span class=\"dijitReset dijitInline dijitIcon\" \r\n        data-dojo-attach-point=\"iconNode\">\n      </span>\r\n      <span class=\"dijitReset dijitInline dijitButtonText\" \r\n        data-dojo-attach-point=\"containerNode,_popupStateNode\" \r\n        id=\"${id}_label\">\n      </span>\r\n    </span>\r\n  </span >\r\n  <input ${!nameAttrSetting} type=\"${type}\" \r\n    value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"  \r\n    data-dojo-attach-point=\"valueNode\"/>\r\n</span>",
'dojo/io/iframe':function(){
define("dojo/io/iframe", ["../main", "require"], function(dojo, require) {
	// module:
	//		dojo/io/iframe
	// summary:
	//		TODOC

dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.iframe.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply
		//		to this type. The following additional properties are allowed
		//		for dojo.io.iframe.send():
		//	method: String?
		//		The HTTP method to use. "GET" or "POST" are the only supported
		//		values.  It will try to read the value from the form node's
		//		method, then try this argument. If neither one exists, then it
		//		defaults to POST.
		//	handleAs: String?
		//		Specifies what format the result data should be given to the
		//		load/handle callback. Valid values are: text, html, xml, json,
		//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
		//		server response should be an HTML file with a textarea element.
		//		The response data should be inside the textarea element. Using an
		//		HTML document the only reliable, cross-browser way this
		//		transport can know when the response has loaded. For the html
		//		handleAs value, just return a normal HTML document.  NOTE: xml
		//		is now supported with this transport (as of 1.1+); a known issue
		//		is if the XML document in question is malformed, Internet Explorer
		//		will throw an uncatchable error.
		//	content: Object?
		//		If "form" is one of the other args properties, then the content
		//		object properties become hidden form form elements. For
		//		instance, a content object of {name1 : "value1"} is converted
		//		to a hidden form element with a name of "name1" and a value of
		//		"value1". If there is not a "form" property, then the content
		//		object is converted into a name=value&name=value string, by
		//		using dojo.objectToQuery().
		this.method = method;
		this.handleAs = handleAs;
		this.content = content;
	}
});
=====*/

dojo.io.iframe = {
	// summary:
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)

	create: function(/*String*/fname, /*String*/onloadstr, /*String?*/uri){
		//	summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo.io.iframe request. Just call send().
		//	fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		//	onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		//	uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
		if(window[fname]){ return window[fname]; }
		if(window.frames[fname]){ return window.frames[fname]; }
		var turi = uri;
		if(!turi){
			if(dojo.config["useXDomain"] && !dojo.config["dojoBlankHtmlUrl"]){
				console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"
					+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
					+ " to the path on your domain to blank.html");
			}
			turi = (dojo.config["dojoBlankHtmlUrl"]||require.toUrl("../resources/blank.html"));
		}
		var cframe = dojo.place(
			'<iframe id="'+fname+'" name="'+fname+'" src="'+turi+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
		dojo.body());

		window[fname] = cframe;

		return cframe;
	},

	setSrc: function(/*DOMNode*/iframe, /*String*/src, /*Boolean*/replace){
		//summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
		try{
			if(!replace){
				if(dojo.isWebKit){
					iframe.location = src;
				}else{
					frames[iframe.name].location = src;
				}
			}else{
				// Fun with DOM 0 incompatibilities!
				var idoc;
				if(dojo.isIE || dojo.isWebKit){
					idoc = iframe.contentWindow.document;
				}else{ //  if(d.isMozilla){
					idoc = iframe.contentWindow;
				}

				//For Safari (at least 2.0.3) and Opera, if the iframe
				//has just been created but it doesn't have content
				//yet, then iframe.document may be null. In that case,
				//use iframe.location and return.
				if(!idoc){
					iframe.location = src;
				}else{
					idoc.location.replace(src);
				}
			}
		}catch(e){
			console.log("dojo.io.iframe.setSrc: ", e);
		}
	},

	doc: function(/*DOMNode*/iframeNode){
		//summary: Returns the document object associated with the iframe DOM Node argument.
		return iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(dojo.doc.frames[iframeNode.name])&&
				(dojo.doc.frames[iframeNode.name].document)
			) || null;
	},

	send: function(/*dojo.io.iframe.__ioArgs*/args){
		//summary:
		//		Function that sends the request to the server.
		//		This transport can only process one send() request at a time, so if send() is called
		//multiple times, it will queue up the calls and only process one at a time.
		if(!this["_frame"]){
			this._frame = this.create(this._iframeName, dojo._scopeName + ".io.iframe._iframeOnload();");
		}

		//Set up the deferred.
		var dfd = dojo._ioSetArgs(
			args,
			function(/*Deferred*/dfd){
				//summary: canceller function for dojo._ioSetArgs call.
				dfd.canceled = true;
				dfd.ioArgs._callNext();
			},
			function(/*Deferred*/dfd){
				//summary: okHandler function for dojo._ioSetArgs call.
				var value = null;
				try{
					var ioArgs = dfd.ioArgs;
					var dii = dojo.io.iframe;
					var ifd = dii.doc(dii._frame);
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					value = ifd; //html
					if(handleAs != "html"){
						if(handleAs == "xml"){
							//	FF, Saf 3+ and Opera all seem to be fine with ifd being xml.  We have to
							//	do it manually for IE6-8.  Refs #6334.
							if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){
								dojo.query("a", dii._frame.contentWindow.document.documentElement).orphan();
								var xmlText=(dii._frame.contentWindow.document).documentElement.innerText;
								xmlText=xmlText.replace(/>\s+</g, "><");
								xmlText=dojo.trim(xmlText);
								//Reusing some code in base dojo for handling XML content.  Simpler and keeps
								//Core from duplicating the effort needed to locate the XML Parser on IE.
								var fauxXhr = { responseText: xmlText };
								value = dojo._contentHandlers["xml"](fauxXhr); // DOMDocument
							}
						}else{
							value = ifd.getElementsByTagName("textarea")[0].value; //text
							if(handleAs == "json"){
								value = dojo.fromJson(value); //json
							}else if(handleAs == "javascript"){
								value = dojo.eval(value); //javascript
							}
						}
					}
				}catch(e){
					value = e;
				}finally{
					ioArgs._callNext();
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				//summary: errHandler function for dojo._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				dfd.ioArgs._callNext();
				return error;
			}
		);

		//Set up a function that will fire the next iframe request. Make sure it only
		//happens once per deferred.
		dfd.ioArgs._callNext = function(){
			if(!this["_calledNext"]){
				this._calledNext = true;
				dojo.io.iframe._currentDfd = null;
				dojo.io.iframe._fireNextRequest();
			}
		};

		this._dfdQueue.push(dfd);
		this._fireNextRequest();

		//Add it the IO watch queue, to get things like timeout support.
		dojo._ioWatch(
			dfd,
			function(/*Deferred*/dfd){
				//validCheck
				return !dfd.ioArgs["_hasError"];
			},
			function(dfd){
				//ioCheck
				return (!!dfd.ioArgs["_finished"]);
			},
			function(dfd){
				//resHandle
				if(dfd.ioArgs._finished){
					dfd.callback(dfd);
				}else{
					dfd.errback(new Error("Invalid dojo.io.iframe request state"));
				}
			}
		);

		return dfd;
	},

	_currentDfd: null,
	_dfdQueue: [],
	_iframeName: dojo._scopeName + "IoIframe",

	_fireNextRequest: function(){
		//summary: Internal method used to fire the next request in the bind queue.
		try{
			if((this._currentDfd)||(this._dfdQueue.length == 0)){ return; }
			//Find next deferred, skip the canceled ones.
			do{
				var dfd = this._currentDfd = this._dfdQueue.shift();
			} while(dfd && dfd.canceled && this._dfdQueue.length);

			//If no more dfds, cancel.
			if(!dfd || dfd.canceled){
				this._currentDfd =  null;
				return;
			}

			var ioArgs = dfd.ioArgs;
			var args = ioArgs.args;

			ioArgs._contentToClean = [];
			var fn = dojo.byId(args["form"]);
			var content = args["content"] || {};
			if(fn){
				if(content){
					// if we have things in content, we need to add them to the form
					// before submission
					var pHandler = function(name, value) {
						dojo.create("input", {type: "hidden", name: name, value: value}, fn);
						ioArgs._contentToClean.push(name);
					};
					for(var x in content){
						var val = content[x];
						if(dojo.isArray(val) && val.length > 1){
							var i;
							for (i = 0; i < val.length; i++) {
								pHandler(x,val[i]);
							}
						}else{
							if(!fn[x]){
								pHandler(x,val);
							}else{
								fn[x].value = val;
							}
						}
					}
				}
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actnNode = fn.getAttributeNode("action");
				var mthdNode = fn.getAttributeNode("method");
				var trgtNode = fn.getAttributeNode("target");
				if(args["url"]){
					ioArgs._originalAction = actnNode ? actnNode.value : null;
					if(actnNode){
						actnNode.value = args.url;
					}else{
						fn.setAttribute("action",args.url);
					}
				}
				if(!mthdNode || !mthdNode.value){
					if(mthdNode){
						mthdNode.value= (args["method"]) ? args["method"] : "post";
					}else{
						fn.setAttribute("method", (args["method"]) ? args["method"] : "post");
					}
				}
				ioArgs._originalTarget = trgtNode ? trgtNode.value: null;
				if(trgtNode){
					trgtNode.value = this._iframeName;
				}else{
					fn.setAttribute("target", this._iframeName);
				}
				fn.target = this._iframeName;
				dojo._ioNotifyStart(dfd);
				fn.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe
				var tmpUrl = args.url + (args.url.indexOf("?") > -1 ? "&" : "?") + ioArgs.query;
				dojo._ioNotifyStart(dfd);
				this.setSrc(this._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.errback(e);
		}
	},

	_iframeOnload: function(){
		var dfd = this._currentDfd;
		if(!dfd){
			this._fireNextRequest();
			return;
		}

		var ioArgs = dfd.ioArgs;
		var args = ioArgs.args;
		var fNode = dojo.byId(args.form);

		if(fNode){
			// remove all the hidden content inputs
			var toClean = ioArgs._contentToClean;
			for(var i = 0; i < toClean.length; i++) {
				var key = toClean[i];
				//Need to cycle over all nodes since we may have added
				//an array value which means that more than one node could
				//have the same .name value.
				for(var j = 0; j < fNode.childNodes.length; j++){
					var chNode = fNode.childNodes[j];
					if(chNode.name == key){
						dojo.destroy(chNode);
						break;
					}
				}
			}

			// restore original action + target
			if(ioArgs["_originalAction"]){
				fNode.setAttribute("action", ioArgs._originalAction);
			}
			if(ioArgs["_originalTarget"]){
				fNode.setAttribute("target", ioArgs._originalTarget);
				fNode.target = ioArgs._originalTarget;
			}
		}

		ioArgs._finished = true;
	}
};

return dojo.io.iframe;
});

},
'dijit/form/_FormSelectWidget':function(){
define("dijit/form/_FormSelectWidget", [
	"dojo/_base/array", // array.filter array.forEach array.map array.some
	"dojo/aspect", // aspect.after
	"dojo/data/util/sorter", // util.sorter.createSortFunction
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel",	// _scopeName
	"dojo/_base/lang", // lang.delegate lang.isArray lang.isObject lang.hitch
	"dojo/query", // query
	"./_FormValueWidget"
], function(array, aspect, sorter, declare, dom, domClass, kernel, lang, query, _FormValueWidget){

/*=====
	var _FormValueWidget = dijit.form._FormValueWidget;
=====*/

// module:
//		dijit/form/_FormSelectWidget
// summary:
//		Extends _FormValueWidget in order to provide "select-specific"
//		values - i.e., those values that are unique to <select> elements.


/*=====
dijit.form.__SelectOption = function(){
	// value: String
	//		The value of the option.  Setting to empty (or missing) will
	//		place a separator at that location
	// label: String
	//		The label for our option.  It can contain html tags.
	// selected: Boolean
	//		Whether or not we are a selected option
	// disabled: Boolean
	//		Whether or not this specific option is disabled
	this.value = value;
	this.label = label;
	this.selected = selected;
	this.disabled = disabled;
}
=====*/

return declare("dijit.form._FormSelectWidget", _FormValueWidget, {
	// summary:
	//		Extends _FormValueWidget in order to provide "select-specific"
	//		values - i.e., those values that are unique to <select> elements.
	//		This also provides the mechanism for reading the elements from
	//		a store, if desired.

	// multiple: [const] Boolean
	//		Whether or not we are multi-valued
	multiple: false,

	// options: dijit.form.__SelectOption[]
	//		The set of options for our select item.  Roughly corresponds to
	//		the html <option> tag.
	options: null,

	// store: dojo.data.api.Identity
	//		A store which, at the very least implements dojo.data.api.Identity
	//		to use for getting our list of options - rather than reading them
	//		from the <option> html tags.
	store: null,

	// query: object
	//		A query to use when fetching items from our store
	query: null,

	// queryOptions: object
	//		Query options to use when fetching from the store
	queryOptions: null,

	// onFetch: Function
	//		A callback to do with an onFetch - but before any items are actually
	//		iterated over (i.e. to filter even further what you want to add)
	onFetch: null,

	// sortByLabel: Boolean
	//		Flag to sort the options returned from a store by the label of
	//		the store.
	sortByLabel: true,


	// loadChildrenOnOpen: Boolean
	//		By default loadChildren is called when the items are fetched from the
	//		store.  This property allows delaying loadChildren (and the creation
	//		of the options/menuitems) until the user clicks the button to open the
	//		dropdown.
	loadChildrenOnOpen: false,

	getOptions: function(/*anything*/ valueOrIdx){
		// summary:
		//		Returns a given option (or options).
		// valueOrIdx:
		//		If passed in as a string, that string is used to look up the option
		//		in the array of options - based on the value property.
		//		(See dijit.form.__SelectOption).
		//
		//		If passed in a number, then the option with the given index (0-based)
		//		within this select will be returned.
		//
		//		If passed in a dijit.form.__SelectOption, the same option will be
		//		returned if and only if it exists within this select.
		//
		//		If passed an array, then an array will be returned with each element
		//		in the array being looked up.
		//
		//		If not passed a value, then all options will be returned
		//
		// returns:
		//		The option corresponding with the given value or index.  null
		//		is returned if any of the following are true:
		//			- A string value is passed in which doesn't exist
		//			- An index is passed in which is outside the bounds of the array of options
		//			- A dijit.form.__SelectOption is passed in which is not a part of the select

		// NOTE: the compare for passing in a dijit.form.__SelectOption checks
		//		if the value property matches - NOT if the exact option exists
		// NOTE: if passing in an array, null elements will be placed in the returned
		//		array when a value is not found.
		var lookupValue = valueOrIdx, opts = this.options || [], l = opts.length;

		if(lookupValue === undefined){
			return opts; // dijit.form.__SelectOption[]
		}
		if(lang.isArray(lookupValue)){
			return array.map(lookupValue, "return this.getOptions(item);", this); // dijit.form.__SelectOption[]
		}
		if(lang.isObject(valueOrIdx)){
			// We were passed an option - so see if it's in our array (directly),
			// and if it's not, try and find it by value.
			if(!array.some(this.options, function(o, idx){
				if(o === lookupValue ||
					(o.value && o.value === lookupValue.value)){
					lookupValue = idx;
					return true;
				}
				return false;
			})){
				lookupValue = -1;
			}
		}
		if(typeof lookupValue == "string"){
			for(var i=0; i<l; i++){
				if(opts[i].value === lookupValue){
					lookupValue = i;
					break;
				}
			}
		}
		if(typeof lookupValue == "number" && lookupValue >= 0 && lookupValue < l){
			return this.options[lookupValue]; // dijit.form.__SelectOption
		}
		return null; // null
	},

	addOption: function(/*dijit.form.__SelectOption|dijit.form.__SelectOption[]*/ option){
		// summary:
		//		Adds an option or options to the end of the select.  If value
		//		of the option is empty or missing, a separator is created instead.
		//		Passing in an array of options will yield slightly better performance
		//		since the children are only loaded once.
		if(!lang.isArray(option)){ option = [option]; }
		array.forEach(option, function(i){
			if(i && lang.isObject(i)){
				this.options.push(i);
			}
		}, this);
		this._loadChildren();
	},

	removeOption: function(/*String|dijit.form.__SelectOption|Number|Array*/ valueOrIdx){
		// summary:
		//		Removes the given option or options.  You can remove by string
		//		(in which case the value is removed), number (in which case the
		//		index in the options array is removed), or select option (in
		//		which case, the select option with a matching value is removed).
		//		You can also pass in an array of those values for a slightly
		//		better performance since the children are only loaded once.
		if(!lang.isArray(valueOrIdx)){ valueOrIdx = [valueOrIdx]; }
		var oldOpts = this.getOptions(valueOrIdx);
		array.forEach(oldOpts, function(i){
			// We can get null back in our array - if our option was not found.  In
			// that case, we don't want to blow up...
			if(i){
				this.options = array.filter(this.options, function(node){
					return (node.value !== i.value || node.label !== i.label);
				});
				this._removeOptionItem(i);
			}
		}, this);
		this._loadChildren();
	},

	updateOption: function(/*dijit.form.__SelectOption|dijit.form.__SelectOption[]*/ newOption){
		// summary:
		//		Updates the values of the given option.  The option to update
		//		is matched based on the value of the entered option.  Passing
		//		in an array of new options will yield better performance since
		//		the children will only be loaded once.
		if(!lang.isArray(newOption)){ newOption = [newOption]; }
		array.forEach(newOption, function(i){
			var oldOpt = this.getOptions(i), k;
			if(oldOpt){
				for(k in i){ oldOpt[k] = i[k]; }
			}
		}, this);
		this._loadChildren();
	},

	setStore: function(/*dojo.data.api.Identity*/ store,
						/*anything?*/ selectedValue,
						/*Object?*/ fetchArgs){
		// summary:
		//		Sets the store you would like to use with this select widget.
		//		The selected value is the value of the new store to set.  This
		//		function returns the original store, in case you want to reuse
		//		it or something.
		// store: dojo.data.api.Identity
		//		The store you would like to use - it MUST implement dojo.data.api.Identity,
		//		and MAY implement dojo.data.api.Notification.
		// selectedValue: anything?
		//		The value that this widget should set itself to *after* the store
		//		has been loaded
		// fetchArgs: Object?
		//		The arguments that will be passed to the store's fetch() function
		var oStore = this.store;
		fetchArgs = fetchArgs || {};
		if(oStore !== store){
			// Our store has changed, so update our notifications
			var h;
			while(h = this._notifyConnections.pop()){ h.remove(); }

			if(store && store.getFeatures()["dojo.data.api.Notification"]){
				this._notifyConnections = [
					aspect.after(store, "onNew", lang.hitch(this, "_onNewItem"), true),
					aspect.after(store, "onDelete", lang.hitch(this, "_onDeleteItem"), true),
					aspect.after(store, "onSet", lang.hitch(this, "_onSetItem"), true)
				];
			}
			this._set("store", store);
		}

		// Turn off change notifications while we make all these changes
		this._onChangeActive = false;

		// Remove existing options (if there are any)
		if(this.options && this.options.length){
			this.removeOption(this.options);
		}

		// Add our new options
		if(store){
			this._loadingStore = true;
			store.fetch(lang.delegate(fetchArgs, {
				onComplete: function(items, opts){
					if(this.sortByLabel && !fetchArgs.sort && items.length){
						items.sort(sorter.createSortFunction([{
							attribute: store.getLabelAttributes(items[0])[0]
						}], store));
					}

					if(fetchArgs.onFetch){
							items = fetchArgs.onFetch.call(this, items, opts);
					}
					// TODO: Add these guys as a batch, instead of separately
					array.forEach(items, function(i){
						this._addOptionForItem(i);
					}, this);

					// Set our value (which might be undefined), and then tweak
					// it to send a change event with the real value
					this._loadingStore = false;
						this.set("value", "_pendingValue" in this ? this._pendingValue : selectedValue);
					delete this._pendingValue;

					if(!this.loadChildrenOnOpen){
						this._loadChildren();
					}else{
						this._pseudoLoadChildren(items);
					}
					this._fetchedWith = opts;
					this._lastValueReported = this.multiple ? [] : null;
					this._onChangeActive = true;
					this.onSetStore();
					this._handleOnChange(this.value);
				},
				scope: this
			}));
		}else{
			delete this._fetchedWith;
		}
		return oStore;	// dojo.data.api.Identity
	},

	// TODO: implement set() and watch() for store and query, although not sure how to handle
	// setting them individually rather than together (as in setStore() above)

	_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		set the value of the widget.
		//		If a string is passed, then we set our value from looking it up.
		if(this._loadingStore){
			// Our store is loading - so save our value, and we'll set it when
			// we're done
			this._pendingValue = newValue;
			return;
		}
		var opts = this.getOptions() || [];
		if(!lang.isArray(newValue)){
			newValue = [newValue];
		}
		array.forEach(newValue, function(i, idx){
			if(!lang.isObject(i)){
				i = i + "";
			}
			if(typeof i === "string"){
				newValue[idx] = array.filter(opts, function(node){
					return node.value === i;
				})[0] || {value: "", label: ""};
			}
		}, this);

		// Make sure some sane default is set
		newValue = array.filter(newValue, function(i){ return i && i.value; });
		if(!this.multiple && (!newValue[0] || !newValue[0].value) && opts.length){
			newValue[0] = opts[0];
		}
		array.forEach(opts, function(i){
			i.selected = array.some(newValue, function(v){ return v.value === i.value; });
		});
		var val = array.map(newValue, function(i){ return i.value; }),
			disp = array.map(newValue, function(i){ return i.label; });

		this._set("value", this.multiple ? val : val[0]);
		this._setDisplay(this.multiple ? disp : disp[0]);
		this._updateSelection();
		this._handleOnChange(this.value, priorityChange);
	},

	_getDisplayedValueAttr: function(){
		// summary:
		//		returns the displayed value of the widget
		var val = this.get("value");
		if(!lang.isArray(val)){
			val = [val];
		}
		var ret = array.map(this.getOptions(val), function(v){
			if(v && "label" in v){
				return v.label;
			}else if(v){
				return v.value;
			}
			return null;
		}, this);
		return this.multiple ? ret : ret[0];
	},

	_loadChildren: function(){
		// summary:
		//		Loads the children represented by this widget's options.
		//		reset the menu to make it populatable on the next click
		if(this._loadingStore){ return; }
		array.forEach(this._getChildren(), function(child){
			child.destroyRecursive();
		});
		// Add each menu item
		array.forEach(this.options, this._addOptionItem, this);

		// Update states
		this._updateSelection();
	},

	_updateSelection: function(){
		// summary:
		//		Sets the "selected" class on the item for styling purposes
		this._set("value", this._getValueFromOpts());
		var val = this.value;
		if(!lang.isArray(val)){
			val = [val];
		}
		if(val && val[0]){
			array.forEach(this._getChildren(), function(child){
				var isSelected = array.some(val, function(v){
					return child.option && (v === child.option.value);
				});
				domClass.toggle(child.domNode, this.baseClass + "SelectedOption", isSelected);
				child.domNode.setAttribute("aria-selected", isSelected);
			}, this);
		}
	},

	_getValueFromOpts: function(){
		// summary:
		//		Returns the value of the widget by reading the options for
		//		the selected flag
		var opts = this.getOptions() || [];
		if(!this.multiple && opts.length){
			// Mirror what a select does - choose the first one
			var opt = array.filter(opts, function(i){
				return i.selected;
			})[0];
			if(opt && opt.value){
				return opt.value
			}else{
				opts[0].selected = true;
				return opts[0].value;
			}
		}else if(this.multiple){
			// Set value to be the sum of all selected
			return array.map(array.filter(opts, function(i){
				return i.selected;
			}), function(i){
				return i.value;
			}) || [];
		}
		return "";
	},

	// Internal functions to call when we have store notifications come in
	_onNewItem: function(/*item*/ item, /*Object?*/ parentInfo){
		if(!parentInfo || !parentInfo.parent){
			// Only add it if we are top-level
			this._addOptionForItem(item);
		}
	},
	_onDeleteItem: function(/*item*/ item){
		var store = this.store;
		this.removeOption(store.getIdentity(item));
	},
	_onSetItem: function(/*item*/ item){
		this.updateOption(this._getOptionObjForItem(item));
	},

	_getOptionObjForItem: function(item){
		// summary:
		//		Returns an option object based off the given item.  The "value"
		//		of the option item will be the identity of the item, the "label"
		//		of the option will be the label of the item.  If the item contains
		//		children, the children value of the item will be set
		var store = this.store, label = store.getLabel(item),
			value = (label ? store.getIdentity(item) : null);
		return {value: value, label: label, item:item}; // dijit.form.__SelectOption
	},

	_addOptionForItem: function(/*item*/ item){
		// summary:
		//		Creates (and adds) the option for the given item
		var store = this.store;
		if(!store.isItemLoaded(item)){
			// We are not loaded - so let's load it and add later
			store.loadItem({item: item, onItem: function(i){
				this._addOptionForItem(i);
			},
			scope: this});
			return;
		}
		var newOpt = this._getOptionObjForItem(item);
		this.addOption(newOpt);
	},

	constructor: function(/*Object*/ keywordArgs){
		// summary:
		//		Saves off our value, if we have an initial one set so we
		//		can use it if we have a store as well (see startup())
		this._oValue = (keywordArgs || {}).value || null;
		this._notifyConnections = [];
	},

	buildRendering: function(){
		this.inherited(arguments);
		dom.setSelectable(this.focusNode, false);
	},

	_fillContent: function(){
		// summary:
		//		Loads our options and sets up our dropdown correctly.  We
		//		don't want any content, so we don't call any inherit chain
		//		function.
		var opts = this.options;
		if(!opts){
			opts = this.options = this.srcNodeRef ? query("> *",
						this.srcNodeRef).map(function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return {
								value: (node.getAttribute("data-" + kernel._scopeName + "-value") || node.getAttribute("value")),
										label: String(node.innerHTML),
								// FIXME: disabled and selected are not valid on complex markup children (which is why we're
								// looking for data-dojo-value above.  perhaps we should data-dojo-props="" this whole thing?)
								// decide before 1.6
										selected: node.getAttribute("selected") || false,
								disabled: node.getAttribute("disabled") || false
							};
						}, this) : [];
		}
		if(!this.value){
			this._set("value", this._getValueFromOpts());
		}else if(this.multiple && typeof this.value == "string"){
			this._set("value", this.value.split(","));
		}
	},

	postCreate: function(){
		// summary:
		//		sets up our event handling that we need for functioning
		//		as a select
		this.inherited(arguments);

		// Make our event connections for updating state
		this.connect(this, "onChange", "_updateSelection");
		this.connect(this, "startup", "_loadChildren");

		this._setValueAttr(this.value, null);
	},

	startup: function(){
		// summary:
		//		Connects in our store, if we have one defined
		this.inherited(arguments);
		var store = this.store, fetchArgs = {};
		array.forEach(["query", "queryOptions", "onFetch"], function(i){
			if(this[i]){
				fetchArgs[i] = this[i];
			}
			delete this[i];
		}, this);
		if(store && store.getFeatures()["dojo.data.api.Identity"]){
			// Temporarily set our store to null so that it will get set
			// and connected appropriately
			this.store = null;
			this.setStore(store, this._oValue, fetchArgs);
		}
	},

	destroy: function(){
		// summary:
		//		Clean up our connections
		var h;
		while(h = this._notifyConnections.pop()){ h.remove(); }
		this.inherited(arguments);
	},

	_addOptionItem: function(/*dijit.form.__SelectOption*/ /*===== option =====*/){
		// summary:
		//		User-overridable function which, for the given option, adds an
		//		item to the select.  If the option doesn't have a value, then a
		//		separator is added in that place.  Make sure to store the option
		//		in the created option widget.
	},

	_removeOptionItem: function(/*dijit.form.__SelectOption*/ /*===== option =====*/){
		// summary:
		//		User-overridable function which, for the given option, removes
		//		its item from the select.
	},

	_setDisplay: function(/*String or String[]*/ /*===== newDisplay =====*/){
		// summary:
		//		Overridable function which will set the display for the
		//		widget.  newDisplay is either a string (in the case of
		//		single selects) or array of strings (in the case of multi-selects)
	},

	_getChildren: function(){
		// summary:
		//		Overridable function to return the children that this widget contains.
		return [];
	},

	_getSelectedOptionsAttr: function(){
		// summary:
		//		hooks into this.attr to provide a mechanism for getting the
		//		option items for the current value of the widget.
		return this.getOptions(this.get("value"));
	},

	_pseudoLoadChildren: function(/*item[]*/ /*===== items =====*/){
		// summary:
		//		a function that will "fake" loading children, if needed, and
		//		if we have set to not load children until the widget opens.
		// items:
		//		An array of items that will be loaded, when needed
	},

	onSetStore: function(){
		// summary:
		//		a function that can be connected to in order to receive a
		//		notification that the store has finished loading and all options
		//		from that store are available
	}
});

});

},
'dijit/layout/_TabContainerBase':function(){
require({cache:{
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n"}});
define("dijit/layout/_TabContainerBase", [
	"dojo/text!./templates/TabContainer.html",
	"./StackContainer",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_TemplatedMixin",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style" // domStyle.style
], function(template, StackContainer, layoutUtils, _TemplatedMixin, declare, domClass, domGeometry, domStyle){


/*=====
	var StackContainer = dijit.layout.StackContainer;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

// module:
//		dijit/layout/_TabContainerBase
// summary:
//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
//		and return the widget that displays the tab labels


return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {
	// summary:
	//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
	//		and return the widget that displays the tab labels
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the name (aka title) of the pane, and optionally a close button.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",

	// tabStrip: [const] Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.   Not supported by claro theme.
	tabStrip: false,

	// nested: [const] Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: template,

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijitTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

		this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");

		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		this.tablist = this._makeController(this.tablistNode);

		if(!this.doLayout){ domClass.add(this.domNode, "dijitTabContainerNoLayout"); }

		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			domClass.add(this.domNode, "dijitTabContainerNested");
			domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
			domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
			domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
		}else{
			domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
		}
	},

	_setupChild: function(/*dijit._Widget*/ tab){
		// Overrides StackContainer._setupChild().
		domClass.add(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();

		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are

		if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){return;}

		var sc = this.selectedChildWidget;

		if(this.doLayout){
			// position and size the titles and the container node
			var titleAlign = this.tabPosition.replace(/-h/, "");
			this.tablist.layoutAlign = titleAlign;
			var children = [this.tablist, {
				domNode: this.tablistSpacer,
				layoutAlign: titleAlign
			}, {
				domNode: this.containerNode,
				layoutAlign: "client"
			}];
			layoutUtils.layoutChildren(this.domNode, this._contentBox, children);

			// Compute size to make each of my children.
			// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
			this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);

			if(sc && sc.resize){
				sc.resize(this._containerContentBox);
			}
		}else{
			// just layout the tab controller, so it can position left/right buttons etc.
			if(this.tablist.resize){
				//make the tabs zero width so that they don't interfere with width calc, then reset
				var s = this.tablist.domNode.style;
				s.width="0";
				var width = domGeometry.getContentBox(this.domNode).w;
				s.width="";
				this.tablist.resize({w: width});
			}

			// and call resize() on the selected pane just to tell it that it's been made visible
			if(sc && sc.resize){
				sc.resize();
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});

});

},
'dijit/_KeyNavContainer':function(){
define("dijit/_KeyNavContainer", [
	"dojo/_base/kernel", // kernel.deprecated
	"./_Container",
	"./_FocusMixin",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/lang" // lang.hitch
], function(kernel, _Container, _FocusMixin, array, keys, declare, event, domAttr, lang){

/*=====
	var _FocusMixin = dijit._FocusMixin;
	var _Container = dijit._Container;
=====*/

	// module:
	//		dijit/_KeyNavContainer
	// summary:
	//		A _Container with keyboard navigation of its children.

	return declare("dijit._KeyNavContainer", [_FocusMixin, _Container], {

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.

/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: call this automatically from my own postCreate()

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			array.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getLastFocusableChild());
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){ return; }

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focs
			widget.focus(last ? "end" : "start");
			this._set("focusedChild", widget);
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			// tags:
			//		private

			widget.set("tabIndex", "-1");

			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.set("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.set("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			}
			this.focusedChild = null;
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				event.stop(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used by MenuBase.js (TODO: move code there)
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused
			return this._getNextFocusableChild(null, -1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	});
});

},
'url:idx/oneui/form/templates/DropDownBox.html':"<div id=\"widget_${id}\" class=\"dijitInline dijitReset dijitLeft idxComposite\"\r\n\t><div class=\"idxLabel dijitInline dijitHidden\"><span class=\"idxRequiredIcon\">*&nbsp</span><label for=\"${id}\" dojoAttachPoint=\"compLabelNode\"></label></div\r\n\t><div class=\"dijitInline\"\r\n\t><div class=\"dijit dijitInline dijitReset dijitInlineTable dijitLeft\" role=\"combobox\" dojoAttachPoint='_aroundNode,stateNode,oneuiBaseNode'\r\n\t\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\" dojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"/\r\n\t></div\r\n\t></div\r\n\t><div class='dijitReset dijitInline oneuiIcon'\r\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\r\n\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\" ${_buttonInputDisabled}/\r\n\t></div\r\n\t><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"></div\r\n\t><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\r\n\t\t><div class=\"dijitValidationIcon\"><input class=\"dijitReset dijitInputField dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\r\n\t></div></div\r\n\t><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\r\n\t></div\r\n></div>",
'dijit/Tooltip':function(){
require({cache:{
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n></div>\n"}});
define("dijit/Tooltip", [
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window", // win.body
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"."		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, has, win,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

/*=====
	var _Widget = dijit._Widget;
	var BackgroundIframe = dijit.BackgroundIframe;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/Tooltip
	// summary:
	//		Defines dijit.Tooltip widget (to display a tooltip), showTooltip()/hideTooltip(), and _MasterTooltip


	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			win.body().appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode || dijit.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.


			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}
			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default

			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var tooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reduce tooltip's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = domGeometry.getContentBox(this.domNode);

			var width = Math.min((Math.max(tooltipSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;

			this.domNode.style.width = width+"px";

			//Adjust width for tooltips that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our tooltip needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + domStyle.get(this.domNode,"paddingLeft") + domStyle.get(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = domGeometry.getMarginBox(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						mb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - tooltipSpaceAvaliableWidth);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		},

		_setAutoTextDir: function(/*Object*/node){
			// summary:
			//	    Resolve "auto" text direction for children nodes
			// tags:
			//		private

			this.applyTextDir(node, has("ie") ? node.outerText : node.textContent);
			array.forEach(node.children, function(child){this._setAutoTextDir(child); }, this);
		},

		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			// tags:
			//		private

			this._set("textDir", textDir);

			if (textDir == "auto"){
				this._setAutoTextDir(this.containerNode);
			}else{
				this.containerNode.dir = this.textDir;
			}
		}
	});

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit.Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: dijit.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.

		// after/before don't work, but they used to, so for back-compat convert them to after-centered, before-centered
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: String|String[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node, the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(/*String|String[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, lang.hitch(this, "disconnect"));
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id); });

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id);
				return [
					this.connect(node, "onmouseenter", "_onHover"),
					this.connect(node, "onmouseleave", "_onUnHover"),
					this.connect(node, "onfocus", "_onHover"),
					this.connect(node, "onblur", "_onUnHover")
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(lang.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			Tooltip.show(this.label || this.domNode.innerHTML, target, this.position, !this.isLeftToRight(), this.textDir);

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				Tooltip.hide(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	// dijit.Tooltip.defaultPosition: String[]
	//		This variable controls the position of tooltips, if the position is not specified to
	//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
	//		possible for `dijit/place::around()`.   The recommended values are:
	//
	//			* before-centered: centers tooltip to the left of the anchor node/widget, or to the right
	//				 in the case of RTL scripts like Hebrew and Arabic
	//			* after-centered: centers tooltip to the right of the anchor node/widget, or to the left
	//				 in the case of RTL scripts like Hebrew and Arabic
	//			* above-centered: tooltip is centered above anchor node
	//			* below-centered: tooltip is centered above anchor node
	//
	//		The list is positions is tried, in order, until a position is found where the tooltip fits
	//		within the viewport.
	//
	//		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
	//		the screen so that there's no room above the target node.   Nodes with drop downs, like
	//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
	//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
	//		is only room below (or above) the target node, but not both.
	Tooltip.defaultPosition = ["after-centered", "before-centered"];


	return Tooltip;
});

},
'dijit/PopupMenuItem':function(){
define("dijit/PopupMenuItem", [
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"dojo/query", // query
	"dojo/_base/window", // win.body
	"./registry",	// registry.byNode
	"./MenuItem",
	"./hccss"
], function(declare, domStyle, query, win, registry, MenuItem){

/*=====
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/PopupMenuItem
	// summary:
	//		An item in a Menu that spawn a drop down (usually a drop down menu)

	return declare("dijit.PopupMenuItem", MenuItem, {
		// summary:
		//		An item in a Menu that spawn a drop down (usually a drop down menu)

		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div data-dojo-type="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to win.doc.body.
			if(!this.popup){
				var node = query("[widgetId]", this.dropDownContainer)[0];
				this.popup = registry.byNode(node);
			}
			win.body().appendChild(this.popup.domNode);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				domStyle.set(this.arrowWrapper, "visibility", "");
			}
			this.focusNode.setAttribute("aria-haspopup", "true");
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive(preserveDom);
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/main':function(){
define("dijit/main", [
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit
	// summary:
	//		The dijit package main module

	return dojo.dijit;
});

},
'curam/app/ExternalApplication':function(){
require({cache:{
'url:curam/app/templates/ExternalApplication.html':"<div class=\"app-container\">\r\n  <div class=\"app-container-bc\" \r\n    data-dojo-type=\"dijit/layout/BorderContainer\"\r\n    data-dojo-props=\"gutters:false\"\r\n    data-dojo-attach-point=\"_borderContainer\">\r\n    <div class=\"app-banner\"\r\n      data-dojo-type=\"dojox/layout/ContentPane\"\r\n      data-dojo-props=\"region: 'top'\"\r\n      data-dojo-attach-point=\"_appBanner\">\r\n    </div>\r\n    <div id=\"app-nav\"\r\n      data-dojo-type=\"curam/widget/menu/MenuPane\"\r\n      data-dojo-props=\"region: 'leading', startExpanded: false\"\r\n      data-dojo-attach-point=\"_appNav\"\r\n      class=\"leftNavMenu\">\r\n    </div>\r\n\t\t<div id=\"app-content\"\r\n\t\t\tdata-dojo-type=\"curam/widget/containers/TransitionContainer\"\r\n\t\t\tdata-dojo-attach-point=\"_appContentBody\" class=\"mainBody\"\r\n\t\t\tdata-dojo-props='region:\"center\", style : {padding : 0, border : 0}'>\r\n\t\t</div>\r\n  </div>\r\n</div>"}});
define(
  "curam/app/ExternalApplication", [ "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/_base/window",
    "dojo/aspect",
    "dojo/dom-attr",
    "dojo/query",
    "dojo/dom-geometry",
    "dojo/dom",
    "dijit/_Widget",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/layout/BorderContainer",
    "dijit/layout/ContentPane",
    "dijit/form/Button",
    "dojo/text!./templates/ExternalApplication.html",
    /* Callback parameters Start */
    "curam/util/UIMFragment",
    "dojo/dom-class",
    "dojo/dom-style",
    "curam/ui/ClientDataAccessor",
    "curam/widget/containers/TransitionContainer",
    "dojo/on",
    "curam/widget/menu/MenuPane",
    "dijit/CheckedMenuItem",
    "dojo/fx",
    "dijit/focus",
    /* Callback parameters End*/
    /* ONE UI banner requirements */
    "idx/oneui/MenuBar",
    "idx/oneui/Menu",
    "idx/oneui/Header",
    "idx/oneui/MenuDialog",
    "idx/oneui/MenuHeading",
    "idx/oneui/HoverHelpTooltip",
    "dijit/PopupMenuBarItem",
    "dijit/MenuItem",
    "dijit/form/ComboButton",
    "curam/widget/menu/BannerMenuItem",
    /* END ONE UI banner requirements */
    "curam/util/SessionTimeout",
    "curam/util/ui/AppExitConfirmation"
    ],
  function(
    declare,
    lang,
    win,
    dojoAspect,
    domAttr,
    query,
    domGeom,
    dom,
    _Widget,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    BorderContainer,
    ContentPane,
    Button,
    template,
    UIMFragment,
    domClass,
    domStyle,
    ClientDataAccessor,
    TransitionContainer,
    onConnect,
    MenuPane,
    CheckedMenuItem,
    fx,
    focusUtil) {
  return declare("curam.app.ExternalApplication",[_Widget,_TemplatedMixin,_WidgetsInTemplateMixin],
  {
    started : false,

  /**
   * The template text.
   *
   * @private
   * @type String
   * @field
   */
  templateString: template,

  widgetsInTemplate: true,

  baseClass : "curamApp",

  _appConfig: null,

  _initializedNavBarID: null,

  guardAgainstLeaving: null,

  directLinkData: null,

  /**
   * Overridden to mixin the override resources if provided.
   * @function
   * @public
   */
  postMixInProperties: function() {
    this.inherited(arguments);
  },

  /**
   * Override to force startup/layout on BorderContainer.
   */
  startup: function() {
    this.inherited(arguments);
    this._init();
    this._setupUserLeavingGuard();
  },


  _isNavBarItem: function(uimPageID) {
    // the "map" variable is created in TabLayoutResolver.java
    return (this._appConfig.map[uimPageID] != null);
  },

  /**
   *
   */
  _init: function() {
    var da = new ClientDataAccessor();
    da.getRaw("/config/tablayout/extapp[" + curam.config.appID + "]",
        lang.hitch(this, function(data) {
          console.log("External App config data:" + data);
          this._appConfig = data;
          this._postDataLoadInit();
        }),
        function(error, args) {
          console.log("External App config data load error:" + error);
        },
        null);

    // Want to meuns in the banner to animate open and closed, so need to hook
    // into the dojo popupmanager to begin animations at the most appropriate
    // moment.
    dojoAspect.before(dijit.popup, "open", this._evenOutMenuRows, true);
    dojoAspect.after(dijit.popup, "open", lang.hitch(this, "_animateMenuOpen"), true);
    dojoAspect.after(dijit.popup, "close", lang.hitch(this, "_animateMenuClose"), true);


    // The banner should dynamically adapt the length of its text as the
    // viewport is resized or as the user zooms in or out.
    // We use a timer here so the event is not constantly processed as the user
    // resizes the window, or zooms.
    this._bannerResizeTimer = null;
    dojo.connect(window, "resize", dojo.hitch(this, function(){
      if(this._bannerResizeTimer) clearTimeout(this._bannerResizeTimer);
      this._bannerResizeTimer = setTimeout(this._handleBannerResize, 400);
    }));

  },

  /**
   * Sets up a handler that will pop up a confirmation dialog before the user
   * leaves the external application. It will only do so if the appropriate
   * configuration value is enabled.
   */
  _setupUserLeavingGuard: function() {
    if (this.guardAgainstLeaving) {
      curam.util.ui.AppExitConfirmation.install();
    }
  },

  /**
     * Iniates the check to see if the timeout warning modal should
     * be diplayed if the session is about to timeout.
     */
    _checkSessionExpired: function() {
      if (this._appConfig != null) {
    	  var timeoutWarningConfig = this._appConfig.timeoutWarning;
    	  if (timeoutWarningConfig) {
    	    var width = timeoutWarningConfig.width;
    		var height = timeoutWarningConfig.height;
    		var timeout = timeoutWarningConfig.timeout;
    		var bufferingPeriod = timeoutWarningConfig.bufferingPeriod;
  		curam.util.SessionTimeout.checkSessionExpired(width, height, timeout, bufferingPeriod);
    	  }
      }
  },

  /**
   * Loads the application "landing page" into the main content panel
   * (_mainContent attach point).
   */
  _loadLandingPage: function(contentPaneID) {
    //TODO: curam.config is a global object on curam pages. Update this widget
    if (curam.config.landingPage) {
      // Load the landing page
      this._displayOnlyBodyContent({
        pageID: curam.config.landingPage
      });
    } else {
      throw "ERROR: Landing page not set correctly: "
            + curam.config.landingPage;
    }
  },

  /**
   * Loads the application banner.
   */
  _loadBanner: function() {
    // Complex hitching going on here to handle scope. The onLoad callback below
    // is setup to run the _initializeBannerLandingPageLink method in the
    // scope of this object (an instance of ExternalApplication). We have to use
    // hitch to ensure this. TODO: get rid of this hitching and instead ensure
    // ExternalApplication is a singleton with a "getInstance()" method we can
    // call from anywhere. Avoids all this hitching?
    UIMFragment.get({
      url: "CDEJ/extapp/application-banner-fragment.jspx",
      targetID: this._appBanner.id,
      onLoad: lang.hitch(this, this._initializeBannerLandingPageLink)
    });
  },

  /**
   * Loads the application banner.
   */
  _reloadBanner: function() {

    //Calling _loadBanner to refresh the banner after it had been initially
    //displayed was throwing an error. We found that one ui was not correctly
    //handling its desendant widgets, and as such widgets used within the banner
    //were not getting destroyed. We have to manually destory the widgets
    //(with ids) used in the banner, before we can reload it. This prevents the
    //"Tried to register widget with id==xxx but that id is already registered"
    //error.
    if (dijit.byId("MMMenuID")) {
      dijit.byId("MMMenuID").destroy();
    }
    if (dijit.byId("appMegaMenu")) {
      dijit.byId("appMegaMenu").destroy();
    }
    if (dijit.byId("appHelpMenu")) {
      dijit.byId("appHelpMenu").destroy();
    }
    if (dijit.byId("appBannerPrintMenu")) {
      dijit.byId("appBannerPrintMenu").destroy();
    }

    this._loadBanner();
  },

  /**
   * Initializes the landing page link in the banner. Must only be called AFTER
   * the banner is loaded. Also, this method assumes that "this" points to an
   * instance of this class, an instance of ExternalApplication. The
   * _loadBanner() method guarantees this.
   *
   * TODO: Re-implement the banner as a dijit with its own life cycle.
   */
  _initializeBannerLandingPageLink: function(contentPane) {
    // narrow down the query to the dom of the banner content pane
    var headerPrimaryTitle = query(".idxHeaderPrimaryTitle",
                                   contentPane.domNode)[0];
    if (!headerPrimaryTitle) {
      throw "Landing Page link not initialized, title node cannot be found";
    }
    var callBack = lang.hitch(this, "_loadLandingPage");
    dojo.connect(headerPrimaryTitle, "onclick", function() {
      callBack();
    });
  },

  /**
   * Animate the menu open. The menu will first slide open and then the its
   * content will fade in. The function is ran after dijit.popup.open and is
   * passed the same arguments as that function.
   */
  _animateMenuOpen: function(args) {

    var aniNode = dojo.byId(args.popup._popupWrapper.id);

    // only animate if the menu is a mega menu, or help menu from the banner
    if (domAttr.get(aniNode, "dijitpopupparent") !== "appMegaMenu" &
      !domClass.contains(aniNode, "oneuiHeaderGlobalActionsMenu_help")) return

    // Find the table holding the content, only once.
    if (!aniNode.aniTable) aniNode.aniTable = dojo.query("table", aniNode)[0];

    // Attributes to track whether the menu animation states
    if (!aniNode.inAnimation) aniNode.inAnimation = false;
    if (!aniNode.isShown) aniNode.isShown = false;

    // if in animation, means user has kicked off this animation before the
    // previous one has finished. So need to stop and handle it.
    if (aniNode.inAnimation) {

      // The Help menu, by default, opens each time the user clicks it. We dont
      // want this behaviour. We want the help menu to act the same as the mega
      // menu, i.e. alternate between open and close when the user clicks on it.
      if (dijit.byId("appHelpMenu") === args.popup) {
        if (args.popup.shouldNotClose) { // variable set a wiget initialisation.
          args.popup.shouldNotClose = false;
          args.popup.cancelClose=true;
          return;
        }
      }
      aniNode.fx && aniNode.fx.stop();
      aniNode.inAnimation = false;
      aniNode.isShown = false;
      domStyle.set(aniNode, "display", "none");
    }

    if(!aniNode.isShown && !aniNode.inAnimation) {
      dojo.style(aniNode, "display", "none");
      dojo.style(aniNode.aniTable, "opacity", "0");
    }

    // setup animation callback functions
    // set the animation status attributes before and after the animation.
    var onBeginAni = function() {
      aniNode.inAnimation = true;
      aniNode.isShown = false;
      if (dijit.byId("appHelpMenu") === args.popup) {
        // flip the open state variable.
        args.popup.shouldNotClose = args.popup.shouldNotClose ? false : true;
        // menu is opening so it wasnt just closed.
        args.popup.justClosed = false;
      }
    };
    var onEndAni = function() {
      dojo.style(aniNode.aniTable, "opacity", "1");
      aniNode.inAnimation = false;
      aniNode.isShown = true;
      var aniNodeHeight = dojo.marginBox(aniNode).h;
      var viewportHeight = dojo.window.getBox().h - 65 - 20;
      if (viewportHeight < aniNodeHeight) {
        domStyle.set(aniNode, "height", viewportHeight + "px");
        domStyle.set(aniNode, "border-bottom", "1px solid black");
      }
    };

    this._animateMenu(aniNode, aniNode.aniTable, "open", onBeginAni, onEndAni);

  },

  /**
   * Animate the menu closed. The menu will first fade out its content and then
   * slide up. The function is ran after dijit.popup.close and is passed the
   * same arguments as that function.
   */
  _animateMenuClose: function(popup) {

    var aniNode = dojo.byId(popup._popupWrapper.id);

    // only animate if the menu is a mega menu, or help menu from the banner
    if (domAttr.get(aniNode, "dijitpopupparent") !== "appMegaMenu" &
        !domClass.contains(aniNode, "oneuiHeaderGlobalActionsMenu_help")) return

    // The Help menu, by default, opens each time the user clicks it. We dont
    // want this behaviour. We want the help menu to act the same as the mega
    // menu, i.e. alternate between open and close when the user clicks on it.
    // So if the menu has either already just closed, or been closed by some
    // other means (i.e. losing focus) then dont animate closed again.
    if (dijit.byId("appHelpMenu") === popup) {
      if (popup.cancelClose) {
        popup.cancelClose=false;
        return;
      } else if (popup.justClosed) {
        popup.justClosed = false;
        return;
      }
    }

    // Find the table holding the content, only once.
    if (!aniNode.aniTable) aniNode.aniTable = dojo.query("table", aniNode)[0];

    // if in animation, means user has kicked off this animation before the
    // previous one has finished. So need to stop and handle it.
    if (aniNode.inAnimation) {
      aniNode.fx && aniNode.fx.stop();
      aniNode.inAnimation = false;
      aniNode.isShown = false;
      dojo.style(aniNode.aniTable, "opacity", "1");
    }


    // Ensure the menu is fully visible before beginning to animate it closed.
    domStyle.set(aniNode, "display", "block");

    // setup animation callback functions
    // set the animation status attributes before and after the animation.
    var onBeginAni = function() {
      aniNode.inAnimation = true;
      aniNode.isShown = true;
    };
    var onEndAni = function() {
      aniNode.inAnimation = false;
      aniNode.isShown = false;
      domStyle.set(aniNode, "display", "none");
      domStyle.set(aniNode, "border-bottom", "");
      // Set Help Menu open state variables.
      if (dijit.byId("appHelpMenu") === popup) {
        popup.shouldNotClose = false;
        popup.justClosed = true;
      }
    };

    this._animateMenu(aniNode, aniNode.aniTable, "close", onBeginAni, onEndAni);

  },

  /**
   * Base animation function to actually set dojo animation object and start the
   * animation.
   */
  _animateMenu: function(mainNode, contentNode, action, onBeginAni, onEndAni) {

    var duration = 300;
    var animations = [];

    var showMenu = fx.wipeIn({ node: mainNode, duration: duration });
    var showContent = dojo.fadeIn({ node: contentNode, duration: duration });

    var hideMenu = fx.wipeOut({ node: mainNode, duration: duration });
    var hideContent = dojo.fadeOut({ node: contentNode, duration: duration });

    if (action === "open") {
      animations.push(showMenu);animations.push(showContent);
    } else {
      animations.push(hideContent);animations.push(hideMenu);
    }

    // animations are chained, as we want the menu to first open and then fade
    // in its content, and vice versa.
    mainNode.fx = fx.chain(animations);
    dojo.connect(mainNode.fx, "onBegin", onBeginAni);
    dojo.connect(mainNode.fx, "onEnd", onEndAni);
    mainNode.fx.play();

  },

  /**
   * Ensure that MegaMenu items on any given row, all have a uniform height.
   * That is, a height equal to the largest in the row. This function is needed
   * as each column of items in the menu are repersented by a seperate table, so
   * there is no real link between items along rows.
   *
   */
  _evenOutMenuRows: function(widget) {

    var widgetNode = dojo.byId(widget.popup.id);
    var widgetID = widget.parent ? widget.parent.id : widget.popup.id;
    // only animate if the menu is a mega menu, or help menu from the banner
    if (widgetID !== "appMegaMenu" & widgetID !== "appHelpMenu") return

    var rowClass, containerClass;
    if (widgetID === "appMegaMenu") {
      rowClass = "MMItemContainerRow";
      containerClass = "MMItemContainer";
    } else {
      rowClass = "HMItemContainerRow";
      containerClass = "HMItemContainer";
    }

    var items = dojo.query("div." + containerClass, widgetNode);

    var holdingNode = widget.popup._popupWrapper ? widget.popup._popupWrapper : widgetNode;
    domStyle.set(holdingNode, "display", "block");

    var numItems = items.length;
    var numRows = numItems < 6 ? 1 : Math.ceil(numItems/3);
    var highest = [];
    for (var i = 0; i < numRows; i++) highest[i] = 0;

    // Find highest height in each row.
    for (var curRow = 0; curRow < numRows; curRow++) {
      dojo.forEach(items, function(item, index) {
        domStyle.set(item, "height", "auto");
        // The width of the menus item icons can not be set on the server side.
        // We set the width just before the menu is open for the first time.
        // Items in the menus are held in tables with fixed layouts.
        // As such, we only need to set the width of an item in the first row of
        // the table and all other cells will be set to that value.
        if (curRow === 0 && !domClass.contains(item, "iconSetOUI")) {
          var imgCell = item;
          // Get the imgCell Parent Node
          while (!domClass.contains(imgCell, "menuItemClassOUI")) {
            imgCell = imgCell.parentNode;
          }
          // then find the actual td that holds the icon
          imgCell = dojo.query("td.dijitMenuItemIconCell", imgCell)[0];
          if (numRows === 1) {
            domStyle.set(imgCell, "width", "50px");
          } else {
            domStyle.set(imgCell, "width", "34px");
          }
          domClass.add(item, "iconSetOUI");
        }
        var itemHeight = domStyle.get(item, "height")
        if (domClass.contains(item, rowClass + curRow)) {
          if (itemHeight > highest[curRow] ) {
            highest[curRow] = itemHeight;
          }
        }
      });
    }

    // Heights found, so can once again hide the menu
    domStyle.set(holdingNode, "display", "none");

    // Apply the relavent height to each item.
    for (var i = 0; i < numRows; i++) {
      dojo.forEach(items, function(item, index) {
        if (domClass.contains(item, rowClass + i)) {
          domStyle.set(item, "height", highest[i] + "px");
        }
      });
    }

  },

  /**
   * We calculate the avilable space in the banner for the mega menu title text
   * and the user's welcome message. If there is not enough room for the full
   * text to appear we truncate them. We try to ensure that as much text is
   * shown as possible.
   */
  _handleBannerResize: function(oneuiBanner) {

    var pos = dojo.position;
    var box = dojo.marginBox;

    // Save the banner object if its passed in, otherwise use existing one.
    CuramExternalApp._oneuiBanner = oneuiBanner || CuramExternalApp._oneuiBanner;
    currentBanner = CuramExternalApp._oneuiBanner;
    var bannerTitleNode = dojo.query(".idxHeaderPrimaryTitleContainer", currentBanner._globalActionsNode)[0];

    var helpExists = currentBanner._helpNode ? true : false;
    var userExists = currentBanner.userNode ? true : false;
    var megaExists = currentBanner.navigation ? true : false;
    var logoExists = currentBanner.logoExists;
    var printExists = currentBanner._settingsNode ? true : false;

    // Had to put code to set the print menu text in this resize method as it
    // was the only place a banner reference ("currentBanner") was available.
    // The print menu is implemented using the OneUI "settings" menu.
    // We reset the alt text below to that of the print menu. The print menu
    // text is looked up in the "TabLayoutResolver" java class.
    if (printExists) {
      // Either title or alt is used based on the browser.
      if (domAttr.get(currentBanner._settingsNode, "title")) {
        domAttr.set(currentBanner._settingsNode, "title",
            CuramExternalApp._appConfig.printMenuLabel);
      }
      if (domAttr.get(currentBanner._settingsNode, "alt")) {
        domAttr.set(currentBanner._settingsNode, "alt",
            CuramExternalApp._appConfig.printMenuLabel);
      }
    }

    var isLTR = currentBanner.isLeftToRight();

    // Find the endpoints of the available space.
    var lastNodeXPosition = helpExists ?
      isLTR ?
        pos(currentBanner._helpNode).x :
        box(currentBanner._mainContainerNode).w
          + box(currentBanner._helpNode).w
          - pos(currentBanner._helpNode).x :
      885;
    var bannerInnerSpace = lastNodeXPosition - box(bannerTitleNode).w;

    if(userExists){
      var userNode = currentBanner.userNode;
      var userTextNode = currentBanner.userTextNode;
      // reset width set by previous resize event.
      domStyle.set(userTextNode, "width", "");
      var UserWidth = box(userNode).w;
      var UserTextWidth = box(userTextNode).w;
    }

    if (megaExists) {
      var MegaMenuNode = currentBanner.navigation.domNode;
      var MegaMenuText = dojo.query("span[id*=text]", MegaMenuNode)[0];
      // reset width set by previous resize event.
      domStyle.set(MegaMenuText, "width", "");
      var MegaMenuWidth = box(MegaMenuNode).w;
      var MegaMenuTextWidth = box(MegaMenuText).w;
    }

    if (printExists) {
      var PrintMenuNode = currentBanner._settingsNode;
      var PrintMenuTextNode = dojo.query("span[id*=text]", PrintMenuNode)[0];
      var PrintMenuWidth = box(PrintMenuNode).w;
    }

    var realInnerSpace = bannerInnerSpace;
    realInnerSpace -= megaExists ? (MegaMenuWidth - MegaMenuTextWidth) : 0;
    realInnerSpace -= userExists ? (UserWidth - UserTextWidth) : 0;
    realInnerSpace -= printExists ? PrintMenuWidth : 0;

    var availSpace = realInnerSpace;
    availSpace -= megaExists? MegaMenuTextWidth : 0;
    availSpace -= userExists? UserTextWidth : 0;
    availSpace -= printExists? PrintMenuWidth : 0;

    // only need to modify width if there is not enough space
    if(availSpace < 0) {
      if(megaExists & userExists){
        var setToWidth = realInnerSpace/2;
        var space;
        if(UserTextWidth < setToWidth){
          space = realInnerSpace - UserTextWidth;
          domStyle.set(MegaMenuText , "width", space + "px");
        } else if (MegaMenuTextWidth < setToWidth){
          space = realInnerSpace - MegaMenuTextWidth;
          domStyle.set(userTextNode, "width", space + "px");
        } else {
          domStyle.set(userTextNode, "width", setToWidth + "px");
          domStyle.set(MegaMenuText , "width", setToWidth + "px");
        }
      } else if (megaExists & printExists) {
        var setToWidth = realInnerSpace/2;
        var space;
        if(PrintMenuWidth < setToWidth){
          space = realInnerSpace - PrintMenuWidth;
          domStyle.set(MegaMenuText , "width", space + "px");
        }else if (MegaMenuTextWidth < setToWidth){
          space = realInnerSpace - MegaMenuTextWidth;
          domStyle.set(PrintMenuNode, "width", space + "px");
        } else {
          domStyle.set(PrintMenuNode, "width", setToWidth + "px");
          domStyle.set(MegaMenuText , "width", setToWidth + "px");
        }
      } else if(megaExists) { // Only the MegaMenu exists
        domStyle.set(MegaMenuText , "width", realInnerSpace + "px");
      } else { // Only the user menu exits
        domStyle.set(userTextNode, "width", realInnerSpace + "px");
      }
    }

    // Once the text lengths are set, we have to position the MegaMenu again.
    if (megaExists) {
      var rightVal = 0;

      rightVal += logoExists ?
          box(dojo.query(
              ".idxHeaderLogoBox", currentBanner._globalActionsNode)[0]).w : 0;

      rightVal += userExists ? box(userNode).w : 0;
      rightVal += helpExists ? box(currentBanner._helpNode).w : 0;
      rightVal += printExists ? box(currentBanner._settingsNode).w : 0;

      domStyle.set(MegaMenuNode, isLTR ? "right" : "left", rightVal + "px");
    }

  },

  _postDataLoadInit: function() {

    // assign helper function to main body that does
    // look ups for URI
    this._appContentBody._doResourceLookUp =
      lang.hitch(this, this._doResourceLookUpForMainBody);

    // Handles button selection on the nav bar
    this._appNav._onSelectAfter = lang.hitch(this,
        function(inputJson) {
      this._appContentBody.set(
          "displayPanel", inputJson);
    });


    this._makeNavBarAccessible();
    this._loadBanner();


    // Dont load the landing page if a direct page is requested.
    if (this.directLinkData) {
      if (this._isNavBarItem(this.directLinkData.pageID)) {
        this._initNavBar(this.directLinkData.pageID, lang.hitch(this, function() {
          this.directLinkData.isDirectLink = true;
          this._displayNavMenuAndBodyContent(this.directLinkData);
        }));
      } else {
        this._displayOnlyBodyContent(this.directLinkData);
      }
    } else {
      this._loadLandingPage();
    }

  },

  _initNavBar: function(uimPageID, callBack) {
    var navID = this._appConfig.map[uimPageID];
    if (typeof(navID) == "undefined" // page isn't associated with a navbar
        || navID == this._initializedNavBarID) { // the requested page is associated with the current nabar
      callBack();
      return;
    }
    // otherwise, we initialize the nav bar using "navID"
    var da = new ClientDataAccessor();
    da.getRaw("/config/tablayout/extnav[" + curam.config.appID + "][" + navID + "]",
        lang.hitch(this, function(data) {
          console.log("External App config data:" + data);
          this._loadMenuItems(data.navItems, data.navBarPixelWidth);
          callBack();
          this._initializedNavBarID = navID;
        }),
        function(error, args) {
          console.log("External App navigation config data load error:" + error);
        },
        null);
  },

  _makeNavBarAccessible: function() {

    var hoverCardCloseIcon = dojo.query(".idxOneuiHoverCardCloseIcon")[0];
    if (hoverCardCloseIcon) {
      // Without setting this, the tabbing will become trapped once the last
      // focusable element is focused. The user will be unable to loop round to
      // the first element, or reverse tab to the previous one.
      domAttr.set(hoverCardCloseIcon, "tabindex", -1);

      // Setting the aria label for the close icon on the hover card to resolve
      // the accessibility issue existing in the current One UI toolkit.
      // TODO: This piece of code can be removed once the toolkit is upgraded
      // where this issue is resolved offically.
      domAttr.set(hoverCardCloseIcon, "aria-label",
          this._appConfig.hoverCardCloseButtonLabel);
    }

    // Setting the label used for the overflow button in
    // the side navigation bar.
    var navOverflowButton = dijit.byId("navOverflowButton");
    navOverflowButton._setLabelAttr(this._appConfig.navOverflowButtonLabel);

  },

  _loadMenuItems: function(navItems, navBarPixelWidth) {
    var menuItems = [];
    this._appNav.set("width", navBarPixelWidth);
    for (var i = 0; i < navItems.length; i++) {
      var navItem = navItems[i];
      var menuItem = {
        id: navItem.pageID,
        label: navItem.title,
        selected: false,
        iconPath: navItem.iconPath,
        subPageIds: navItem.subPageIds,
        iconClass: "whoKnow"
      }
      menuItems.push(menuItem);
    }
    this._appNav.addMenuItems(menuItems);
  },

  megaMenuClick: function(args) {
    if (typeof(args.displayNavBar) == "undefined") {
      // if the displayNavBar hasn't been explicitly set, then it is assumed
      // it is hidden for all mega menu items.
      args.displayNavBar = false;
    }
    this.displayContent(args);
  },

  displayContent : function(inputJson) {
   if(inputJson != null) {
      inputJson.forceRefresh = true;
      // The rules for showing the nav bar or not are described
      // with each condition below. TODO: move conditions into
      // a separate function which just sets a boolean flag.
      // Take care with precedence when doing so.

      // Where "inputJson.displayNavBar" is explicitly set,
      // this takes precedence.

      // "displayNavBar" is explicitly set to false
      if (inputJson.displayNavBar == false) {
        this._displayOnlyBodyContent(inputJson);
        return;
      }
      // "displayNavBar" is explicitly set to false
      if (inputJson.displayNavBar == true) {
        this._displayNavMenuAndBodyContent(inputJson);
        return;
      }
      // inputJson.displayNavBar hasn't been specified

      // check if it is the landing page, if so hide the nav bar
      // this takes precedence over the conditions below.
      if (inputJson.pageID == curam.config.landingPage) {
        this._displayOnlyBodyContent(inputJson);
        return;
      }
      // Check if it is a configured nav bar item and if so
      // display the nav bar
      if (this._isNavBarItem(inputJson.pageID)) {
        this._displayNavMenuAndBodyContent(inputJson);
        return;
      } else {
        // it is not a configured nav bar item, but the nav bar
        // is alread displayed, leave it so.
        if (this._appNav._showing) {
          this._displayNavMenuAndBodyContent(inputJson);
          return;
        } else {
          // it is not a configured nav bar item, the nav bar is
          // already hidden, leave it so.
          this._displayOnlyBodyContent(inputJson);
          return;
        }
      }
    }
  },

  _displayOnlyBodyContent : function(inputJson) {
    if(this._appNav._showing) {
      // side menu is displayed
      var handlerBodyFadeOut = this.connect(this._appContentBody, '_panelFadeOutComplete', lang.hitch(this,function(){
        // remove listener after first event
        handlerBodyFadeOut.remove();
        var handlerMenuFadeOut = this.connect(this._appNav, '_onHideComplete', lang.hitch(this,function(){
                this._appNav.deselect();

                handlerMenuFadeOut.remove();

                // PK change to allow inputJson to pass through....
                //this._appContentBody.set("displayPanel", {
                //        key : inputJson.pageID,
                //        param : inputJson.param
                //});
                inputJson.key = inputJson.pageID;
                this._appContentBody.set("displayPanel", inputJson);
        }));

        this._appNav.fadeOut();
      }));

      this._appContentBody.fadeOutDisplay();

    } else {
      // side menu is not displayed
      // PK change to allow inputJson to pass through....
      //this._appContentBody.set("displayPanel", {
      //        key : inputJson.pageID,
      //        param : inputJson.param
      //});
      inputJson.key = inputJson.pageID;
      this._appContentBody.set("displayPanel", inputJson);

    }
  },


  /**
   * Function will bring the nav menu and main body in to display
   * and display the page of the requested ID in the main body
   */
  _displayNavMenuAndBodyContent : function(inputJson)
  {
    inputJson.key = inputJson.pageID;
    if (inputJson.param == null) {
      inputJson.param = [];
    }

    inputJson.exceptionButtonFound = false;

    if(this._appNav._showing) {
      this._appNav.setSelectedButton(inputJson);
    } else {
      if (inputJson.isDirectLink) {
        var handlerMenuFadeIn = this.connect(this._appNav, '_onShowComplete', lang.hitch(this,function(){
          handlerMenuFadeIn.remove();
          this._appNav.setSelectedButton(inputJson);
        }));
        this._appNav.fadeIn();
      } else {
        var handlerBodyFadeOut = this.connect(this._appContentBody, '_panelFadeOutComplete', lang.hitch(this,function(){
          // remove listener after first event
          handlerBodyFadeOut.remove();
          var handlerMenuFadeIn = this.connect(this._appNav, '_onShowComplete', lang.hitch(this,function(){

            handlerMenuFadeIn.remove();
            this._appNav.setSelectedButton(inputJson);
          }));

          this._appNav.fadeIn();
        }));
        this._appContentBody.fadeOutDisplay();
      }
    }
  },

  /**
   * Function looks up and returns a URI from a referenceIdentifer
   */
  _doResourceLookUpForMainBody : function(jsonIn, pramUrl, compositeKey) {
    // no translation required...for now....just return the identifier
    // directly

    var uri;
    // when the TransitionContainer invokes this call back, jsonIn.key is the
    // UIM Page ID
    if (jsonIn.key) {
      // assume its a UIM so build a "curam style" url
      if (this._isUIMFragment(jsonIn.key)) {
        uri = jsL + "/" + jsonIn.key + "Page.do?"
              + this._addCDEJParameters();
      } else {
        // we assume it has to load in an iframe.
        uri = jsL + "/UIMIFrameWrapperPage.do?uimPageID="
              + jsonIn.key + "&" + this._addCDEJParameters();
      }
    } else if (jsonIn.url) {
      // just use the specified url without any changes
      uri = jsonIn.url
    }
    // NB: the uri built here is not complete. The TransitionContainer will
    // take care of adding any parameters specified in jsonIn.param
    return uri;
  },

  /**
   * Adds CDEJ parameters to the request string. This function assumes it is
   * called directly after _constructPath() so it always starts with a "?".
   * The screen context parameter is the only one required for "fragment"
   * requests.
   */
  _addCDEJParameters: function() {
    return jsScreenContext.toRequestString();
  },
  /**
   * Called from util.js when a modal is opened from a UIM in the external
   * application.
   */
  updateMainContentIframe: function(href) {
    var iframe = dojo.query("iframe", this.domNode)[0];
    if (iframe) {
      iframe.contentWindow.location.href = href;
    }
  },

  _isUIMFragment: function(pageID) {
    return (this._appConfig && this._appConfig.uimFragRegistry[pageID] != null);
  },


  /**
   * Handle when the user clicks or otherwise activates Person Menu title text.
   */
  _setupUserMenuLinking: function(userNode, linkArgs) {

    dojo.connect(userNode, 'onclick', lang.partial(function(linkArgs, evt){
      // only if the click occurs to the left of the user dropdown arrow, do we
      // allow the application to navigate to the user home page.
      var arrowNode = dojo.byId("curam-extapp_userMenuArrow");

      // Workaround when the Jaws is opened.
      if (evt.target != arrowNode) {
          displayContent(linkArgs);
      }

    }, linkArgs));

    dojo.connect(userNode, 'onkeypress', function(evt){
      if (evt.charOrCode === dojo.keys.ENTER) {
        dojo.stopEvent(evt);
        displayContent(linkArgs);
      }
    });

  },

  /**
   * Out of the box ONEUI header is not accessable. Need to apply certain
   * attributes to aid keyboard navigation.
   */
  _makeUserMenuAccessible: function (userNode, textNode) {

    domAttr.set(textNode, "tabindex", "3");
    domAttr.set(textNode, "title", textNode.innerText);
    domAttr.set(textNode, "role", "link");

    var userMenuDropDown = dojo.query(".idxHeaderDropDownArrow", userNode)[0];
    domAttr.set(userMenuDropDown, "tabindex", "4");
    domAttr.set(userMenuDropDown, "role", "button");
    // TODO: need to change the title to a proper one.
    domAttr.set(userMenuDropDown, "title", textNode.innerText);

    /* To handle the change of image in user node when we are in high contrast mode */
    this._handleUserImageHighContrast(userNode);
  },

  /**
   * When we are in high contrast mode we should have a different image for user node
   * and it should be changed in roll as well as click state.
   */
  _handleUserImageHighContrast: function(userNode) {
    var userImageNode = dojo.query(".idxHeaderUserIcon", userNode)[1];
    if (userImageNode) {
      var body = win.body();
      if (body && domClass.contains(body, "high-contrast")) {
        userImageNode.src = "servlet/PathResolver?r=i&p=/config/tablayout/image[banner_hom_normal.png]";
        onConnect(userImageNode, "mouseover", function() {
          userImageNode.src = "servlet/PathResolver?r=i&p=/config/tablayout/image[banner_home_roll.png]";
        });
        onConnect(userImageNode, "click", function() {
          userImageNode.src = "servlet/PathResolver?r=i&p=/config/tablayout/image[banner_home_click.png]";
        });
        onConnect(userImageNode, "mouseout", function() {
          userImageNode.src = "servlet/PathResolver?r=i&p=/config/tablayout/image[banner_hom_normal.png]";
        });
      }
    }
  },

  /**
   * Out of the box ONEUI header is not accessable. Need to apply certain
   * attributes to aid keyboard navigation.
   */
  _makeMegaMenuAccessible: function (navNode) {

    var textNode = dojo.query("span[id*=text]", navNode.domNode)[0];
    domAttr.set(textNode, "title", textNode.innerText);
  },

  /**
   * Out of the box ONEUI header is not accessable. Need to apply certain
   * attributes to aid keyboard navigation.
   */
  _makeHelpMenuAccessible: function (helpNode) {

    domAttr.set(helpNode, "tabindex", "6");
    domAttr.set(helpNode, "role", "button");

    dojo.connect(helpNode, "onkeydown", function(evt){
      if (evt.keyCode === dojo.keys.ENTER) {
        dojo.stopEvent(evt);
        dijit.byId("appHelpMenu")._scheduleOpen(evt.target);
      }
    });

  },

  /**
   * Out of the box ONEUI header is not accessable. Need to apply certain
   * attributes to aid keyboard navigation.
   */
  _makePrintMenuAccessible: function (banner) {
    var printNode = banner._settingsNode;
    domAttr.set(printNode, "tabindex", "5");
    domAttr.set(printNode, "role", "button");

    dojo.connect(printNode, "onkeydown", function(evt){
      if (evt.keyCode === dojo.keys.ENTER) {
        dojo.stopEvent(evt);
        dijit.byId("appBannerPrintMenu")._scheduleOpen(evt.target);
      }
    });

  },

  /**
   * Our Person Menu is accessed when the user hovers (or clicks) the arrow next
   * to their username. This causes a hovercard to appear, containing the Person
   * menu items. This unusual approach means we need to surpress the default sub
   * menu behaviour and attach hovercard to the arrow.
   */
  _setupUserMenuHoverCard: function(hoverContentNode) {

      dojoAspect.after(idx.oneui.Header.prototype, "_renderUser",function() {
        domClass.add(this.userNode, "idxHeaderDropDown");
        var userNode_arrow =dojo.query(".idxHeaderDropDownArrow", this.userNode)[0];
        userNode_arrow.id = "curam-extapp_userMenuArrow";
        if (dojo.isIE !== 7) {
          domAttr.set(userNode_arrow, "onmouseover", "idx.oneui.HoverHelpTooltip.defaultPosition=['below']");
          domAttr.set(userNode_arrow, "onkeypress", "idx.oneui.HoverHelpTooltip.defaultPosition=['below']");
        } else {
          dojo.connect(userNode_arrow, 'onclick',idx.oneui.HoverHelpTooltip.defaultPosition=['below']);
        }
      });

      // The hovercard by default will always display to the right, and only if
      // there is not enough room there, will it then display to the left. This
      // is expected dojo behaviour. We want the card to always display to the
      // left. To achieve this without subclassing, we move the anchor (which
      // the hovercard displays below) to the extreme right edge of the screen
      // and move it and the hovercard back to their orginal position once
      // displayed. This ensures that the hovercard will always render below and
      // right of its anchor as we want.
      if (dojo.isIE !== 7) {
        // move the arrowNode to the right.
        dojoAspect.before(idx.oneui.HoverHelpTooltip, "show", function() {
          var arrowNode = dojo.byId("curam-extapp_userMenuArrow");
          var isLTR = CuramExternalApp._oneuiBanner.isLeftToRight();
          domStyle.set(arrowNode, isLTR ?
            {"position":"fixed", "top" : "30px", "right":"21px"} :
            {"position":"fixed", "top" : "30px", "left":"21px"});
        });
        // after rendered, move the arrowNode back.
        dojoAspect.after(idx.oneui.HoverHelpTooltip, "show", function() {
          domStyle.set(dojo.byId("curam-extapp_userMenuArrow"), "position", "static");
        });

        // Using the id passed in, when the widget was initialised, locate the
        // hover card holding node, and move it to its correct positon.
        dojoAspect.after(hoverContentNode, "onShow", lang.partial(function(hoverContentID) {
          var hoverHolderID = "idx_oneui__MasterHoverHelpTooltip_0";
          if (hoverContentID.lastIndexOf("_") != -1) {
            hoverHolderID = "idx_oneui__MasterHoverHelpTooltip_"
                    + hoverContentID.slice(hoverContentID.lastIndexOf("_")+1);
          }

          var oneuiBanner = CuramExternalApp._oneuiBanner;
          var helpExists = oneuiBanner._helpNode ? true : false;
          // One UI "settings" menu is used for printing
          var printMenuExists = oneuiBanner._settingsNode ? true : false;
          var logoExists = oneuiBanner.logoExists;

          var rightVal = 0;
          rightVal += logoExists ?
              domGeom.getMarginBox(query(
                  ".idxHeaderLogoBox", oneuiBanner._globalActionsNode)[0]).w : 0;
          rightVal += helpExists ? domGeom.getMarginBox(oneuiBanner._helpNode).w : 0;
          rightVal += printMenuExists ? domGeom.getMarginBox(oneuiBanner._settingsNode).w : 0;
          // We only want half of the width of the user menu arrow node
          // to place the hover card under it.
          rightVal += domGeom.getContentBox(
              query(".idxHeaderDropDownArrow", oneuiBanner.userNode)[0]).w / 2;

          // There is a difference of 14px between the right and left values.
          // This differece results from the margin-left property
          // selector: .oneui .idxOneuiHoverHelpTooltipBelow
          // in \ibmidxtk\idx\themes\oneui\idx\oneui\HoverHelpTooltip.css
          var isLTR = oneuiBanner.isLeftToRight();
          domStyle.set(dom.byId(hoverHolderID), isLTR ?
            {"left":"auto", "right": rightVal + "px"} :
            {"right":"auto", "left": (rightVal+14) + "px"});
        }, hoverContentNode.id));
      }

  },

  /**
   * We need a custom class name on the menu to safely alter its look without
   * affecting other widgets.
   *
   * The dom for the help menu is rebuilt by ONEUI each time the user opens the
   * menu. We therefore need to add our custom class name each time the menu is
   * open.
   */
  _addHelpMenuCustomClass: function(){
    var node = dijit.byId("appHelpMenu")._popupWrapper;
    if (!domClass.contains(node, "oneuiHeaderGlobalActionsMenu_help")){
      domClass.add(node, "oneuiHeaderGlobalActionsMenu_help");
    }
  },

  /**
   * Displays the specified page in a modal.
   */
  displayMegaMenuItemInModal: function(requestObj) {
    console.log(requestObj);
  },

  /**
   * When using JAWS12 with IE8, it causes the browser to crash whenever JAWS is
   * trying to read help or mega menu items who's total innerText length is
   * greater than 255 characters. As a fix for this, we need to temporarly
   * shorten the innertext of these menu items as JAWS is reading them. Once
   * JAWS starts to read the shorten version, we can restore the innerTexts
   * orginal value. Therefore, visually, the menu item text does not appear to
   * change. This change only occurs when menu items gains and loses focus or
   * when it is clicked and only happens for menu items that exceed the
   * character limit.
   */
  _preventJAWSCrashClick: function(widget) {

    var textCell = dojo.query("#" + widget.id + "_text", widget)[0];
    if(!textCell.isModified) {
      //As JAWS crashes when the innerText of the focused node contains more
      //than 255 characters, we need to make sure that the sum of each
      //individual text holding element, is less than this limit.
      dojo.query(".wtfoneui", textCell).forEach(function(textDiv) {
        textDiv.oldInnerText = textDiv.innerText;
        if (domClass.contains(textDiv, "MMtitle")) {
          textDiv.innerText = textDiv.innerText.substring(0, 229).concat("...");
        } else {
          var titleTextLen = textDiv.previousSibling;
          while (!domClass.contains(titleTextLen, "MMtitle")) {
            titleTextLen = titleTextLen.previousSibling;
          }
          titleTextLen = titleTextLen.innerText.length;
          //Need to account for the title texts length.
          var truncate = Math.min(250 - titleTextLen, Math.max(10, textDiv.innerText.length - titleTextLen));
          textDiv.innerText = textDiv.innerText.substring(0, truncate).concat("...");
        }
      });
      textCell.isModified = true;

      //Restore orginal value.
      textCell.innerModdedTimer && clearTimeout(textCell.innerModdedTimer);
      textCell.innerModdedTimer = setTimeout(dojo.partial(function(widget){
        if(textCell.isModified) {
          dojo.query(".wtfoneui", textCell).forEach(function(textDiv) {
            textDiv.innerText = textDiv.oldInnerText;
          });
          textCell.isModified = false;
          textCell["innerModdedTimer"] = undefined;
          try {
            delete textCell.innerModdedTimer;
          } catch (e) {/*IE7 doesnt like me delete the property*/}
        }
      }, widget), 2);
    }

  },

  /**
   * When using JAWS12 with IE8, it causes the browser to crash whenever JAWS is
   * trying to read help or mega menu items who's total innerText length is
   * greater than 255 characters. As a fix for this, we need to temporarly
   * shorten the innertext of these menu items as JAWS is reading them. Once
   * JAWS starts to read the shorten version, we can restore the innerTexts
   * orginal value. Therefore, visually, the menu item text does not appear to
   * change. This change only occurs when menu items gains and loses focus or
   * when it is clicked and only happens for menu items that exceed the
   * character limit.
   */
  _preventJAWSCrashFocus: function(widget) {

    //Node holding the menu items text elements
    var textCell = dojo.query("#" + widget.id + "_text", widget)[0];
    if(!textCell.isModified) {
      //As JAWS crashes when the innerText of the focused node contains more
      //than 255 characters, we need to make sure that the sum of each
      //individual text holding element, is less than this limit.
      dojo.query(".wtfoneui", textCell).forEach(function(textDiv) {
        textDiv.oldInnerText = textDiv.innerText;
        if (domClass.contains(textDiv, "MMtitle")) {
          textDiv.innerText = textDiv.innerText.substring(0, 229).concat("...");
        } else {
          var titleTextLen = textDiv.previousSibling;
          while (!domClass.contains(titleTextLen, "MMtitle")) {
            titleTextLen = titleTextLen.previousSibling;
          }
          titleTextLen = titleTextLen.innerText.length;
          //Need to account for the title texts length.
          var truncate = Math.min(250 - titleTextLen, Math.max(10, textDiv.innerText.length - titleTextLen));
          textDiv.innerText = textDiv.innerText.substring(0, truncate).concat("...");
        }
      });
      textCell.isModified = true;

      //Either the orginal value will be restored by this timeout function,
      //or it will be restored when the menu item loses focus and our
      //handler deals with it.
      textCell.innerModdedTimer && clearTimeout(textCell.innerModdedTimer);
      textCell.innerModdedTimer = setTimeout(dojo.partial(function(widget){
        if(textCell.isModified) {
          dojo.query(".wtfoneui", textCell).forEach(function(textDiv) {
            textDiv.innerText = textDiv.oldInnerText;
          });
          textCell.isModified = false;
          textCell["innerModdedTimer"] = undefined;
          try {
            delete textCell.innerModdedTimer;
          } catch (e) {/*IE7 doesnt like me deleting the property*/}
        }
      }, widget), 2);
    }
  },

  /**
   * When using JAWS12 with IE8, it causes the browser to crash whenever JAWS is
   * trying to read help or mega menu items who's total innerText length is
   * greater than 255 characters. As a fix for this, we need to temporarly
   * shorten the innertext of these menu items as JAWS is reading them. Once
   * JAWS starts to read the shorten version, we can restore the innerTexts
   * orginal value. Therefore, visually, the menu item text does not appear to
   * change. This change only occurs when menu items gains and loses focus or
   * when it is clicked and only happens for menu items that exceed the
   * character limit.
   */
  _preventJAWSCrashBlur: function(widget) {

    //Node holding the menu items text elements
    var textCell = dojo.query("#" + widget.id + "_text", widget)[0];
    textCell.innerModdedTimer && clearTimeout(textCell.innerModdedTimer);
    //Restore orginal value, if it has been modified.
    if(textCell.isModified) {
      dojo.query(".wtfoneui", textCell).forEach(function(textDiv) {
        textDiv.innerText = textDiv.oldInnerText;
      });
      textCell.isModified = false;
    }
  },

  /**
   * Added as part of the skip link fix TEC-15122
   * Allows screen readers to 'jump' straight to main content of the page,
   * avoiding having to read through all the navigational elements of the page.
   *
   * The code below is replicated from curam.util.skipLinkFocus()
   * Due to layering issues we replicated the function rather than pull in
   * util.js file. Should remove this once implement proper application wide
   * layering.
   */
  _skipLinkFocus: function(destId) {
    destId = destId || 'app-content';
    var dest = dojo.byId(destId);
    if (dest) {
      dest.focus();
    }
  },

  /**
   * TEC-16453. Skiplink should become visible when focused (i.e. a user tabs on it)
   * and it should be visible only when it has focus, so it should hide again when
   * the user tabs off it.
   */
  _showHideSkipLink: function(e) {
    var skipLink = dojo.byId("skipLink");
    if (skipLink) {
      var skipLinkDiv = skipLink.parentNode;
      if (e.type == "focus" && domClass.contains(skipLinkDiv, "hidden")) {
        domClass.remove(skipLinkDiv, "hidden");
      } else if (e.type == "blur" && !domClass.contains(skipLinkDiv, "hidden")) {
        domClass.add(skipLinkDiv, "hidden");
      }
    }
  },

/*
  print: function() {
    // if the "curam-iframe" exists
    var iframe = query("iframe.curam-iframe", "app-content")[0];
    console.log("PRINTING IFRAME:" + iframe);
    if (iframe) {
      if (dojo.isIE < 9) {
        iframe.contentWindow.document.execCommand("print", false, null);
      } else {
        iframe.contentWindow.print();
      }
    } else {
      window.print();
    }
  }
*/

  print: function() {
    // if the "curam-iframe" exists
    var iframe = query("#app-content iframe.curam-iframe")[0];
    console.log("PRINTING IFRAME:" + iframe);
    if (iframe) {
      if (dojo.isIE < 11) {
        console.log("# IE: " + dojo.isIE + ", calling iframe.contentWindow.document.execCommand");
        iframe.contentWindow.document.execCommand("print", false, null);
      } else {
        console.log("# Calling iframe.contentWindow.print()");
        iframe.contentWindow.print();
      }
    } else {
      console.log("# Calling window.print()");
      window.print();
    }
  }

  });
});

},
'dijit/layout/ContentPane':function(){
define("dijit/layout/ContentPane", [
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject
	"../_Widget",
	"./_ContentPaneResizeMixin",
	"dojo/string", // string.substitute
	"dojo/html", // html._ContentSetter html._emptyNode
	"dojo/i18n!../nls/loading",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.attr
	"dojo/_base/window", // win.body win.doc.createDocumentFragment
	"dojo/_base/xhr", // xhr.get
	"dojo/i18n" // i18n.getLocalization
], function(kernel, lang, _Widget, _ContentPaneResizeMixin, string, html, nlsLoading,
	array, declare, Deferred, dom, domAttr, win, xhr, i18n){

/*=====
	var _Widget = dijit._Widget;
	var _ContentPaneResizeMixin = dijit.layout._ContentPaneResizeMixin;
=====*/

// module:
//		dijit/layout/ContentPane
// summary:
//		A widget containing an HTML fragment, specified inline
//		or by uri.  Fragment may include widgets.


return declare("dijit.layout.ContentPane", [_Widget, _ContentPaneResizeMixin], {
	// summary:
	//		A widget containing an HTML fragment, specified inline
	//		or by uri.  Fragment may include widgets.
	//
	// description:
	//		This widget embeds a document fragment in the page, specified
	//		either by uri, javascript generated markup or DOM reference.
	//		Any widgets within this content are instantiated and managed,
	//		but laid out according to the HTML structure.  Unlike IFRAME,
	//		ContentPane embeds a document fragment as would be found
	//		inside the BODY tag of a full HTML document.  It should not
	//		contain the HTML, HEAD, or BODY tags.
	//		For more advanced functionality with scripts and
	//		stylesheets, see dojox.layout.ContentPane.  This widget may be
	//		used stand alone or as a base class for other widgets.
	//		ContentPane is useful as a child of other layout containers
	//		such as BorderContainer or TabContainer, but note that those
	//		widgets can contain any widget as a child.
	//
	// example:
	//		Some quick samples:
	//		To change the innerHTML: cp.set('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList: cp.set('content', dojo.query('div [class=selected]', userSelection))
	//
	//		To do an ajax update: cp.set('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; Use set('href', ...);
	href: "",

	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to set("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// parserScope: String
	//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	//		will search for data-dojo-type (or dojoType).  For backwards compatibility
	//		reasons defaults to dojo._scopeName (which is "dojo" except when
	//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
	parserScope: kernel._scopeName,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via set('content', ...) / set('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	/*======
	// ioMethod: dojo.xhrGet|dojo.xhrPost
	//		Function that should grab the content specified via href.
	ioMethod: dojo.xhrGet,
	======*/

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="href: './bar', ioArgs: {timeout: 500}">
	ioArgs: {},

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior set('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href
	//		or content is loaded.
	onLoadDeferred: null,

	// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	_setTitleAttr: null,

	// Flag to parser that I'll parse my contents, so it shouldn't.
	stopParser: true,

	// template: [private] Boolean
	//		Flag from the parser that this ContentPane is inside a template
	//		so the contents are pre-parsed.
	// (TODO: this declaration can be commented out in 2.0)
	template: false,

	create: function(params, srcNodeRef){
		// Convert a srcNodeRef argument into a content parameter, so that the original contents are
		// processed in the same way as contents set via set("content", ...), calling the parser etc.
		// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
		if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
			var df = win.doc.createDocumentFragment();
			srcNodeRef = dom.byId(srcNodeRef);
			while(srcNodeRef.firstChild){
				df.appendChild(srcNodeRef.firstChild);
			}
			params = lang.delegate(params, {content: df});
		}
		this.inherited(arguments, [params, srcNodeRef]);
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = string.substitute(this.loadingMessage, messages);
		this.errorMessage = string.substitute(this.errorMessage, messages);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
		// For subclasses of ContentPane that do have a template, does nothing.
		if(!this.containerNode){
			this.containerNode = this.domNode;
		}

		// remove the title attribute so it doesn't show up when hovering
		// over a node  (TODO: remove in 2.0, no longer needed after #11490)
		this.domNode.removeAttribute("title");

		if(!domAttr.get(this.domNode,"role")){
			this.domNode.setAttribute("role", "group");
		}
	},

	startup: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		this.inherited(arguments);

		// And this catches stuff like dojo.dnd.Source
		if(this._contentSetter){
			array.forEach(this._contentSetter.parseResults, function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			}, this);
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use set('href', ...) instead.
		kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
		return this.set("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so set("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));

		this._set("href", href);

		// _setHrefAttr() is called during creation and by the user, after creation.
		// Assuming preload == false, only in the second case do we actually load the URL;
		// otherwise it's done in startup(), and only if this widget is shown.
		if(this.preload || (this._created && this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use set('content', ...) instead.
		kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
		this.set("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make set("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this._set("href", "");

		// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		if(this._created){
			// For back-compat reasons, call onLoad() for set('content', ...)
			// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)
			// or as initialization parameter (ie: new ContentPane({content: ...})
			this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));
		}

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

		return this.onLoadDeferred; 	// Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make get("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		this.inherited(arguments);

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				return this.refresh();	// If child has an href, promise that fires when the load is complete
			}
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));
		this._load();
		return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(lang.isObject(this.ioArgs)){
			lang.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this._set("isLoaded", true);
		try{
			this.onLoadDeferred.callback(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this._set("isLoaded", false);
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		array.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			array.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == win.body()){
					widget.destroyRecursive(preserveDom);
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		if(!preserveDom){
			html._emptyNode(this.containerNode);
		}

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof html._ContentSetter)){
			setter = this._contentSetter = new html._ContentSetter({
				node: this.containerNode,
				_onError: lang.hitch(this, this._onError),
				onContentError: lang.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		}

		var setterParams = lang.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: !cont.domNode && this.parseOnLoad,
			parserScope: this.parserScope,
			startup: false,
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		}, this._contentSetterParams || {});

		setter.set( (lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(!isFakeContent){
			if(this._started){
				// Startup each top level child widget (and they will start their children, recursively)
				delete this._started;
				this.startup();

				// Call resize() on each of my child layout widgets,
				// or resize() on my single child layout widget...
				// either now (if I'm currently visible) or when I become visible
				this._scheduleLayout();
			}

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// override on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	// EVENT's, should be overide-able
	onLoad: function(/*===== data =====*/){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ /*===== error =====*/){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ /*===== error =====*/){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

});

},
'idx/oneui/common':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/common", ["exports", "dojo/_base/sniff", "dojo/_base/window", "dojo/dom-construct"], function(exports, has, win, domConstruct){
	
	function _getFontMeasurements(){
		var heights = {
			'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,
			'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,
			'xx-large': 0
		};
		var p;
		if(has("ie")){
			win.doc.documentElement.style.fontSize="100%";
		}
		var div = domConstruct.create("div", {style: {
				position: "absolute",
				left: "0",
				top: "-100px",
				width: "30px",
				height: "1000em",
				borderWidth: "0",
				margin: "0",
				padding: "0",
				outline: "none",
				lineHeight: "1",
				overflow: "hidden"
			}}, win.body());
		for(p in heights){
			div.style.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}

		win.body().removeChild(div);
		return heights; //object
	};
	var fontMeasurements = null;
	function _getCachedFontMeasurements(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = _getFontMeasurements();
		}
		return fontMeasurements;
	};
	
	
	
	exports.normalizedLength = function(len) {
		if(len.length === 0){ return 0; }
		if(len.length > 2){
			var px_in_pt = _getCachedFontMeasurements()["12pt"] / 12;
			var val = parseFloat(len);
			switch(len.slice(-2)){
				case "px": return val;
				case "pt": return val * px_in_pt;
				case "in": return val * 72 * px_in_pt;
				case "pc": return val * 12 * px_in_pt;
				case "mm": return val * g.mm_in_pt * px_in_pt;
				case "cm": return val * g.cm_in_pt * px_in_pt;
			}
		}
		return parseFloat(len);	// Number
	}
	
});
},
'dijit/_WidgetsInTemplateMixin':function(){
define("dijit/_WidgetsInTemplateMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/parser", // parser.parse
	"dijit/registry"	// registry.findWidgets
], function(array, declare, parser, registry){

	// module:
	//		dijit/_WidgetsInTemplateMixin
	// summary:
	//		Mixin to supplement _TemplatedMixin when template contains widgets

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				var cw = (this._startupWidgets = parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}));

				this._supportingWidgets = registry.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		}
	});
});

},
'dijit/_HasDropDown':function(){
define("dijit/_HasDropDown", [
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/_base/event", // event.stop
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has",
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/touch",
	"dojo/_base/window", // win.doc
	"dojo/window", // winUtils.getBox
	"./registry",	// registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, event,dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, touch,
			win, winUtils, registry, focus, popup, _FocusMixin){

/*=====
	var _FocusMixin = dijit._FocusMixin;
=====*/

	// module:
	//		dijit/_HasDropDown
	// summary:
	//		Mixin for widgets that need drop down ability.

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown's on the arrow icon
			if(this.disabled || this.readOnly){ return; }

			// Prevent default to stop things like text selection, but don't stop propogation, so that:
			//		1. TimeTextBox etc. can focusthe <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			e.preventDefault();

			this._docHandler = this.connect(win.doc, touch.release, "_onDropDownMouseUp");

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop down is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.
			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				if(dropDown.focus && dropDown.autoFocus !== false){
					// Focus the dropdown widget - do it on a delay so that we
					// don't steal our own focus.
					window.setTimeout(lang.hitch(dropDown, "focus"), 1);
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// setTimeout() needed to make it work on IE (test DateTextBox)
				setTimeout(lang.hitch(this, "focus"), 0);
			}

			if(has("ios")){
				this._justGotMouseUp = true;
				setTimeout(lang.hitch(this, function(){
					this._justGotMouseUp = false;
				}), 0);
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			if(has("ios") && !this._justGotMouseUp){
				// This branch fires on iPhone for ComboBox, because the button node is an <input> and doesn't
				// generate touchstart/touchend events.   Pretend we just got a mouse down / mouse up.
				// The if(has("ios") is necessary since IE and desktop safari get spurious onclick events
				// when there are nested tables (specifically, clicking on a table that holds a dijit.form.Select,
				// but not on the Select itself, causes an onclick event on the Select)
				this._onDropDownMouseDown(e);
				this._onDropDownMouseUp(e);
			}

			// The drop down was already opened on mousedown/keydown; just need to call stopEvent().
			if(this._stopClickEvents){
				event.stop(e);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events

			this.inherited(arguments);

			this.connect(this._buttonNode, touch.press, "_onDropDownMouseDown");
			this.connect(this._buttonNode, "onclick", "_onDropDownClick");
			this.connect(this.focusNode, "onkeypress", "_onKey");
			this.connect(this.focusNode, "onkeyup", "_onKeyUp");
		},

		destroy: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){ return; }

			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					event.stop(e);
					return;
				}
			}
			if(d && this._opened && e.charOrCode == keys.ESCAPE){
				this.closeDropDown();
				event.stop(e);
			}else if(!this._opened &&
					(e.charOrCode == keys.DOWN_ARROW ||
						( (e.charOrCode == keys.ENTER || e.charOrCode == " ") &&
						  //ignore enter and space if the event is for a text input
						  ((target.tagName || "").toLowerCase() !== 'input' ||
						     (target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				event.stop(e);
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					setTimeout(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Don't focus on button if the user has explicitly focused on something else (happens
			// when user clicks another control causing the current popup to close)..
			// But if focus is inside of the drop down then reset focus to me, because IE doesn't like
			// it when you display:none a node with focus.
			var focusMe = focus.curNode && this.dropDown && dom.isDescendant(focus.curNode, this.dropDown.domNode);

			this.closeDropDown(focusMe);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit.popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				this._preparedNode = true;
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}

			// Code for resizing dropdown (height limitation, or increasing width to match my width)
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				domStyle.set(ddNode, myStyle);

				// Figure out maximum height allowed (if there is a height restriction)
				var maxHeight = this.maxHeight;
				if(maxHeight == -1){
					// limit height to space available in viewport either above or below my domNode
					// (whichever side has more room)
					var viewport = winUtils.getBox(),
						position = domGeometry.position(aroundNode, false);
					maxHeight = Math.floor(Math.max(position.y, viewport.h - (position.y + position.h)));
				}

				// Attach dropDown to DOM and make make visibility:hidden rather than display:none
				// so we call startup() and also get the size
				popup.moveOffScreen(dropDown);

				if(dropDown.startup && !dropDown._started){
					dropDown.startup(); // this has to be done after being added to the DOM
				}
				// Get size of drop down, and determine if vertical scroll bar needed
				var mb = domGeometry.getMarginSize(ddNode);
				var overHeight = (maxHeight && mb.h > maxHeight);
				domStyle.set(ddNode, {
					overflowX: "hidden",
					overflowY: overHeight ? "auto" : "hidden"
				});
				if(overHeight){
					mb.h = maxHeight;
					if("w" in mb){
						mb.w += 16;	// room for vertical scrollbar
					}
				}else{
					delete mb.h;
				}

				// Adjust dropdown width to match or be larger than my width
				if(this.forceWidth){
					mb.w = aroundNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, aroundNode.offsetWidth);
				}else{
					delete mb.w;
				}

				// And finally, resize the dropdown to calculated height and width
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					domGeometry.setMarginBox(ddNode, mb);
				}
			}

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
				}
			});
			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;

			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._opened){
				if(focus){ this.focus(); }
				popup.close(this.dropDown);
				this._opened = false;
			}
		}

	});
});

},
'cwtk/widget/FragmentPane':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/FragmentPane", [
    "dojo", 
    "dojo/_base/declare", 
    "dojo/_base/lang", 
    "dojox/layout/ContentPane",
    "cwtk/util/UIMFragment"
], function(dojo, declare, lang, ContentPane, UIMFragment){

		return declare("cwtk.widget.FragmentPane", ContentPane, {
           uim: "", 
           parameters: null,
           isUimLoaded: false,
           
           startup : function() {
               this.inherited(arguments);
               this._onStart();
           },
           
           _onStart : function() {
               this.onStart();
               this.loadUim();
           },
           
           onStart : function() {
               //called after creation
           },
           
           loadUim: function() {
               if (this.uim && this.uim.length > 0 && !this.isUimLoaded) {
                   this.isUimLoaded = true;
                   var frag = new UIMFragment();
                   frag.load(this.id, this.uim, this.parameters);
               }
               
           },
           
           refreshUim: function() {
               this.isUimLoaded = false;
               this.loadUim();
           },
           
            
           destroy : function() {
               this.inherited(arguments);
           }
        });

});
},
'cwtk/eligibilityresults/EligibilityResult':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("cwtk/eligibilityresults/EligibilityResult", [
    "dojo", 
    "dojo/_base/declare", 
    "dojo/NodeList-traverse", 
    "dojo/fx", 
    "cwtk/eligibilityresults/CategoryAction",
    "cwtk/eligibilityresults/ProgramAction",
    "cwtk/eligibilityresults/Transitions"
], function(dojo, declare, traverse, fx, CategoryAction, ProgramAction, Transitions){

		return declare("cwtk.eligibilityresults.EligibilityResult", null, {
    
		    transitions: new Transitions(),
		    
		    // Events
		    programAction : new ProgramAction(),
		    categoryAction: new CategoryAction(),
		    
		    _upfrontLoadingCount : 0,
		
			showHideDetails:function(node) {
				
				var titlePane = dojo.query(node).parents(".cw-program").first()[0];
				var hidden = dojo.hasClass(titlePane, 'cw-collapsed');
    			
    			var focusOn = function() {
                    dojo.query('.cw-program-title-show-hide a', titlePane).forEach(function(n){
                        if (n != node) {
                            n.focus();
                        }
                    });
    			}
				
				dojo.forEach(
				    dojo.query(".cw-program-details", titlePane), 
				    function(panel){
					
    					if(hidden){
    					    dojo.style(panel, 'display', 'none');//workaround for smooth transition
				            dojo.addClass(titlePane, 'cw-expanded');
            				dojo.removeClass(titlePane, 'cw-collapsed');
    						dojo.fx.wipeIn({node:panel, duration:300}).play();
    						focusOn();
    					} else {
    						dojo.fx.wipeOut({node:panel, duration:300, onEnd: function(){
    						    dojo.addClass(titlePane, 'cw-collapsed');
		                        dojo.removeClass(titlePane, 'cw-expanded');
		                        focusOn();
    						}}).play();
    					}
				    });
			},
		
			programMenuAction: function(motivationID, programID, url) {
			    this.programAction.execute({programID:programID, url:url, motivationID:motivationID});
			},
			
			categoryMenuAction: function(motivationID, categoryID, url, title) {
			    this.categoryAction.execute({url:url, title:title, motivationID:motivationID, categoryID:categoryID});
			},
			
			upfrontLoading: function(pane) {
			     
			    var that = this;
			    var layout = dojo.byId('eligibility-main-layout');
			    
			    var handleStart = function(ev) {
    		        that._upfrontLoadingCount++;
    		        that._createOverlay(layout);
			    };
			    var handleStop = function(ev) {
			        that._upfrontLoadingCount--;
			        if (that._upfrontLoadingCount <= 0) {
			            dojo.style(that._overlay(layout), 'display', 'none');
			            setTimeout(function(){
			                dojo.destroy(that._overlay(layout))
		                }, 1000);
			        }
			    };
			    
		        var cp = dijit.byId(pane);
		        dojo.connect(cp, 'onDownloadStart', handleStart);
		        dojo.connect(cp, 'onDownloadEnd', handleStop);
		        dojo.connect(cp, 'onDownloadError', handleStop);
			},
			
			_overlay : function(layout) {
			    return dojo.byId(layout.id + '_overlay');
			},
			
			_createOverlay : function(layout) {
			    return dojo.create('div', {
    			        id : layout.id + '_overlay',
    			        innerHTML : "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span></span>",
    			        style: {position: 'absolute', width: '100%', height: '100%', background: 'white', zIndex: '999'}
    		        }, layout);
			}
				
		});

});

},
'cwtk/widget/DropDown':function(){
require({cache:{
'url:cwtk/widget/templates/DropDown.html':"<span class=\"dijit dijitReset dijitInline\">\r\n  <span class='dijitReset dijitInline' \r\n    data-dojo-attach-event=\"ondijitclick:_onClick\" \r\n    data-dojo-attach-point=\"_buttonNode\" >\r\n    <span class=\"dijitReset dijitStretch dijitButtonContents\"   \r\n      data-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"   \r\n      role=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\">\r\n      <span class=\"dijitReset dijitInline dijitIcon\" \r\n        data-dojo-attach-point=\"iconNode\">\n      </span>\r\n      <span class=\"dijitReset dijitInline dijitButtonText\" \r\n        data-dojo-attach-point=\"containerNode,_popupStateNode\" \r\n        id=\"${id}_label\">\n      </span>\r\n    </span>\r\n  </span >\r\n  <input ${!nameAttrSetting} type=\"${type}\" \r\n    value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"  \r\n    data-dojo-attach-point=\"valueNode\"/>\r\n</span>"}});
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/DropDown", [
    "dojo", 
    "dojo/_base/declare", 
    "dijit/form/DropDownButton", 
    "cwtk/widget/_OrientedDropDown", 
    "dojo/text!./templates/DropDown.html"
], function(dojo, declare, DropDownButton, _OrientedDropDown, template){

		return declare("cwtk.widget.DropDown", [DropDownButton, _OrientedDropDown], {
		   
		   isButton : false,
		   _isFocusable : false,
		   
		   _timerHover : null,
		   
		   doEmployOrientationIE8Hack_ : true,
		   
		   postMixInProperties : function() {
			   this.inherited(arguments);
		       if(!this.isButton) {
		           this.templateString = template;
	           }
		   }, 
		   startup : function() {
			   this.inherited(arguments);
			   this.connector = dojo.query('.dijitTooltipConnector', this.dropDown.domNode)[0];
			   this.aroundNode = this._aroundNode || this.domNode;
			   if (this.isButton) {
			       this.aroundNode = dojo.query('.dijitButtonNode', this.domNode)[0];
		       }
			   dojo.connect(this.dropDown, "onMouseLeave", dojo.hitch(this, function() {
			       this.closeDropDown(true);
		       }));
			   dojo.connect(this.dropDown, "onMouseOver", dojo.hitch(this, function() {
			       clearTimeout(this._timerHover);
			       delete this._timerHover;
		       }));
			   dojo.connect(this, "onMouseLeave", dojo.hitch(this, function() {
			       if (this._opened) {
    			       this._timerHover = setTimeout(dojo.hitch(this, function(){
        			       this.closeDropDown(true);
        			   }), 2000);
			       }
		       }));
			   this.focusNode.tabIndex = (this._isFocusable ? "0" : "-1");
		       
		   }, 
		   destroy : function() {
			   this.inherited(arguments);
		   }, 
		   openDropDown : function() {
			   this.inherited(arguments);
			   this.fixDropDown();
		   }  
		});

});
},
'dijit/form/_CheckBoxMixin':function(){
define("dijit/form/_CheckBoxMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/event" // event.stop
], function(declare, domAttr, event){

	// module:
	//		dijit/form/_CheckBoxMixin
	// summary:
	// 		Mixin to provide widget functionality corresponding to an HTML checkbox

	return declare("dijit.form._CheckBoxMixin", null, {
		// summary:
		// 		Mixin to provide widget functionality corresponding to an HTML checkbox
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,
		
		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-checked",

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			domAttr.set(this.focusNode, 'readOnly', value);
		},

		// Override dijit.form.Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox.layout.TabContainer
		_setLabelAttr: undefined,

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}
			this.inherited(arguments);
		},

		reset: function(){
			this.inherited(arguments);
			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this.params.value || "on");
			domAttr.set(this.focusNode, 'value', this.value);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				event.stop(e);
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'curam/html':function(){
/*
 This file provides general html manipulation functions.
*/
define("curam/html", ["curam/define"
        ], function() {
  
  curam.define.singleton("curam.html", {
    splitWithTag: function(value, delim, tagName, fnModifier) {
      // summary: Splits a string value into tokenized elements, then wraps
      //          the specified tag name, or "div" if no tagName is specified.
      //          E.g. calling 
      //            curam.html.splitWithTag("hello\nworld", "\n", "div")
      //          returns
      //            "<div>hello</div><div>world</div>
      //          If fnModifier is speficied, it should be a function to which
      //          each split element is passed, and should return a new value for
      //          that element.
      var splitVal = value.split(delim || "\n");
      
      // If there are no delimiters found, do not wrap any tags around the value.
      if(splitVal.length < 2) {
        return fnModifier ? fnModifier(value) : value;
      }
      var t = (tagName || "div") + ">";
      var tagStart = "<" + t, tagEnd = "</" + t;
      
      if(fnModifier) {
        for(var i = 0; i < splitVal.length; i++) {
          splitVal[i] = fnModifier(splitVal[i]);
        }
      }
      
      // Join the array of tokenized values together with an end and start tag.
      return tagStart + splitVal.join(tagEnd + tagStart) + tagEnd;
    }
  });
  
  return curam.html;
});

},
'dojo/html':function(){
define("dojo/html", ["./_base/kernel", "./_base/lang", "./_base/array", "./_base/declare", "./dom", "./dom-construct", "./parser"], function(dojo, lang, darray, declare, dom, domConstruct, parser) {
	// module:
	//		dojo/html
	// summary:
	//		TODOC

	lang.getObject("html", true, dojo);

	// the parser might be needed..

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0;

	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		//
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = domConstruct.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element.
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes

		// always empty
		domConstruct.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = domConstruct.toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && lang.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					domConstruct.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				domConstruct.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	declare("dojo.html._ContentSetter", null,
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",

			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,

			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.	Root for attribute names to search for.	  If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: dojo._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.	  Only obeyed if parseContent is true.
			startup: true,

			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..

				// the original params are mixed directly into the instance "this"
				lang.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dom.byId( this.node || node );

				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node) {
					// can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV

					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},

			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					darray.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},

			onBegin: function(){
				// summary
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;

				if(lang.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}

					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();

				this.content = cont;
				return this.node; /* DomNode */
			},

			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},

			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.node;
				delete this.content;
			},

			onContentError: function(err){
				return "Error occured setting content: " + err;
			},

			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					darray.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					this.parseResults = parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},

			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(lang.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};

	return dojo.html;
});

},
'url:dijit/templates/MenuBar.html':"<div class=\"dijitMenuBar dijitMenuPassive\" data-dojo-attach-point=\"containerNode\"  role=\"menubar\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress: _onKeyPress\"></div>\n",
'dojo/Stateful':function(){
define("dojo/Stateful", ["./_base/declare", "./_base/lang", "./_base/array"], function(declare, lang, array) {
	// module:
	//		dojo/Stateful
	// summary:
	//		TODOC

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	// example:
	//	|	var obj = new dojo.Stateful();
	//	|	obj.watch("foo", function(){
	//	|		console.log("foo changed to " + this.get("foo"));
	//	|	});
	//	|	obj.set("foo","bar");
	postscript: function(mixin){
		if(mixin){
			lang.mixin(this, mixin);
		}
	},

	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		//	name:
		//		The property to get.
		//	returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		// 		this just retrieves the object's property.
		// 		For example:
		//	|	stateful = new dojo.Stateful({foo: 3});
		//	|	stateful.get("foo") // returns 3
		//	|	stateful.foo // returns 3

		return this[name]; //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		//	returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		// 		the property. A programmatic setter may be defined in subclasses.
		// 		For example:
		//	|	stateful = new dojo.Stateful();
		//	|	stateful.watch(function(name, oldValue, value){
		//	|		// this will be called on the set below
		//	|	}
		//	|	stateful.set(foo, 5);
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myObj.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; //dojo.Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		//	name:
		//		Indicates the property to watch. This is optional (the callback may be the
		// 		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		// 		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		//	callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		// 		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);
		return {
			unwatch: function(){
				propertyCallbacks.splice(array.indexOf(propertyCallbacks, callback), 1);
			}
		}; //Object
	}

});

});

},
'cwtk/widget/Rotator':function(){
require({cache:{
'url:cwtk/widget/templates/Rotator.html':"<div class=\"cw-rotator\">\n\t<div class=\"cw-rotator-nav cw-rotator-nav-prev\" \n\t\tdata-dojo-attach-point=\"prevNode\" \n\t\tdata-dojo-attach-event=\"ondijitclick: _prev\">\n\t\t<ul>\n\t\t\t<li class=\"dojoxRotatorPrev dojoxRotatorIcon dojoxRotatorFirst dojoxRotatorLast\">\n\t\t\t\t<a href=\"#\">\n\t\t\t\t\t<span>Prev</span>\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\t<div class=\"cw-rotator-nav cw-rotator-nav-next\" \n\t\tdata-dojo-attach-point=\"nextNode\" data-dojo-attach-event=\"ondijitclick: _next\">\n\t\t<ul>\n\t\t\t<li class=\"dojoxRotatorPrev dojoxRotatorIcon dojoxRotatorFirst dojoxRotatorLast\">\n\t\t\t\t<a href=\"#\">\n\t\t\t\t\t<span>Next</span>\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\t<div class=\"cw-rotator-container-wrapper\" data-dojo-attach-point=\"containerWrapper\">\n\t\t<div class=\"cw-rotator-container\" \n\t\t\tdata-dojo-attach-point=\"containerNode\">\n\t\t</div>\n\t</div>\n</div>\n"}});
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/Rotator", [
    "dojo",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dijit/_Widget",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dojo/text!./templates/Rotator.html"
], function(dojo, declare, lang, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, template){

		return declare("cwtk.widget.Rotator", [_Widget,_TemplatedMixin,_WidgetsInTemplateMixin], {

		   prevNode: null,
		   nextNode: null,
		   containerWrapper: null,

		   templateString: template,

		   shift : 150,

		   duration : 750,

		   postMixInProperties : function() {
		       this.inherited(arguments);
	       },

		   buildRendering : function() {
               this.inherited(arguments);
		   },
           startup : function() {
               this.inherited(arguments);
               dojo.connect(this, "resize", this._onResize);

           },

           _onResize : function() {
               this.fixWidth();
               this.showArrows();

               setTimeout(dojo.hitch(this, function(){
                   this._slide(0);
               }), 1000);
           },

           fixWidth : function() {

               var totalWidth = 0;
               dojo.query(">", this.containerNode).forEach(function(node){
                   totalWidth += dojo.position(node).w;
               });
               dojo.style(this.containerNode, 'width', (totalWidth + 1) + 'px');

           },

           showArrows : function() {
               var posWrap = dojo.position(this.containerWrapper);
               var posCon = dojo.position(this.containerNode);

               if (posCon.w < posWrap.w) {
                   dojo.style(this.prevNode, 'display', 'none');
                   dojo.style(this.nextNode, 'display', 'none');
               } else {
                   dojo.style(this.prevNode, 'display', '');
                   dojo.style(this.nextNode, 'display', '');
               }
           },

           _prev : function(event) {
               var left = dojo.style(this.containerNode, 'left');

               var posWrap = dojo.position(this.containerWrapper);
               var posCon = dojo.position(this.containerNode);

               var diff = posWrap.x - posCon.x;
               if (diff > this.shift) {
                   left += this.shift;
               } else {
                   left += diff;
               }
               this._slide(left);
           },

           _next : function(event) {
               var left = dojo.style(this.containerNode, 'left');

               var posWrap = dojo.position(this.containerWrapper);
               var posCon = dojo.position(this.containerNode);

               var diff = (posWrap.x + posWrap.w) - (posCon.x + posCon.w);
               if ((diff + this.shift) > 0) {
                   left += diff;
               } else {
                   left -= this.shift;
               }
               this._slide(left);
           },

           _slide : function(shift) {
               dojo.animateProperty({node: this.containerNode,
                   properties: {left: (shift)},
                   duration: this.duration}).play();
           },

           destroy : function() {
               this.inherited(arguments);
           }
        });

});
},
'dojo/dnd/autoscroll':function(){
define("dojo/dnd/autoscroll", ["../main", "../window"], function(dojo) {
	// module:
	//		dojo/dnd/autoscroll
	// summary:
	//		TODOC

dojo.getObject("dnd", true, dojo);

dojo.dnd.getViewport = dojo.window.getBox;

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.window.getBox(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!

	var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;

	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n),
				overflow = (s.overflow.toLowerCase() in dojo.dnd._validOverflow),
				overflowX = (s.overflowX.toLowerCase() in dojo.dnd._validOverflow),
				overflowY = (s.overflowY.toLowerCase() in dojo.dnd._validOverflow);
			if(overflow || overflowX || overflowY){
				b = dojo._getContentBox(n, s);
				t = dojo.position(n, true);
			}
			// overflow-x
			if(overflow || overflowX){
				w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2);
				rx = e.pageX - t.x;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft;
				}
				dx = 0;
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
					oldLeft = n.scrollLeft;
					n.scrollLeft = n.scrollLeft + dx;
				}
			}
			// overflow-y
			if(overflow || overflowY){
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2);
				ry = e.pageY - t.y;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					ry += dojo.body().scrollTop;
				}
				dy = 0;
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
					oldTop = n.scrollTop;
					n.scrollTop  = n.scrollTop  + dy;
				}
			}
			if(dx || dy){ return; }
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

	return dojo.dnd;
});

},
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n",
'curam/util/ScreenContext':function(){
define("curam/util/ScreenContext", [], function() {
  
  var CONTEXT_KEYS = {
      DEFAULT_CONTEXT: 112,
      SAMPLE22: 2,
      SAMPLE21: 1,
      SAMPLE13: 4,
      SAMPLE12: 2,
      SAMPLE11: 1,
      EXTAPP: 1048576,
      CONTEXT_PORTLET: 524288,
      SMART_PANEL: 262144,
      NESTED_UIM: 131072,
      ORG_TREE: 65536,
      CONTEXT_PANEL: 32768,
      LIST_ROW_INLINE_PAGE: 8192,
      LIST_EVEN_ROW: 16384,
      TAB: 4096,
      TREE: 2048,
      AGENDA: 1024,
      POPUP: 512,
      MODAL: 256,
      HOME: 128,
      HEADER: 64,
      NAVIGATOR: 32,
      FOOTER: 16,
      OVAL: 8,
      RESOLVE: 4,
      ACTION: 2,
      ERROR: 1,
      EMPTY: 0
  };
  
  var CTX_NAMES = [['ERROR', 'ACTION', 'RESOLVE', 'OPT_VALIDATION',
                       'FOOTER', 'NAVIGATOR', 'HEADER',
                       'HOME_PAGE', 'MODAL', 'POPUP', 'AGENDA','TREE', 'TAB', 
                       'LIST_EVEN_ROW', 'LIST_ROW_INLINE_PAGE', 'CONTEXT_PANEL', 
                       'ORG_TREE','NESTED_UIM','SMART_PANEL',
                       'CONTEXT_PORTLET','EXTAPP'],
                   ['SAMPLE11', 'SAMPLE12','SAMPLE13'],
                   ['SAMPLE21','SAMPLE22']];
  
  var ScreenContext = dojo.declare("curam.util.ScreenContext", null, {
    constructor: function(initialContext){
      // summary:
      //    Sets up the ScreenContext with either the initialContext parameter
      //    or a default context
      
      if (initialContext) {
        
        this.setContext(initialContext);
      } else {
        // What's the point of the OR here? Aren't they the same?
        this.currentContext = [
              CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]];
      }
    },
    
    setContext: function(newContext) {
      // summary:
      //    Sets the context. If null, a default context is used.
      var tmp = this.setup(newContext);
      
      this.currentContext =  
        ((tmp == null) ? 
         ([CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]]) : (tmp));
    },
  
    addContextBits: function(contextBits, idx) {
      // summary:
      //    Adds context bits to the existing context
      if (!contextBits) {
        return;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        this.currentContext[navig] |= pContext;
      }
      return this.currentContext[navig];
    },
  
    addAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      var navig = (idx)? idx : 0;
      this.currentContext[navig] = 4294967295;
      return this.currentContext[navig];
    },
  
    clear: function(contextBits, idx) {
      // summary:
      //    Clears the given named context bits
      if (!contextBits) {
        this.clearAll();
        return;
      }
      var navig = (idx)? idx : 0;
      if (contextBits == 0) {
        return this.currentContext[navig];
      }
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var clearedBits = this.currentContext[navig] & pContext;
        this.currentContext[navig] ^= clearedBits;
      }
      return this.currentContext[navig];
    },
  
    clearAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      if (idx) {
        this.currentContext[idx] = 0;
      } else {
        for (var i = 0; i <this.currentContext.length; i++) {
          this.currentContext[i] = 0;
        }
      }
    },
  
    updateStates: function(newContext) {
      this.clear('ERROR|ACTION|RESOLVE');
      this.currentContext[0] = this.currentContext[0] | (newContext & 7);
    },
  
    hasContextBits: function(contextBits, idx) {
      if (!contextBits) {
        return false;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var merge = this.currentContext[navig] & pContext;
        
        return (merge == pContext);
      }
      return false;
    },
  
    getValue: function() {
      // summary:
      //    Gets the value of the context.
      var outputVal = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        outputVal += this.currentContext[i] + "|";
      }
      return outputVal.substring(0,outputVal.length-1);
    },
  
    toRequestString: function() {
      return "o3ctx=" + this.getValue();
    },
  
    toBinary: function() {
      var binaryStr = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        binaryStr += this.currentContext[i].toString(2) + "|";
      }
      return binaryStr.substring(0,binaryStr.length-1);
    },
  
    toString: function() {
      var accumulatedContext = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        var ctxList = "";
        var j = 0;
        while (j < CTX_NAMES[i].length) {
          if (((this.currentContext[i] >> j) & 1) != 0) {
            ctxList +="," + CTX_NAMES[i][j];
          }
          j++;
        }
        if (ctxList == '') {
          return "{}";
        }
        accumulatedContext += 
          "|" + ctxList.replace(",", "{") + ((ctxList.length == 0)?"" : "}");
      }
      return accumulatedContext.substring(1);
    },
  
    parseContext: function(contextString) {
      var tmpString = contextString.replace(/,/g, "|");
      
      var parts = tmpString.split("|");
      var tmp = isNaN(parts[0]) ? parseInt(CONTEXT_KEYS[parts[0]]) : parts[0];
      
      for(var i = 1; i < parts.length; i++){
        tmp = tmp | (isNaN(parts[i]) ? parseInt(CONTEXT_KEYS[parts[i]]) : parts[i]);
      }

      return (isNaN(tmp) ? null : tmp);
    },
  
    setup: function(stringWithBars) {
      // summary:
      //    Sets up the context using a string delimited by '|'
      if (!stringWithBars) {
        return null;
      }
      var initialArray = ("" + stringWithBars).split("|");
      var resultArray = new Array(initialArray.length);
      
      for (var i = 0; i < initialArray.length; i++) {
        resultArray[i] = 
            this.parseContext(initialArray[initialArray.length - i - 1]);
        resultArray[i] = resultArray[i] | resultArray[i];
        if (!resultArray[i] 
              || isNaN(resultArray[i]) 
              || resultArray[i] > 4294967295) {
          return null;
        }
      }
      return resultArray;
    }
  });
  
  return ScreenContext;
});

},
'dijit/layout/utils':function(){
define("dijit/layout/utils", [
	"dojo/_base/array", // array.filter array.forEach
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/lang", // lang.mixin
	".."	// for exporting symbols to dijit, remove in 2.0
], function(array, domClass, domGeometry, domStyle, lang, dijit){

	// module:
	//		dijit/layout/utils
	// summary:
	//		marginBox2contentBox() and layoutChildren()

	var layout = lang.getObject("layout", true, dijit);
	/*===== layout = dijit.layout =====*/

	layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
		// summary:
		//		Given the margin-box size of a node, return its content box size.
		//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
		//		to wait for the browser to compute sizes.
		var cs = domStyle.getComputedStyle(node);
		var me = domGeometry.getMarginExtents(node, cs);
		var pb = domGeometry.getPadBorderExtents(node, cs);
		return {
			l: domStyle.toPixelValue(node, cs.paddingLeft),
			t: domStyle.toPixelValue(node, cs.paddingTop),
			w: mb.w - (me.w + pb.w),
			h: mb.h - (me.h + pb.h)
		};
	};

	function capitalize(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	}

	function size(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			lang.mixin(widget, newSize);
		}else{
			// otherwise, call getMarginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
			lang.mixin(widget, dim);
		}
	}

	layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
			/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
		// summary:
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array of Widgets or at least objects containing:
		//			* domNode: pointer to DOM node to position
		//			* region or layoutAlign: position to place DOM node
		//			* resize(): (optional) method to set size of node
		//			* id: (optional) Id of widgets, referenced from resize object, below.
		// changedRegionId:
		//		If specified, the slider for the region with the specified id has been dragged, and thus
		//		the region's height or width should be adjusted according to changedRegionSize
		// changedRegionSize:
		//		See changedRegionId.

		// copy dim because we are going to modify it
		dim = lang.mixin({}, dim);

		domClass.add(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.    TODO: move these lines to LayoutContainer?   Unneeded other places I think.
		children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
			.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

		// set positions/sizes
		array.forEach(children, function(child){
			var elm = child.domNode,
				pos = (child.region || child.layoutAlign);
			if(!pos){
				throw new Error("No region setting for " + child.id)
			}

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.position = "absolute";

			domClass.add(elm, "dijitAlign" + capitalize(pos));

			// Size adjustments to make to this child widget
			var sizeSetting = {};

			// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
			// panes and width adjustment for left/right align panes.
			if(changedRegionId && changedRegionId == child.id){
				sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
			}

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				sizeSetting.w = dim.w;
				size(child, sizeSetting);
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				sizeSetting.h = dim.h;
				size(child, sizeSetting);
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client" || pos == "center"){
				size(child, dim);
			}
		});
	};


	return {
		marginBox2contentBox: layout.marginBox2contentBox,
		layoutChildren: layout.layoutChildren
	};
});

},
'cwtk/widget/_OrientedDropDown':function(){
/*
 * Licensed Materials - Property of IBM
 * 
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure 
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define("cwtk/widget/_OrientedDropDown", [
    "dojo", 
    "dojo/_base/declare",
    "dojo/has"
], function(dojo, declare, has){

		return declare("cwtk.widget._OrientedDropDown", null, {
		
		   aroundNode : null,
		   connector : null,
		   dropDown: null,
		   
		   /* Orientation: M (middle), L (left), R (right) */
		   orientation : '',
		   
		   /* Offset on dropdown position */
		   offset : 0,
		   
		   fixDropDownFirst_ : true,
		   doEmployOrientationIE8Hack_ : false,
		   
		   fixDropDown : function() {
			   if (!this.orientation || this.orientation === '') return;
			   
			   //reset margins
			   this.dropDown.domNode.style.marginLeft = 0;
    		   this.dropDown.domNode.style.marginRight = 0;
		       this.connector.style.marginLeft = 0;
    		   this.connector.style.marginRight = 0;
			   
			   //if overflows to the right, remove classes and orient to right
			   this.removeRightClasses(this.dropDown.domNode);
			   
			   var posAround = dojo.position(this.aroundNode, true);
			   var posDropDown = dojo.position(this.dropDown.domNode, true);
			   var posConnector = dojo.position(this.connector, true);
			   
			   //calculate position
			   
			   if (this.orientation === 'M') {
    			   var shiftConnector = (posAround.x + posAround.w / 2) - (posConnector.x + posConnector.w / 2);
    			   var shiftContainer = (posAround.x + posAround.w / 2) - (posDropDown.x + posDropDown.w / 2);
			   }
			   else if (this.orientation === 'L') {
    			   var shiftConnector = posAround.x - posConnector.x + 10;
    			   var shiftContainer = posAround.x - posDropDown.x;
			   }
			   else if (this.orientation === 'R') {
    			   var shiftConnector = (posAround.x + posAround.w) - (posConnector.x + posConnector.w) - 10;
    			   var shiftContainer = (posAround.x + posAround.w) - (posDropDown.x + posDropDown.w);
    			   
    			   // Ugly hack for GUM-3295
    			   // - in IE only, the nodes are not visible leading to bad posXXX.x|y coordinates
    			   // - this only affects the first time the drop down is shown, thus requiring a slight "shift" to 
    			   //    position things correctly
    			   if (this.doEmployOrientationIE8Hack_ && has("ie") <= 8 && this.fixDropDownFirst_ == true) {
				   	 this.fixDropDownFirst_ = false;
				   	 shiftContainer -= 30;
				   }
			   }
			   
			   if (!shiftConnector && !shiftContainer) {
			       console.log('Orientation not found.');
			       return;
			   }
    		   			   
			   //if overflows body on the left
			   if (posDropDown.x + shiftContainer < 0) {
				   //move to left corner plus 10 pixels of relief
				   shiftContainer = posDropDown.x * -1 + 10;
			   }
			   
			   this.connector.style.marginLeft = (shiftConnector - shiftContainer) + "px";
			   this.dropDown.domNode.style.marginLeft = (this.offset + shiftContainer) + "px";
			   
		   },
		   
		   resetDropDown : function() {
		       if (this.dropDown) {
    		       this.dropDown.domNode.style.marginLeft = '';
        		   this.dropDown.domNode.style.marginRight = '';
		       }
		       if (this.connector) {
    		       this.connector.style.marginLeft = '';
        		   this.connector.style.marginRight = '';
		       }
		   },
		   
		   removeRightClasses : function(node) {
		       var hasRight = false;
		       var classNames = dojo.attr(node, "class").split(" ");
			   for (var i = 0; i < classNames.length; i++) {
			       if (classNames[i].indexOf("Right") > -1) {
			           dojo.removeClass(node, classNames[i]);
			           hasRight = true;
			       }
		       }
		       return hasRight;
		   }  
		});

});
},
'url:dijit/templates/MenuSeparator.html':"<tr class=\"dijitMenuSeparator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>",
'dijit/_FocusMixin':function(){
define("dijit/_FocusMixin", [
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

/*=====
	var _WidgetBase = dijit._WidgetBase;
=====*/

	// module:
	//		dijit/_FocusMixin
	// summary:
	//		Mixin to widget to provide _onFocus() and _onBlur() methods that
	//		fire when a widget or it's descendants get/lose focus

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or it's descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/form/ValidationTextBox':function(){
require({cache:{
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"}});
define("dijit/form/ValidationTextBox", [
	"dojo/_base/declare", // declare
	"dojo/i18n", // i18n.getLocalization
	"./TextBox",
	"../Tooltip",
	"dojo/text!./templates/ValidationTextBox.html",
	"dojo/i18n!./nls/validate"
], function(declare, i18n, TextBox, Tooltip, template){

/*=====
	var Tooltip = dijit.Tooltip;
	var TextBox = dijit.form.TextBox;
=====*/

	// module:
	//		dijit/form/ValidationTextBox
	// summary:
	//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.


	/*=====
		dijit.form.ValidationTextBox.__Constraints = function(){
			// locale: String
			//		locale used for validation, picks up value from this widget's lang attribute
			// _flags_: anything
			//		various flags passed to regExpGen function
			this.locale = "";
			this._flags_ = "";
		}
	=====*/

	return declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: template,
		baseClass: "dijitTextBox dijitValidationTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		// 		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this.focused);
		},

		validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return (this.required && this._isEmpty(this.textbox.value)) ? this.missingMessage : this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this.focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._computePartialRE();
		},

		_computePartialRE: function(){
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function(re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			if(!this.invalidMessage){ this.invalidMessage = this.promptMessage; }
			if(this.missingMessage == "$_unset_$"){ this.missingMessage = this.messages.missingMessage; }
			if(!this.missingMessage){ this.missingMessage = this.invalidMessage; }
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		}
	});
});

},
'curam/util/SessionTimeout':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/SessionTimeout", ["curam/util",
        "dojo/_base/lang",
        "curam/debug",
        "curam/html",
        "curam/util/UimDialog",
        "curam/util/ResourceBundle"],
       function(util, lang, debug, html, uimDialog) {
  /*
   * Modification History
   * --------------------
   * 28-Jun-2014 BOS [CR00435242] Update the configuration for the expired user
   * message.
   * 03-Jun-2014 BOS [CR00434187] Initial Version.
   */
  /**
   * @name curam.util.SessionTimeout
   * @namespace Checks if and when a timeout warning modal is displayed to a
   * user immediately before their session times out.
   * 
   * This API provides methods for a session timeout warning modal dialog.
   * 
   * It reads a specific cookie that is set by the <code>RequestFilter</code>
   * Servlet and uses the information within that cookie to check if a modal
   * dialog needs to be displayed to the user to warn them that their session is
   * about to timeout.
   * 
   * This API is tightly coupled with the 
   * <code>external-session-timeout-dialog.jspx</code> and the 
   * <code>RequestFilter.java</code> Servlet.
   * 
   */
	
	/**
	 * Creating Resource Bundle Object to access localized resources.
	 */ 
	dojo.requireLocalization("curam.application", "TimeoutWarning");
	var bundle = new curam.util.ResourceBundle("TimeoutWarning");
  
  curam.define.singleton("curam.util.SessionTimeout", {
	// The page identifier for the logout page that will end the session if
	// a user clicks the logout button or the session automatically logs out.
	logoutPageID:"",
	
	// The minutes displayed for the countdown timer to inform user of time in
	// minutes that they have to take action within the modal before it 
	// automatically terminates the session.
	minutes:0,
	
	// The seconds displayed for the countdown timer to inform user of time in
	// seconds that they have to take action within the modal before it 
	// automatically terminates the session.
	seconds:0,
	
	// The node that display the user message
	userMessageNode:null,
	
	// The identifier of the node that displays the user message in the modal 
	userMessageNodeID:"userMessage",
	
	// The identifier of the node that displays the time left in the modal
	displayTimerNodeID:"displayTimer",
	
	// Indicates if the countdown timer should be stopped or not
	stopTimer:false,
	
	// The updated user message to be displayed in the modal dialog
	updatedUserMessage:null,
	
	// The text that will be supplied to modal button to inform user that they
	// should dismiss modal
	dismissModalBtnTxt:null,
	
	// CCS class name for modal buttons that are displayed to user. These class
	// names can be used to retrieve the DOM for these buttons and update the
	// style and text on them.
	displayButtonCssNames:".initially-hidden-widget.btn-id-1",
	
	// Indicates if a modal button action should logout a user.
	doLogout:true,
	
	// The length of time that it takes for the dialog to be displayed.
	timeForDialogToAppear:0,
	
	// The JSPX file used to display the session timeout warning dialog to the user.
	sessTimeoutWarningJSPXDialog:"external-session-timeout-warning-dialog.jspx",
	
	// The JSPX file used to display the session timeout dialog to the user.
	sessTimeoutJSPXDialog:"external-session-timeout-dialog.jspx",
	
	// The grace period afforded to the user when taking action within the modal.
	bufferingPeriod:null,

	/**
	 * Checks if a timeout warning dialog should be displayed to a user if their
	 * session is about to expire.
	 *  
	 * @param width                The configured width of the timeout warning 
	 * dialog.
	 * @param height               The configured height of the timeout warning 
	 * dialog.
	 * @param timeoutPeriod        The configured timeout period of the timeout
	 * warning dialog.
	 * @param timeoutWarningIssued Indicates if a timeout warning dialog has
	 * already been displayed to the user.
	 */
    checkSessionExpired: function(width, height, timeoutPeriod, bufferingPeriod) {     
      this.width = width;
	  this.height = height;
	  this.timeoutPeriod = timeoutPeriod;
	  this.stopChecking = false;
	
	  // 10 seconds is the default check for how often the check will be
	  // executed.
	  this.interval = 10000;
	
	  // if a grace period for checking that the session has not expired has not 
      // been explicitly set then set it to default of 30 seconds (30000 miliseconds)
      this.bufferingPeriod = bufferingPeriod == undefined ? 30000 : bufferingPeriod * 1000;

	  this.executeChecking = setInterval(function(){curam.util.SessionTimeout._executeSessionExpiredCheck();},this.interval);
    },
    
    /*
     * Executes the actual check to assess if the timeout warning dialog should
     * be displayed to the user.
     */
    _executeSessionExpiredCheck: function() {
      // get the latest session expiry cookie
      var latestSessionExpCookie = curam.util.getCookie('sessionExpiry');
      // the currsessionExpCookie holds the current cookie reference, if they do
      // not match then a new request has been issued so reset the timer back to
      
      // -10 seconds (as 10s has already passed) need to restart back to before 0
      if (this.currSessionExpCookie) {
    	if (this.currSessionExpCookie != latestSessionExpCookie) {
    	  this.timeForDialogToAppear = -10000;
    	  // TODO: Would be better to refactor _sessionExpiryCookieIsAsExpected
    	  // function and just set global variables in that function -- BOS
    	  this.validCookie
  	        = this._sessionExpiryCookieIsAsExpected(latestSessionExpCookie);
    	 
    	}
      } else {
    	// current cookie undefined indicates a new checking period so validate
    	// cookies
    	this.validCookie
  	      = this._sessionExpiryCookieIsAsExpected(latestSessionExpCookie);
    	this._ammendTimeoutPeriodForMisconfiguration(this.validCookie);  	
      }
      this.currSessionExpCookie = latestSessionExpCookie;
      
      this.timeForDialogToAppear = this.timeForDialogToAppear + this.interval;
      
      if (this.validCookie) {
    	  this.sessionExpiry = Math.abs(this.validCookie[0]);
    	  this.serverTime = Math.abs(this.validCookie[1]);
    	// total offset time is the configured session timeout (data set on cookie)
        // plus the total interval period so far plus the grace period allowed
        // Timezone difference taken into account here..
    	// Client side time is not important in this calculation..
    	var totalCurrServerTime
          = this.serverTime + this.timeForDialogToAppear + this.bufferingPeriod;
    	var totalExpirySeverTime = this.sessionExpiry - (this.timeoutPeriod * 1000);
    	// these two variables useful for debugging purposes
    	this.totalExpirySeverTime = totalExpirySeverTime;
    	this.totalCurrServerTime = totalCurrServerTime;
	    if (totalCurrServerTime >= totalExpirySeverTime && this.stopChecking!=true) {
	      this.stopChecking = true;
	      if (window.top.openModal != undefined) {
	        window.top.openModal(this.sessTimeoutWarningJSPXDialog, {width:this.width,height:this.height});
	        
	      }
	      clearInterval(this.executeChecking);
	    }  
      }
    },
      
    /**
     * Checks that the cookie that contains data about the session timeout is
     * secure and that its data has not been manipulated maliciously.
     * 
     * @param sessionExpiryCookie The cookie to check for security.
     * @returns                   the secure cookie.
     */
    _sessionExpiryCookieIsAsExpected:function(sessionExpiryCookie) {
    	// TODO: Might be better to do this validation in the request filter and
    	// just set the difference between server and expiry time i.e
    	// expiryTime - serverTime -- BOS
        var validDate = true;
        if (sessionExpiryCookie != null) {
      	// There is a contract here between the addSessionTimeoutCookie() method
      	// that sets this cookie in the 'RequestFilter' servlet and check we do
      	// here to ensure that cookie is as expected. The cookie should have 
      	// only 2 tokens delimited by a hyphen character (-) and each token
      	// must be in the date format.
          var tokens = sessionExpiryCookie.split("-", 2);
          if (tokens && tokens.length == 2) {
            for (token in tokens) {
          	  // first convert to int as it must in miliseconds from 1 Jan 1970..
          	  var millisecondsToken = Math.abs(token);
          	  if (isNaN(millisecondsToken)) {
          		validDate = false;
              }
            }
            if (validDate == true) {	
              return tokens;	  
            }
          }
        }
     },
     
     /**
      * Ammends the timeout configuration if the timeout period is incorrectly
      * configured to be greater than the session timeout period or is 
      * configured to be a negative value..
      * @param validCookie
      */
     _ammendTimeoutPeriodForMisconfiguration: function(validCookie) {
       // TODO: Even though this only happens once. It would be better to do this in
       // RequestFilter and TabLayoutResolver. However would have to do examine
       // the timeout configuration and validate that set correctly -- BOS 
       if (validCookie) {
    	  var sessionExpiry = Math.abs(this.validCookie[0]);
     	  var serverTime = Math.abs(this.validCookie[1]);  
     	  // session timeout configuration in seconds  
     	  var sessionTimeoutConfig = (sessionExpiry 
     	    - (serverTime + this.interval + this.bufferingPeriod))/1000;
     	 sessionTimeoutConfig = sessionTimeoutConfig <= 0 ? 0 : sessionTimeoutConfig;
     	  var timeoutConfig = this.getTimeoutWarningConfig();
     	  if (timeoutConfig) {
     		var timeoutPeriodConfig = timeoutConfig.timeout;
     		timeoutPeriodConfig = timeoutPeriodConfig <= 0 ? 0 : timeoutPeriodConfig;
     		if (timeoutPeriodConfig >= sessionTimeoutConfig) {
     		  this.getTimeoutWarningConfig("timeout", sessionTimeoutConfig); 
     		}
     	  } 
       }
     },
    
    /**
     * The application configuration for the timeout warning.
     * @returns The application configuration for the timeout warning.
     */
    getTimeoutWarningConfig: function(timeoutConfigKey, timeoutConfigVal) {
      if (window.top.getAppConfig) {
    	  var config = window.top.getAppConfig();
          var timeoutConfig = config.timeoutWarning;
          if (timeoutConfig && timeoutConfigKey && timeoutConfigVal) {
            timeoutConfig[timeoutConfigKey] = timeoutConfigVal;
          }
          return timeoutConfig;	  
      }
    },
    
    /**
     * Displays countdown timer to the user and logs user out.
     * 
     * @param logoutPageID         The specified logout page identifier.
     * @param timeoutPeriod        The specified timeout period to initiate the
     * countdown timer.
     * @param sessionExpiryUserMsg The expiry user message to be displayed to
     * the user when the user does not take action within the user after the
     * timer has timed out.
     * @param dismissModalBtnTxt The text for the dismiss modal button.
     */
    displayTimerAndLogout:function(logoutPageID, timeoutPeriod, sessionExpiryUserMsg, dismissModalBtnTxt, expiredTitleText, titleNodeID){
    	this.executeTimer = setInterval(function(){curam.util.SessionTimeout.timer();}, 1000);
    	this.minutes  = ~~(timeoutPeriod / 60);
    	this.seconds = timeoutPeriod % 60;
    	this.timerNode = dojo.byId(this.displayTimerNodeID);
    	this.userMessageNode = dojo.byId(this.userMessageNodeID);
    	this.logoutPageID = logoutPageID;
    	this.updatedUserMessage = sessionExpiryUserMsg;
    	this.dismissModalBtnTxt = dismissModalBtnTxt;
    	this.expiredTitleText = expiredTitleText;
    	this.titleNode = window.top.dojo.byId(titleNodeID);	
    },
    
    /**
     * Executes the timer.
     */
    timer:function(){
      if (this.stopTimer !=true) {
    	var timerMessage = "";
    	if (this.seconds < 10) {
    	  timerMessage = this.minutes+" : 0"+this.seconds; 	
        } else {
    	  timerMessage = this.minutes+" : "+this.seconds;	
    	}

		//Ensure LTR direction: LRE + text + PDF
		this.timerNode.innerHTML = "&#x202A;" + timerMessage + "&#x202C;"
        
        if (this.seconds == 0) {
          this.seconds = 59;
          this.minutes = this.minutes - 1;
        } else {
      	  this.seconds = this.seconds - 1;	
        }
        
        if(this.minutes==0 && this.seconds ==0){
          this.quitTimeoutWarningDialog();
      	  this.stopTimer();
        }
      
        if (this.seconds==0) {
          this.minutes = this.minutes - 1;
      	this.seconds = 59;
        } 
      }
    },
    
    stopTimer:function() {
      clearInterval(this.executeTimer);
    },
    
    /**
     * Quits the session from the session timeout warning dialog.
     */
    quitTimeoutWarningDialog: function(close){
      var logoutPage = {pageID:this.logoutPageID};
      window.top.displayContent(logoutPage);  
    },
    
    /**
     * Dismisses the session timeout dialog and restarts the session again.
     */
    dismissTimeoutDialog: function() {
      window.top.location = jsBaseURL + "/" + "application.do";
    },
    
    /**
     * Enables the user to continue using the application when they click the
     * localized Continue button within the modal.
     */
    continueUsingApp:function() {
    	debug.log(bundle.getProperty("continueApp"));
    	this.stopTimer();
    },
    
    /**
     * Enables the user to dismiss the timeout warning modal when a session has
     * timed out and starts checking again for when the new session times out.
     */
    dismissTimeoutWarningModal:function() {
    	debug.log(bundle.getProperty("dismissTimeoutModal"));
    },
    
    /**
     * Format the user message and displays it as paragraphs to the user.
     * 
     * @param msg             The user message to be displayed.
     * @param userMessageNode The user message node to be updated.
     */
    displayUserMsgAsParagraphs: function(msg, userMessageNode) {
      var userMessageWithParagraphs;
      if (userMessageNode) {
        userMessageWithParagraphs = userMessageNode;
      } else {
    	userMessageWithParagraphs = dojo.byId(this.userMessageNodeID);  
      }
      
      var paragaphTxt = curam.html.splitWithTag(msg, "\\n", "p");	
      userMessageWithParagraphs.innerHTML = paragaphTxt;
      this.userMessageNode = userMessageWithParagraphs;
    }});
   
  return curam.util.SessionTimeout;
  
});
},
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\"\n\t\t\tdata-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t\tdata-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>",
'curam/util/ui/refresh/TabRefreshController':function(){
/*
 * Copyright 2011-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/util/ui/refresh/TabRefreshController", ["curam/debug",
        "curam/util/ui/refresh/RefreshEvent",
        "curam/util/ResourceBundle"
        ], function() {

  /*
   * Modification History
   * --------------------
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 07-May-2013  MV  [CR00383012] Fix destroy function to properly
   *    re-initialize members. 
   * 07-Mar-2013  MV  [CR00373496] Fix member variable values handling.
   * 22-Oct-2012  SK  [CR00346419] Now destroys the configuration references
   *                  to avoid memory leak.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  dojo.requireLocalization("curam.application", "Debug");
  var bundle = new curam.util.ResourceBundle("Debug");

  /**
   * @name curam.util.ui.refresh.TabRefreshController
   * @namespace Manages refreshing of the the tab UI components.
   *
   */
  var TabRefreshController = dojo.declare("curam.util.ui.refresh.TabRefreshController", null,
  /**
   * @lends curam.util.ui.refresh.TabRefreshController.prototype
   */
  {
    /** Event name for menu refresh. */
    EVENT_REFRESH_MENU: "/curam/refresh/menu",

    /** Event name for navigation refresh. */
    EVENT_REFRESH_NAVIGATION: "/curam/refresh/navigation",

    /** Event name for context panel refresh. */
    EVENT_REFRESH_CONTEXT: "/curam/refresh/context",

    /** Event name for the main content panel refresh. */
    EVENT_REFRESH_MAIN: "/curam/refresh/main-content",

    /** ID of the related tab widget. */
    _tabWidgetId: null,

    /** The configuration for onsubmit handling. */
    _configOnSubmit: null,

    /** The configuration for onload handling. */
    _configOnLoad: null,

    /** The handler function that performs the actual refresh based on the
     * generated events. */
    _handler: null,

    /**
     * Holds the last submit event to be processed. This is needed because page
     * submits are processed only when the next page loads. It is done for two
     * reasons: a) to make sure any server updates caused by the submit are
     * reflected when the UI is refreshed and b) to avoid double refreshes
     * when they are configured on both one page submit and the next page load.
     * If this is the case the refresh list is optimized and only done once.
     */
    _lastSubmitted: null,

    /**
     * Holds the current refresh event sent to the main content panel. This is
     * used to break potential infinite recursion when we are notified of page
     * events caused by our own refresh event.
     */
    _currentlyRefreshing: null,

    /**
     * Creates an instance of the refresh controller.
     *
     * @param {String} tabWidgetId Id of the tab widget this controller
     *            belongs to.
     * @param {Object} [config] The tab refresh configuration object.
     *            The expected structure is the one output
     *            by curam.util.client.render.component.TabRenderer.
     *            Configuration is optional as some tabs have no associated
     *            refresh configuration. If not provided, the controller will not
     *            be active, i.e. will not send out any refresh events ever.
     */
    constructor: function(tabWidgetId, config) {
      this._configOnSubmit = {};
      this._configOnLoad = {};

      if (!config) {
        // is null controller
        return;
      }

      this._tabWidgetId = tabWidgetId;

      // Expand the configuration data structure so that it is easily
      // used in the controller.
      dojo.forEach(config.config, dojo.hitch(this, function(item) {
        this._configOnSubmit[item.page] = item.onsubmit;
        this._configOnLoad[item.page] = item.onload;
      }));
    },

    /**
     * Notifies the controller of a page submit in the specified context.
     *
     * @param pageId ID of the page that has been submitted.
     * @param context Context in which the page has been submitted. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageSubmitted: function(pageId, context) {
      // create event object - validates the parameters
      new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONSUBMIT, context);
      curam.debug.log("curam.util.ui.refresh.TabRefreshController: " +
          bundle.getProperty("curam.util.ui.refresh.TabRefreshController.submit",
                             [pageId, context]));
      if (this._configOnSubmit[pageId]) {
        // if we are interested in this submit, record the event
        // it will be processed when a next page loads
        this._lastSubmitted = pageId;
        curam.debug.log("curam.util.ui.refresh.TabRefreshController: "
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "submit.notify"));
      }
    },

    /**
     * Notifies the controller of a page load in the specified context.
     *
     * @param pageId ID of the page that has been loaded.
     * @param context Context in which the page has been loaded. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageLoaded: function(pageId, context) {
      // create event object - also validates the parameters
      var event = new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD, context);

      curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
        + bundle.getProperty("curam.util.ui.refresh.TabRefreshController.load",
          [pageId, context]));

      // do not react to onload event if it was caused by our refresh event
      // this avoids possible infinite recursion
      if (this._currentlyRefreshing && this._currentlyRefreshing.equals(event)) {
        this._currentlyRefreshing = null;
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "refresh"));
        return;
      }

      // if a refresh is configured for both previous page submit and next page
      // load we merge the configurations and only refresh once
      var mergedRefreshConfig = {};

      // only support onload event for the main content panel
      if(context == event.SOURCE_CONTEXT_MAIN && this._configOnLoad[pageId]) {
        mergedRefreshConfig = this._configOnLoad[pageId];
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
            + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".load.config"));
      }
      // else ->
      // load in other contexts will be only used to dispatch
      // any previous onsubmit event
      if (this._lastSubmitted) {
        // merge the configs if we have both onsubmit and onload
        var cfg = this._configOnSubmit[this._lastSubmitted];
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
            + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".submit.config", [this._lastSubmitted]));

        mergedRefreshConfig.details = mergedRefreshConfig.details || cfg.details;
        mergedRefreshConfig.menubar = mergedRefreshConfig.menubar || cfg.menubar;
        mergedRefreshConfig.navigation =
            mergedRefreshConfig.navigation || cfg.navigation;
        mergedRefreshConfig.mainContent =
            mergedRefreshConfig.mainContent || cfg.mainContent;

        this._lastSubmitted = null;
      }

      this._fireRefreshEvents(mergedRefreshConfig);
    },

    /**
     * Invokes the refresh handler with events based on the received
     * page load/submit events and refresh configuration.
     *
     * @private
     *
     * @param cfg The relevant configuration fragment.
     */
    _fireRefreshEvents: function(cfg) {
      var events = [];
      if (cfg.details) {
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.context"));
        events.push(this.EVENT_REFRESH_CONTEXT + "/" + this._tabWidgetId);
      }
      if (cfg.menubar) {
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.menu"));
        events.push(this.EVENT_REFRESH_MENU + "/" + this._tabWidgetId);
      }
      if (cfg.navigation) {
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.nav"));
        events.push(this.EVENT_REFRESH_NAVIGATION + "/" + this._tabWidgetId);
      }
      if (cfg.mainContent) {
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
          + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.main"));
        // store the refresh event for later use in the infinite recursion
        // breaking code above
        this._currentlyRefreshing = new curam.util.ui.refresh.RefreshEvent(
            curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD,
            curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN,
            null);
        events.push(this.EVENT_REFRESH_MAIN + "/" + this._tabWidgetId);
      }
      if (events.length > 0) {
        curam.debug.log("curam.util.ui.refresh.TabRefreshController:"
            + bundle.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".refresh.log", [events.length, events]));
        this._handler(events);
      }
    },

    /**
     * Specifies the refresh handler function to be invoked when some tab UI
     * parts should be refreshed.
     *
     * @param {Function} handler A function to be invoked in response to tab UI
     *    refresh events. The function will be passed one parameter
     *    which is an array of refresh event names. The format of the refresh
     *    event names is the following: event_name/tab_widget_id, where
     *    the supported event_names are defined as constants in this class
     *    and tab_widget_id is ID of the tab the events are related to. Please
     *    note that all the events in the array will always refer to the same tab.
     */
    setRefreshHandler: function(handler) {
      this._handler = handler;
    },

    /**
     * Releases any resources related to this controller instance.
     * It is the responsibility of this class' clients to call this function when
     * the tab that owns the controller instance is closed.
     */
    destroy: function() {
      for (prop in this._configOnSubmit) {
        if (this._configOnSubmit.hasOwnProperty(prop)) {
        delete this._configOnSubmit[prop];
      }
      }
      for (prop in this._configOnLoad) {
        if (this._configOnLoad.hasOwnProperty(prop)) {
        delete this._configOnLoad[prop];
      }
      }
      this._configOnSubmit = {};
      this._configOnLoad = {};
      this._handler = null;
      this._lastSubmitted = null;
      this._currentlyRefreshing = null;
    }
  });

  return TabRefreshController;
});

},
'dojo/_base/url':function(){
define("dojo/_base/url", ["./kernel"], function(dojo) {
	// module:
	//		dojo/url
	// summary:
	//		This module contains dojo._Url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'idx/oneui/MenuHeading':function(){
require({cache:{
'url:idx/oneui/templates/MenuHeading.html':"<tr class=\"dijitReset dijitMenuItem oneuiMenuHeading\" role=\"presentation\" tabindex=\"-1\">\r\n\t<td class=\"dijitReset dijitMenuItemLabel oneuiMenuHeadingLabel\" colspan=\"4\" data-dojo-attach-point=\"containerNode\"></td>\r\n</tr>"}});
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define("idx/oneui/MenuHeading", ["dojo/_base/declare", 
		"dijit/MenuSeparator",
		"dojo/text!../oneui/templates/MenuHeading.html"],
		function(declare,
				 MenuSeparator,
				 template){
	/**
	 * Creates a new idx.oneui.MenuHeading
	 * @name idx.oneui.MenuHeading
	 * @class The MenuHeading widget provides a non-selectable, full-width menu entry
	 * suitable for labelling groups of menu items.
	 * @augments dijit.MenuSeparator
	 * @example &lt;div data-dojo-type="idx.oneui.Menu"&gt;
  &lt;div data-dojo-type="idx.oneui.MenuHeading"
       data-dojo-props="column:'0',<span class="highlitCode">label:'Column #0'</span>"&gt;
  &lt;/div&gt;
    ...
&lt;/div&gt;
	 */
	return declare("idx.oneui.MenuHeading", [MenuSeparator], 
	/** @lends idx.oneui.MenuHeading.prototype */
	{
		/**
		 * The text and markup to display in the item.
		 * @type string
		 */		
		label: '',
		
		/**
		 * Standard Dojo setter config for handling the 'label' property via calls to 
		 * set().
		 * @constant
		 * @type Object
		 */
		_setLabelAttr: { node: "containerNode", type: "innerHTML" },

		/**
	 	 * The template HTML for the widget.
		 * @constant
		 * @type string
		 * @private
		 * @default Loaded from idx/oneui/templates/MenuHeading.html.
		 */
		templateString: template

	});
});

},
'dojox/collections/_base':function(){
define("dojox/collections/_base", ["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array"], 
  function(dojo, lang, arr){
	var collections = lang.getObject("dojox.collections", true);

/*=====
	collections = dojox.collections;
=====*/

	collections.DictionaryEntry=function(/* string */k, /* object */v){
		//	summary
		//	return an object of type dojox.collections.DictionaryEntry
		this.key=k;
		this.value=v;
		this.valueOf=function(){
			return this.value; 	//	object
		};
		this.toString=function(){
			return String(this.value);	//	string
		};
	}

	/*	Iterators
	 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
	 *	work with the Collections included in this module.  However, they *can*
	 *	be used with arrays and objects, respectively, should one choose to do so.
	 */
	collections.Iterator=function(/* array */a){
		//	summary
		//	return an object of type dojox.collections.Iterator
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			//	summary
			//	Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			//	summary
			//	Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/* function */fn, /* object? */scope){
			//	summary
			//	Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function(){
			//	summary
			//	reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	}

	/*	Notes:
	 *	The DictionaryIterator no longer supports a key and value property;
	 *	the reality is that you can use this to iterate over a JS object
	 *	being used as a hashtable.
	 */
	collections.DictionaryIterator=function(/* object */obj){
		//	summary
		//	return an object of type dojox.collections.DictionaryIterator
		var a=[];	//	Create an indexing array
		var testObject={};
		for(var p in obj){
			if(!testObject[p]){
				a.push(obj[p]);	//	fill it up
			}
		}
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			//	summary
			//	Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			//	summary
			//	Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/* function */fn, /* object? */scope){
			//	summary
			//	Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function() {
			//	summary
			//	reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	};

	return collections;
});

},
'url:idx/oneui/templates/HoverCard.html':"<div class=\"idxOneuiHoverCard idxOneuiHoverCardLeft\">\r\n\t<div role=\"document\"> <span data-dojo-attach-point=\"closeButtonNode, focusNode\" class=\"idxOneuiHoverCardCloseIcon\" data-dojo-attach-event=\"ondijitclick: hide\" role=\"button\" tabIndex=\"0\"></span></div>\r\n\t\r\n\t<div data-dojo-attach-point=\"bodyNode\" class=\"idxOneuiHoverCardBody\">\t\r\n\t\t<div class=\"idxOneuiHoverCardGrip\" data-dojo-attach-point=\"gripNode\"></div>\r\n\t\t<div class=\"idxOneuiHoverCardContainer\" role='alert' data-dojo-attach-point=\"containerNode\">\t\t\r\n\t\t</div>\r\n\t\t<div class=\"idxOneuiHoverCardFooter\">\r\n\t\t\t<div class=\"idxOneuiHoverCardActionIcons\" data-dojo-attach-point=\"actionIcons\"></div>\r\n\t\t\t<span aria-haspopup=\"true\" data-dojo-attach-point=\"moreActionsNode\"></span>\r\n\t\t</div>\r\n\t\t<div class=\"idxOneuiHoverCardFooterExpand\"></div>\r\n\t</div>\r\n\t<div class=\"idxOneuiHoverCardConnector\" data-dojo-attach-point=\"connectorNode\"></div>\r\n</div>\r\n\r\n\r\n",
'dijit/form/Button':function(){
require({cache:{
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\ttabIndex=\"-1\" role=\"presentation\" data-dojo-attach-point=\"valueNode\"\n/></span>\n"}});
define("dijit/form/Button", [
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html"
], function(require, declare, domClass, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

/*=====
	var _FormWidget = dijit.form._FormWidget;
	var _ButtonMixin = dijit.form._ButtonMixin;
=====*/

// module:
//		dijit/form/Button
// summary:
//		Button widget

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.form.Button", [_FormWidget, _ButtonMixin], {
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button data-dojo-type="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "dijitNoIcon",
	_setIconClassAttr: { node: "iconNode", type: "class" },

	baseClass: "dijitButton",

	templateString: template,

	// Map widget attributes to DOMNode attributes.
	_setValueAttr: "valueNode",

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		var ok = this.inherited(arguments);
		if(ok){
			if(this.valueNode){
				this.valueNode.click();
				e.preventDefault(); // cancel BUTTON click and continue with hidden INPUT click
				// leave ok = true so that subclasses can do what they need to do
			}
		}
		return ok;
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		// TODO: remove the method in 2.0, parser will do it all for me
		if(source && (!this.params || !("label" in this.params))){
			var sourceLabel = lang.trim(source.innerHTML);
			if(sourceLabel){
				this.label = sourceLabel; // _applyAttributes will be called after buildRendering completes to update the DOM
			}
		}
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
		}
		this._set("showLabel", val);
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use set('label', ...) instead.
		kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
		this.set("label", content);
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		//		If the label is hidden (showLabel=false) then and no title has
		//		been specified, then label is also set as title attribute of icon.
		this.inherited(arguments);
		if(!this.showLabel && !("title" in this.params)){
			this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}
});


});


},
'dijit/CalendarLite':function(){
require({cache:{
'url:dijit/templates/Calendar.html':"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" aria-labelledby=\"${id}_mddb ${id}_year\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\n\t\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\">\n\t\t\t\t<div data-dojo-attach-point=\"monthNode\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\n\t\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t${!dayCellsHtml}\n\t\t</tr>\n\t</thead>\n\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"onclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t\t${!dateRowsHtml}\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\" role=\"presentation\">\n\t\t\t\t<div class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n"}});
define("dijit/CalendarLite", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/cldr/supplemental", // cldrSupplemental.getFirstDayOfWeek
	"dojo/date", // date
	"dojo/date/locale",
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.contains
	"dojo/_base/event", // event.stop
	"dojo/_base/lang", // lang.getObject, lang.hitch
	"dojo/_base/sniff", // has("ie") has("webkit")
	"dojo/string", // string.substitute
	"dojo/_base/window", // win.doc.createTextNode
	"./_WidgetBase",
	"./_TemplatedMixin",
	"dojo/text!./templates/Calendar.html"
], function(array, declare, cldrSupplemental, date, local, dom, domClass, event, lang, has, string, win,
			_WidgetBase, _TemplatedMixin, template){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/CalendarLite
	// summary:
	//		Lightweight version of Calendar widget aimed towards mobile use

	var CalendarLite = declare("dijit.CalendarLite", [_WidgetBase, _TemplatedMixin], {
		// summary:
		//		Lightweight version of Calendar widget aimed towards mobile use
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit.form.DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		//		Also note that this widget isn't keyboard accessible; use dijit.Calendar for that
		// example:
		//	|	var calendar = new dijit.CalendarLite({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div data-dojo-type="dijit.CalendarLite"></div>

		// Template for main calendar
		templateString: template,

		// Template for cell for a day of the week (ex: M)
		dowTemplateString: '<th class="dijitReset dijitCalendarDayLabelTemplate" role="columnheader"><span class="dijitCalendarDayLabel">${d}</span></th>',

		// Templates for a single date (ex: 13), and for a row for a week (ex: 20 21 22 23 24 25 26)
		dateTemplateString: '<td class="dijitReset" role="gridcell" data-dojo-attach-point="dateCells"><span class="dijitCalendarDateLabel" data-dojo-attach-point="dateLabels"></span></td>',
		weekTemplateString: '<tr class="dijitReset dijitCalendarWeekTemplate" role="row">${d}${d}${d}${d}${d}${d}${d}</tr>',

		// value: Date
		//		The currently selected Date, initially set to invalid date to indicate no selection.
		value: new Date(""),
		// TODO: for 2.0 make this a string (ISO format) rather than a Date

		// datePackage: String
		//		JavaScript object containing Calendar functions.  Uses Gregorian Calendar routines
		//		from dojo.date by default.
		datePackage: date,

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See locale
		dayWidth: "narrow",

		// tabIndex: Integer
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",

		// currentFocus: Date
		//		Date object containing the currently focused date, or the date which would be focused
		//		if the calendar itself was focused.   Also indicates which year and month to display,
		//		i.e. the current "page" the calendar is on.
		currentFocus: new Date(),

		baseClass:"dijitCalendar",

		_isValidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking that it's a valid date, rather
			//		than blank or NaN.
			// tags:
			//		private
			return value && !isNaN(value) && typeof value == "object" &&
				value.toString() != this.constructor.prototype.value.toString();
		},

		_getValueAttr: function(){
			// summary:
			//		Support get('value')

			// this.value is set to 1AM, but return midnight, local time for back-compat
			if(this.value && !isNaN(this.value)){
				var value = new this.dateClassObj(this.value);
				value.setHours(0, 0, 0, 0);

				// If daylight savings pushes midnight to the previous date, fix the Date
				// object to point at 1am so it will represent the correct day. See #9366
				if(value.getDate() < this.value.getDate()){
					value = this.dateFuncObj.add(value, "hour", 1);
				}
				return value;
			}else{
				return null;
			}
		},

		_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
			// summary:
			//		Support set("value", ...)
			// description:
			// 		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// value:
			//		Either a Date or the number of seconds since 1970.
			// tags:
			//      protected
			if(value){
				// convert from Number to Date, or make copy of Date object so that setHours() call below
				// doesn't affect original value
				value = new this.dateClassObj(value);
			}
			if(this._isValidDate(value)){
				if(!this._isValidDate(this.value) || this.dateFuncObj.compare(value, this.value)){
					value.setHours(1, 0, 0, 0); // round to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)

					if(!this.isDisabledDate(value, this.lang)){
						this._set("value", value);

						// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
						// focus point.   This will also repopulate the grid, showing the new selected value (and possibly
						// new month/year).
						this.set("currentFocus", value);

						if(priorityChange || typeof priorityChange == "undefined"){
							this.onChange(this.get('value'));
						}
					}
				}
			}else{
				// clear value, and repopulate grid (to deselect the previously selected day) without changing currentFocus
				this._set("value", null);
				this.set("currentFocus", this.currentFocus);
			}
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//      private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(win.doc.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//      Fills in the calendar grid with each day (1-31)
			// tags:
			//      private

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);

			var firstDay = month.getDay(),
				daysInMonth = this.dateFuncObj.getDaysInMonth(month),
				daysInPreviousMonth = this.dateFuncObj.getDaysInMonth(this.dateFuncObj.add(month, "month", -1)),
				today = new this.dateClassObj(),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){ dayOffset -= 7; }

			// Mapping from date (as specified by number returned from Date.valueOf()) to corresponding <td>
			this._date2cell = {};

			// Iterate through dates in the calendar and fill in date numbers and style info
			array.forEach(this.dateCells, function(template, idx){
				var i = idx + dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateFuncObj.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateFuncObj.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this._isSelectedDate(date, this.lang)){
					clazz = "dijitCalendarSelectedDate " + clazz;
					template.setAttribute("aria-selected", true);
				}else{
					template.setAttribute("aria-selected", false);
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
					template.setAttribute("aria-disabled", true);
				}else{
					clazz = "dijitCalendarEnabledDate " + clazz;
					template.removeAttribute("aria-disabled");
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";

				// Each cell has an associated integer value representing it's date
				var dateVal = date.valueOf();
				this._date2cell[dateVal] = template;
				template.dijitDateValue = dateVal;

				// Set Date string (ex: "13").
				this._setText(this.dateLabels[idx], date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate());
			}, this);

			// set name of this month
			this.monthWidget.set("month", month);

			// Fill in localized prev/current/next years
			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			array.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name+"YearLabelNode"],
					this.dateLocaleModule.format(d, {selector:'year', locale:this.lang}));
			}, this);
		},

		goToToday: function(){
			// summary:
			//      Sets calendar's value to today's date
			this.set('value', new this.dateClassObj());
		},

		constructor: function(/*Object*/args){
			this.datePackage = args.datePackage || this.datePackage;
			this.dateFuncObj = typeof this.datePackage == "string" ?
				lang.getObject(this.datePackage, false) :// "string" part for back-compat, remove for 2.0
				this.datePackage;
			this.dateClassObj = this.dateFuncObj.Date || Date;
			this.dateLocaleModule = lang.getObject("locale", false, this.dateFuncObj);
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return CalendarLite._MonthWidget({
				id: this.id + "_mw",
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		buildRendering: function(){
			// Markup for days of the week (referenced from template)
			var d = this.dowTemplateString,
				dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			this.dayCellsHtml = string.substitute([d,d,d,d,d,d,d].join(""), {d: ""}, function(){
				return dayNames[dayOffset++ % 7]
			});

			// Markup for dates of the month (referenced from template), but without numbers filled in
			var r = string.substitute(this.weekTemplateString, {d: this.dateTemplateString});
			this.dateRowsHtml = [r,r,r,r,r,r].join("");

			// Instantiate from template.
			// dateCells and dateLabels arrays filled when _Templated parses my template.
			this.dateCells = [];
			this.dateLabels = [];
			this.inherited(arguments);

			dom.setSelectable(this.domNode, false);

			var dateObj = new this.dateClassObj(this.currentFocus);

			this._supportingWidgets.push(this.monthWidget = this._createMonthWidget());

			this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus

			// Set up connects for increment/decrement of months/years
			var connect = lang.hitch(this, function(nodeProp, part, amount){
				this.connect(this[nodeProp], "onclick", function(){
					this._setCurrentFocusAttr(this.dateFuncObj.add(this.currentFocus, part, amount));
				});
			});
			connect("incrementMonth", "month", 1);
			connect("decrementMonth", "month", -1);
			connect("nextYearLabelNode", "year", 1);
			connect("previousYearLabelNode", "year", -1);
		},

		_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
			// summary:
			//		If the calendar currently has focus, then focuses specified date,
			//		changing the currently displayed month/year if necessary.
			//		If the calendar doesn't have focus, updates currently
			//		displayed month/year, and sets the cell that will get focus.
			// forceFocus:
			//		If true, will focus() the cell even if calendar itself doesn't have focus

			var oldFocus = this.currentFocus,
				oldCell = oldFocus && this._date2cell ? this._date2cell[oldFocus.valueOf()] : null;

			// round specified value to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
			date = new this.dateClassObj(date);
			date.setHours(1, 0, 0, 0);

			this._set("currentFocus", date);

			// TODO: only re-populate grid when month/year has changed
			this._populateGrid();

			// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
			var newCell = this._date2cell[date.valueOf()];
			newCell.setAttribute("tabIndex", this.tabIndex);
			if(this.focused || forceFocus){
				newCell.focus();
			}

			// set tabIndex=-1 on old focusable cell
			if(oldCell && oldCell != newCell){
				if(has("webkit")){	// see #11064 about webkit bug
					oldCell.setAttribute("tabIndex", "-1");
				}else{
					oldCell.removeAttribute("tabIndex");
				}
			}
		},

		focus: function(){
			// summary:
			//		Focus the calendar by focusing one of the calendar cells
			this._setCurrentFocusAttr(this.currentFocus, true);
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for day clicks, selects the date if appropriate
			// tags:
			//      protected
			event.stop(evt);
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode);
			if(node && !domClass.contains(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
		},

		onChange: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Called only when the selected date has changed
		},

		_isSelectedDate: function(dateObject /*===== , locale =====*/){
			// summary:
			//		Extension point so developers can subclass Calendar to
			//		support multiple (concurrently) selected dates
			// dateObject: Date
			// locale: String?
			// tags:
			//		protected extension
			return this._isValidDate(this.value) && !this.dateFuncObj.compare(dateObject, this.value, "date")
		},

		isDisabledDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// dateObject: Date
			// locale: String?
			// tags:
			//      extension
/*=====
			return false; // Boolean
=====*/
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	});

	CalendarLite._MonthWidget = declare("dijit.CalendarLite._MonthWidget", _WidgetBase, {
		// summary:
		//		Displays name of current month padded to the width of the month
		//		w/the longest name, so that changing months doesn't change width.
		//
		//		Create as new dijit.Calendar._MonthWidget({
		//			lang: ...,
		//			dateLocaleModule: ...
		//		})

		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month),
				spacer =
					(has("ie") == 6 ? "" :	"<div class='dijitSpacer'>" +
						array.map(monthNames, function(s){ return "<div>" + s + "</div>"; }).join("") + "</div>");

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.domNode.innerHTML =
				spacer +
				"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +
				monthNames[month.getMonth()] + "</div>";
		}
	});

	return CalendarLite;
});

},
'dojo/parser':function(){
define(
	"dojo/parser", ["./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./_base/html", "./_base/window", "./_base/url",
	 	"./_base/json", "./aspect", "./date/stamp", "./has", "./query", "./on", "./ready"],
	function(dojo, dlang, darray, config, dhtml, dwindow, _Url, djson, aspect, dates, has, query, don, ready){

// module:
//		dojo/parser
// summary:
//		The Dom/Widget parsing package

new Date("X"); // workaround for #11279, new Date("") == NaN

if (1) {
	var form = document.createElement("form");
	// Test if DOMNode.attributes only lists the attributes the user specified, not attributes w/default values.
	has.add("dom-attributes-explicit", form.attributes.length == 0);

	// IE8 will erroneously list a few attributes that weren't specified,
	// but we know to skip them because they have a specified flag which is false
	has.add("dom-attributes-specified-flag", form.attributes.length < 40);

	// Otherwise, it's IE6-7 form.attributes will list hundreds of values, need to do outerHTML instead.
}

dojo.parser = new function(){
	// summary:
	//		The Dom/Widget parsing package

	var _nameMap = {
		// Map from widget name (ex: "dijit.form.Button") to structure mapping
		// lowercase version of attribute names to the version in the widget ex:
		//	{
		//		label: "label",
		//		onclick: "onClick"
		//	}
	};
	function getNameMap(proto){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = {};
		for(var name in proto){
			if(name.charAt(0)=="_"){ continue; }	// skip internal properties
			map[name.toLowerCase()] = name;
		}
		return map;
	}
	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	aspect.after(dlang, "extend", function(){
		_nameMap = {};
	}, true);

	// Map from widget name (ex: "dijit.form.Button") to a map of { "list-of-mixins": ctor }
	// if "list-of-mixins" is "__type" this is the raw type without mixins
	var _ctorMap = {};


	function getCtor(type){
		var map = _ctorMap[type] || (_ctorMap[type] = {});
		return map["__type"] || (map["__type"] = (dlang.getObject(type) || require(type)));
	}

	this._functionFromScript = function(script, attrData){
		// summary:
		//		Convert a <script type="dojo/method" args="a, b, c"> ... </script>
		//		into a function
		// script: DOMNode
		//		The <script> DOMNode
		// attrData: String
		//		For HTML5 compliance, searches for attrData + "args" (typically
		//		"data-dojo-args") instead of "args"
		var preamble = "";
		var suffix = "";
		var argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args"));
		if(argsStr){
			darray.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			darray.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	};

	this.instantiate = /*====== dojo.parser.instantiate= ======*/ function(nodes, mixin, options) {
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of DOM nodes
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// options: Object?
		//		An object used to hold kwArgs for instantiation.
		//		See parse.options argument for details.

		mixin = mixin || {};
		options = options || {};

		var dojoType = (options.scope || dojo._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (options.scope || dojo._scopeName) + "-",// typically "data-dojo-"
			dataDojoType = attrData + "type";						// typically "data-dojo-type"

		var list = [];
		darray.forEach(nodes, function(node){
			var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
			if(type){
				list.push({
					node: node,
					"type": type
				});
			}
		});

		// Instantiate the nodes and return the objects
		return this._instantiate(list, mixin, options);
	};

	this._instantiate = /*====== dojo.parser.instantiate= ======*/ function(nodes, mixin, options){
		// summary:
		//		Takes array of objects representing nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of objects like
		//	|		{
		//	|			type: "dijit.form.Button",
		//	|			node: DOMNode,
		//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
		//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
		//	|		}
		// mixin: Object
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// options: Object
		//		An options object used to hold kwArgs for instantiation.
		//		See parse.options argument for details.

		var thelist = [];

		// Precompute names of special attributes we are looking for
		// TODO: for 2.0 default to data-dojo- regardless of scopeName (or maybe scopeName won't exist in 2.0)
		var dojoType = (options.scope || dojo._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (options.scope || dojo._scopeName) + "-",// typically "data-dojo-"
			dataDojoType = attrData + "type",						// typically "data-dojo-type"
			dataDojoProps = attrData + "props",						// typically "data-dojo-props"
			dataDojoAttachPoint = attrData + "attach-point",
			dataDojoAttachEvent = attrData + "attach-event",
			dataDojoId = attrData + "id",
			dataDojoMixins = attrData + "mixins";

		// And make hash to quickly check if a given attribute is special, and to map the name to something friendly
		var specialAttrs = {};
		darray.forEach([dataDojoProps, dataDojoType, dojoType, dataDojoId, "jsId", dataDojoAttachPoint,
				dataDojoAttachEvent, "dojoAttachPoint", "dojoAttachEvent", "class", "style", dataDojoMixins], function(name){
			specialAttrs[name.toLowerCase()] = name.replace(options.scope, "dojo");
		});

		function extend(type, mixins){
			return type.createSubclass && type.createSubclass(mixins) || type.extend.apply(type, mixins);
		}

		darray.forEach(nodes, function(obj){
			if(!obj){ return; }

			var node = obj.node,
				type = obj.type,
				mixins = node.getAttribute(dataDojoMixins), ctor;

			if(mixins){
				var map = _ctorMap[type];
				// remove whitespaces
				mixins = mixins.replace(/ /g, "");
				ctor = map && map[mixins];
				if(!ctor){
					// first get ctor for raw type (& create _ctorMap[type] if needed (should not be))
					ctor = getCtor(type);
					// then do the mixin
					ctor = _ctorMap[type][mixins] = extend(ctor, darray.map(mixins.split(","), getCtor));
				}
			}else{
				ctor = getCtor(type);
			}

			var proto = ctor && ctor.prototype;

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(obj.inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, obj.inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){ return a.specified;});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
								node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i=0, item;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				if(lcName in specialAttrs){
					switch(specialAttrs[lcName]){

					// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
					case "data-dojo-props":
						var extra = value;
						break;

					// data-dojo-id or jsId. TODO: drop jsId in 2.0
					case "data-dojo-id":
					case "jsId":
						var jsname = value;
						break;

					// For the benefit of _Templated
					case "data-dojo-attach-point":
					case "dojoAttachPoint":
						params.dojoAttachPoint = value;
						break;
					case "data-dojo-attach-event":
					case "dojoAttachEvent":
						params.dojoAttachEvent = value;
						break;

					// Special parameter handling needed for IE
					case "class":
						params["class"] = node.className;
						break;
					case "style":
						params["style"] = node.style && node.style.cssText;
						break;
					}
				}else{
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = (_nameMap[type] || (_nameMap[type] = getNameMap(proto)));
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof dojo._Url) ? (dojo.baseUrl + value) :
								djson.fromJson(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = djson.fromJson.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			var scripts = obj.scripts || (ctor && (ctor._noScript || proto._noScript) ? [] :
						query("> script[type^='dojo/']", node));

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var connects = [],	// functions to connect after instantiation
				calls = [],		// functions to call after instantiation
				watch = [],  //functions to watch after instantiation
				on = []; //functions to on after instantiation

			if(scripts){
				for(i=0; i<scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							connects.push({event: event, func: nf});
						}else if(scriptType == "dojo/on"){
							on.push({event: event, func: nf});
						}else{
							params[event] = nf;
						}
					}else if(scriptType == "dojo/watch"){
						watch.push({prop: prop, func: nf});
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			if(jsname){
				dlang.setObject(jsname, instance);
			}

			// process connections and startup functions
			for(i=0; i<connects.length; i++){
				aspect.after(instance, connects[i].event, dojo.hitch(instance, connects[i].func), true);
			}
			for(i=0; i<calls.length; i++){
				calls[i].call(instance);
			}
			for(i=0; i<watch.length; i++){
				instance.watch(watch[i].prop, watch[i].func);
			}
			for(i=0; i<on.length; i++){
				don(instance, on[i].event, on[i].func);
			}
		}, this);

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			darray.forEach(thelist, function(instance){
				if( !options.noStart && instance  &&
					dlang.isFunction(instance.startup) &&
					!instance._started
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.scan = /*====== dojo.parser.scan= ======*/ function(root, options){
		// summary:
		//		Scan a DOM tree and return an array of objects representing the DOMNodes
		//		that need to be turned into widgets.
		// description:
		//		Search specified node (or document root node) recursively for class instances
		//		and return an array of objects that represent potential widgets to be
		//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
		//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
		//		like "dijit.form.Button".
		//
		//		See parser.parse() for details of markup.
		// root: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `options`
		//		object can be passed in this place. If the `options` object has a
		//		`rootNode` member, that is used.
		// options: Object
		//		a kwArgs options object, see parse() for details

		// Output list
		var list = [];

		var dojoType = (options.scope || dojo._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (options.scope || dojo._scopeName) + "-",	// typically "data-dojo-"
			dataDojoType = attrData + "type",						// typically "data-dojo-type"
			dataDojoTextDir = attrData + "textdir";					// typically "data-dojo-textdir"

		// Info on DOMNode currently being processed
		var node = root.firstChild;

		// Info on parent of DOMNode currently being processed
		//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
		//	- parent: pointer to identical structure for my parent (or null if no parent)
		//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
		var inherited = options.inherited;
		if(!inherited){
			function findAncestorAttr(node, attr){
				return (node.getAttribute && node.getAttribute(attr)) ||
					(node !== dwindow.doc && node !== dwindow.doc.documentElement && node.parentNode ? findAncestorAttr(node.parentNode, attr) : null);
			}
			inherited = {
				dir: findAncestorAttr(root, "dir"),
				lang: findAncestorAttr(root, "lang"),
				textDir: findAncestorAttr(root, dataDojoTextDir)
			};
			for(var key in inherited){
				if(!inherited[key]){ delete inherited[key]; }
			}
		}
		var parent = {
			inherited: inherited
		};

		// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
		var scripts;

		// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
		var scriptsOnly;

		function getEffective(parent){
			// summary:
			//		Get effective dir, lang, textDir settings for specified obj
			//		(matching "parent" object structure above), and do caching.
			//		Take care not to return null entries.
			if(!parent.inherited){
				parent.inherited = {};
				var node = parent.node,
					grandparent = getEffective(parent.parent);
				var inherited  = {
					dir: node.getAttribute("dir") || grandparent.dir,
					lang: node.getAttribute("lang") || grandparent.lang,
					textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
				};
				for(var key in inherited){
					if(inherited[key]){
						parent.inherited[key] = inherited[key];
					}
				}
			}
			return parent.inherited;
		}

		// DFS on DOM tree, collecting nodes with data-dojo-type specified.
		while(true){
			if(!node){
				// Finished this level, continue to parent's next sibling
				if(!parent || !parent.node){
					break;
				}
				node = parent.node.nextSibling;
				scripts = parent.scripts;
				scriptsOnly = false;
				parent = parent.parent;
				continue;
			}

			if(node.nodeType != 1){
				// Text or comment node, skip to next sibling
				node = node.nextSibling;
				continue;
			}

			if(scripts && node.nodeName.toLowerCase() == "script"){
				// Save <script type="dojo/..."> for parent, then continue to next sibling
				type = node.getAttribute("type");
				if(type && /^dojo\/\w/i.test(type)){
					scripts.push(node);
				}
				node = node.nextSibling;
				continue;
			}
			if(scriptsOnly){
				node = node.nextSibling;
				continue;
			}

			// Check for data-dojo-type attribute, fallback to backward compatible dojoType
			var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

			// Short circuit for leaf nodes containing nothing [but text]
			var firstChild = node.firstChild;
			if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
				node = node.nextSibling;
				continue;
			}

			// Setup data structure to save info on current node for when we return from processing descendant nodes
			var current = {
				node: node,
				scripts: scripts,
				parent: parent
			};

			// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate
			// Note: won't find classes declared via dojo.Declaration, so use try/catch to avoid throw from require()
			// We don't care yet about mixins ctors, we check script stop only on main class
			var ctor;
			try{
				ctor = type && getCtor(type);
			}catch(e){
			}
			var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children
			if(type){
				list.push({
					"type": type,
					node: node,
					scripts: childScripts,
					inherited: getEffective(current) // dir & lang settings for current node, explicit or inherited
				});
			}

			// Recurse, collecting <script type="dojo/..."> children, and also looking for
			// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
			// When finished with children, go to my next sibling.
			node = firstChild;
			scripts = childScripts;
			scriptsOnly = ctor && ctor.prototype.stopParser && !(options.template);
			parent = current;
		}

		return list;
	};

	this.parse = /*====== dojo.parser.parse= ======*/ function(rootNode, options){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them. Searches for either data-dojo-type="Class" or
		//		dojoType="Class" where "Class" is a a fully qualified class name,
		//		like `dijit.form.Button`
		//
		//		Using `data-dojo-type`:
		//		Attributes using can be mixed into the parameters used to instantiate the
		//		Class by using a `data-dojo-props` attribute on the node being converted.
		//		`data-dojo-props` should be a string attribute to be converted from JSON.
		//
		//		Using `dojoType`:
		//		Attributes are read from the original domNode and converted to appropriate
		//		types by looking up the Class prototype values. This is the default behavior
		//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
		//		go away in Dojo 2.0.
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `options`
		//		object can be passed in this place. If the `options` object has a
		//		`rootNode` member, that is used.
		//
		// options: Object?
		//		A hash of options.
		//
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes.
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `options object.
		//			* template: Boolean
		//				If true, ignores ContentPane's stopParser flag and parses contents inside of
		//				a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
		//				nested inside the ContentPane to work.
		//			* inherited: Object
		//				Hash possibly containing dir and lang settings to be applied to
		//				parsed widgets, unless there's another setting on a sub-node that overrides
		//			* scope: String
		//				Root for attribute names to search for.   If scopeName is dojo,
		//				will search for data-dojo-type (or dojoType).   For backwards compatibility
		//				reasons defaults to dojo._scopeName (which is "dojo" except when
		//				multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		//			* propsThis: Object
		//				If specified, "this" referenced from data-dojo-props will refer to propsThis.
		//				Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId('foo'));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		//	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node and options based on the passed arguments.
		var root;
		if(!options && rootNode && rootNode.rootNode){
			options = rootNode;
			root = options.rootNode;
		}else if(rootNode && dlang.isObject(rootNode) && !("nodeType" in rootNode)){
			options = rootNode;
		}else{
			root = rootNode;
		}
		root = root ? dhtml.byId(root) : dwindow.body();

		options = options || {};

		// List of all nodes on page w/dojoType specified
		var list = this.scan(root, options);

		// go build the object instances
		var mixin = options.template ? {template: true} : {};
		return this._instantiate(list, mixin, options); // Array
	};
}();


//Register the parser callback. It should be the first callback
//after the a11y test.
if(config.parseOnLoad){
	ready(100, dojo.parser, "parse");
}

return dojo.parser;
});

},
'url:dijit/templates/MenuBarItem.html':"<div class=\"dijitReset dijitInline dijitMenuItem dijitMenuItemLabel\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<span data-dojo-attach-point=\"containerNode\"></span>\n</div>\n",
'curam/debug':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define("curam/debug", ["curam/define",
        "curam/util/LocalConfig"
        ], function(define, localConfig) {
  
  /*
   * Modification History
   * --------------------
   * 11-Apr-2014  MV  [CR00424825] Add support for JavaScript debug
   *    configuration and LocalConfig.
   * 12-Sep-2011  MV  [CR00286500] Fix stack overflow when logging window objects
   *     in IE.
   * 11-May-2011  MV  [CR00265902] Fixed log function invocation.
   * 26-Jan-2011  MV  [CR00244801] Fixed check for DEBUG flag.
   * 21-Jan-2011  DG  [CR00243540] Added note on new way to set DEBUG variable.
   *                    Added copyright. Tidied up formatting.
   * 26-Jun-2010  MV  [CR00204069] Improve to enable passing many number
   *                    of parameters. Enable easier usage by removing class
   *                    declaration and shortening the name.
   * 06-Nov-2009  SC  [CR00172239] Initial Version
   */
  /**
   * Provides a simple logging facility for debug tracing to the JavaScript
   * console.
   */
  define.singleton("curam.debug", {
    /**
     * A logging facility that can be turned on or off using the
     * "curam.trace.javascript" application property. Debug tracing is disabled
     * by default; use your application admin screens to enable it.
     * Any number of parameters can be passed. These are forwarded
     * to the <code>console.log.apply</code> function.
     */
    log: function() {
      if (curam.debug.enabled()) {
        try {
          var a = arguments;
          if (!dojo.isIE) {
            console.log.apply(console, a);
          
          // the above generic call doesn't work in IE  so the following ugly
          // specific handling must be provided
          } else {
            var numArgs = a.length;
            var sa = curam.debug._serializeArgument;
            switch(numArgs) {
              case 1: console.log(arguments[0]);
              break;
              
              case 2: console.log(a[0], sa(a[1]));
              break;
              
              case 3: console.log(a[0], sa(a[1]), sa(a[2]));
              break;
              
              case 4: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]));
              break;
              
              case 5: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]));
              break;
              
              case 6: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]),
                  sa(a[5]));
              break;
              
              default: console.log("[Incomplete message - " + (numArgs - 5)
                  + " message a truncated] " + a[0],
                  sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]), sa(a[5]));
            }
          }

        } catch (e) {
          console.log(e);
          // Some problem with the console. Do nothing.
        }
      }
    },
    
    /**
     * Make a human readable version of the object to be logged.
     *
     * @param arg The object to be serialized.
     * @returns The human readable version of the object.
     */
    _serializeArgument: function(arg) {
      if (typeof arg != "undefined"
          && typeof arg.nodeType != "undefined"
          && typeof arg.cloneNode != "undefined") { // isNode 
        // DOM nodes can't be serialized using dojo.toJson(), so just return
        // default toString version
        return "" + arg;

      } else if (curam.debug._isWindow(arg)) {
        // window object causes stack overflow for dojo.toJson() so handling 
        // specifically here
        return arg.location.href;

      } else if (curam.debug._isArray(arg)
            && curam.debug._isWindow(arg[0])) { // is array of window objects
        // array of window objects causes stack overflow for dojo.toJson()
        // so handling specifically here
        return "[array of window objects, length " + arg.length + "]";

      } else {
        return dojo.toJson(arg);
      }
    },
    
    /**
     * Recognizes array objects.
     * 
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is array, otherwise false.
     */
    _isArray: function(arg) {
      return typeof arg != "undefined"
          && (dojo.isArray(arg) || typeof arg.length != "undefined");
    },

    /**
     * Recognizes window object.
     *
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is a window object,
     *    otherwise false.
     */
    _isWindow: function(arg) {
      // some of the significant properties might be undefined fo closed window
      // so handle this case separately
      var isClosed = typeof arg != "undefined"
        && typeof arg.closed != "undefined" && arg.closed;
      if (isClosed) {
        // it is a closed window
        return true;
      
      } else {
        return typeof arg != "undefined"
            && typeof arg.location != "undefined"
            && typeof arg.navigator != "undefined"
            && typeof arg.document != "undefined"
            && typeof arg.closed != "undefined";
      }
    },
    
    enabled: function() {
      return localConfig.readOption('jsTraceLog', 'false') == 'true';
    },
    
    /**
     * Performs setup of the debug/tracing infrastructure.
     * This is called from the application main page to setup debug.
     *
     * @param {Object} config Configuration data.
     */
    _setup: function(config) {
      localConfig.seedOption('jsTraceLog', config.trace, 'false');
      localConfig.seedOption('ajaxDebugMode', config.ajaxDebug, 'false');
      localConfig.seedOption('asyncProgressMonitor',
          config.asyncProgressMonitor, 'false');
    }
  });
  
  return curam.debug;
});

},
'dijit/TooltipDialog':function(){
require({cache:{
'url:dijit/templates/TooltipDialog.html':"<div role=\"presentation\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" data-dojo-attach-point=\"containerNode\" role=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\"></div>\n</div>\n"}});
define("dijit/TooltipDialog", [
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.replace
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"./focus",
	"./layout/ContentPane",
	"./_DialogMixin",
	"./form/_FormMixin",
	"./_TemplatedMixin",
	"dojo/text!./templates/TooltipDialog.html",
	"."		// exports methods to dijit global
], function(declare, domClass, event, keys, lang,
			focus, ContentPane, _DialogMixin, _FormMixin, _TemplatedMixin, template, dijit){

/*=====
	var ContentPane = dijit.layout.ContentPane;
	var _DialogMixin = dijit._DialogMixin;
	var _FormMixin = dijit.form._FormMixin;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/TooltipDialog
	// summary:
	//		Pops up a dialog that appears like a Tooltip


	return declare("dijit.TooltipDialog",
		[ContentPane, _TemplatedMixin, _FormMixin, _DialogMixin], {
		// summary:
		//		Pops up a dialog that appears like a Tooltip

		// title: String
		// 		Description of tooltip dialog (required for a11y)
		title: "",

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
		//		is never a child of a layout container, nor can you specify the size of
		//		TooltipDialog in order to control the size of an inner widget.
		doLayout: false,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTooltipDialog",

		// _firstFocusItem: [private] [readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private] [readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		templateString: template,

		_setTitleAttr: function(/*String*/ title){
			this.containerNode.title = title;
			this._set("title", title)
		},

		postCreate: function(){
			this.inherited(arguments);
			this.connect(this.containerNode, "onkeypress", "_onKey");
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
			// summary:
			//		Configure widget to be displayed in given position relative to the button.
			//		This is called from the dijit.popup code, and should not be called
			//		directly.
			// tags:
			//		protected
			var newC = "dijitTooltipAB" + (corner.charAt(1) == 'L' ? "Left" : "Right")
					+ " dijitTooltip"
					+ (corner.charAt(0) == 'T' ? "Below" : "Above");

			domClass.replace(this.domNode, newC, this._currentOrientClass || "");
			this._currentOrientClass = newC;
		},

		focus: function(){
			// summary:
			//		Focus on first field
			this._getFocusItems(this.containerNode);
			focus.focus(this._firstFocusItem);
		},

		onOpen: function(/*Object*/ pos){
			// summary:
			//		Called when dialog is displayed.
			//		This is called from the dijit.popup code, and should not be called directly.
			// tags:
			//		protected

			this.orient(this.domNode,pos.aroundCorner, pos.corner);
			this._onShow(); // lazy load trigger
		},

		onClose: function(){
			// summary:
			//		Called when dialog is hidden.
			//		This is called from the dijit.popup code, and should not be called directly.
			// tags:
			//		protected
			this.onHide();
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handler for keyboard events
			// description:
			//		Keep keyboard focus in dialog; close dialog on escape key
			// tags:
			//		private

			var node = evt.target;
			if(evt.charOrCode === keys.TAB){
				this._getFocusItems(this.containerNode);
			}
			var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
			if(evt.charOrCode == keys.ESCAPE){
				// Use setTimeout to avoid crash on IE, see #10396.
				setTimeout(lang.hitch(this, "onCancel"), 0);
				event.stop(evt);
			}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB){
				if(!singleFocusItem){
					focus.focus(this._lastFocusItem); // send focus to last item in dialog
				}
				event.stop(evt);
			}else if(node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey){
				if(!singleFocusItem){
					focus.focus(this._firstFocusItem); // send focus to first item in dialog
				}
				event.stop(evt);
			}else if(evt.charOrCode === keys.TAB){
				// we want the browser's default tab handling to move focus
				// but we don't want the tab to propagate upwards
				evt.stopPropagation();
			}
		}
	});
});

},
'*now':function(r){r(['dojo/i18n!*preload*dojo/nls/cwtk-layer*["de","fr","it","es","pt-br","zh-cn","zh-tw","ja","ko","ROOT"]']);}
}});
define("dojo/cwtk-layer", [], 1);
